/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2020 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.worker", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.worker"] = factory();
	else
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "WorkerMessageHandler", ({
  enumerable: true,
  get: function get() {
    return _worker.WorkerMessageHandler;
  }
}));

var _worker = __w_pdfjs_require__(1);

var pdfjsVersion = '2.8.57';
var pdfjsBuild = '3d33313e4';

/***/ }),
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerTask = exports.WorkerMessageHandler = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _pdf_manager = __w_pdfjs_require__(136);

var _writer = __w_pdfjs_require__(176);

var _is_node = __w_pdfjs_require__(6);

var _message_handler = __w_pdfjs_require__(178);

var _worker_stream = __w_pdfjs_require__(179);

var _core_utils = __w_pdfjs_require__(138);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WorkerTask = /*#__PURE__*/function () {
  function WorkerTask(name) {
    _classCallCheck(this, WorkerTask);

    this.name = name;
    this.terminated = false;
    this._capability = (0, _util.createPromiseCapability)();
  }

  _createClass(WorkerTask, [{
    key: "finished",
    get: function get() {
      return this._capability.promise;
    }
  }, {
    key: "finish",
    value: function finish() {
      this._capability.resolve();
    }
  }, {
    key: "terminate",
    value: function terminate() {
      this.terminated = true;
    }
  }, {
    key: "ensureNotTerminated",
    value: function ensureNotTerminated() {
      if (this.terminated) {
        throw new Error("Worker task was terminated");
      }
    }
  }]);

  return WorkerTask;
}();

exports.WorkerTask = WorkerTask;

var WorkerMessageHandler = /*#__PURE__*/function () {
  function WorkerMessageHandler() {
    _classCallCheck(this, WorkerMessageHandler);
  }

  _createClass(WorkerMessageHandler, null, [{
    key: "setup",
    value: function setup(handler, port) {
      var testMessageProcessed = false;
      handler.on("test", function wphSetupTest(data) {
        if (testMessageProcessed) {
          return;
        }

        testMessageProcessed = true;

        if (!(data instanceof Uint8Array)) {
          handler.send("test", null);
          return;
        }

        var supportTransfers = data[0] === 255;
        handler.postMessageTransfers = supportTransfers;
        handler.send("test", {
          supportTransfers: supportTransfers
        });
      });
      handler.on("configure", function wphConfigure(data) {
        (0, _util.setVerbosityLevel)(data.verbosity);
      });
      handler.on("GetDocRequest", function wphSetupDoc(data) {
        return WorkerMessageHandler.createDocumentHandler(data, port);
      });
    }
  }, {
    key: "createDocumentHandler",
    value: function createDocumentHandler(docParams, port) {
      var pdfManager;
      var terminated = false;
      var cancelXHRs = null;
      var WorkerTasks = [];
      var verbosity = (0, _util.getVerbosityLevel)();
      var apiVersion = docParams.apiVersion;
      var workerVersion = '2.8.57';

      if (apiVersion !== workerVersion) {
        throw new Error("The API version \"".concat(apiVersion, "\" does not match ") + "the Worker version \"".concat(workerVersion, "\"."));
      }

      var enumerableProperties = [];

      for (var property in []) {
        enumerableProperties.push(property);
      }

      if (enumerableProperties.length) {
        throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
      }

      var docId = docParams.docId;
      var docBaseUrl = docParams.docBaseUrl;
      var workerHandlerName = docParams.docId + "_worker";
      var handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
      handler.postMessageTransfers = docParams.postMessageTransfers;

      function ensureNotTerminated() {
        if (terminated) {
          throw new Error("Worker was terminated");
        }
      }

      function startWorkerTask(task) {
        WorkerTasks.push(task);
      }

      function finishWorkerTask(task) {
        task.finish();
        var i = WorkerTasks.indexOf(task);
        WorkerTasks.splice(i, 1);
      }

      function loadDocument(_x) {
        return _loadDocument.apply(this, arguments);
      }

      function _loadDocument() {
        _loadDocument = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(recoveryMode) {
          var _yield$Promise$all, _yield$Promise$all2, numPages, fingerprint;

          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return pdfManager.ensureDoc("checkHeader");

                case 2:
                  _context.next = 4;
                  return pdfManager.ensureDoc("parseStartXRef");

                case 4:
                  _context.next = 6;
                  return pdfManager.ensureDoc("parse", [recoveryMode]);

                case 6:
                  if (recoveryMode) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 9;
                  return pdfManager.ensureDoc("checkFirstPage");

                case 9:
                  _context.next = 11;
                  return Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprint")]);

                case 11:
                  _yield$Promise$all = _context.sent;
                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                  numPages = _yield$Promise$all2[0];
                  fingerprint = _yield$Promise$all2[1];
                  return _context.abrupt("return", {
                    numPages: numPages,
                    fingerprint: fingerprint
                  });

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _loadDocument.apply(this, arguments);
      }

      function getPdfManager(data, evaluatorOptions) {
        var pdfManagerCapability = (0, _util.createPromiseCapability)();
        var newPdfManager;
        var source = data.source;

        if (source.data) {
          try {
            newPdfManager = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, evaluatorOptions, docBaseUrl);
            pdfManagerCapability.resolve(newPdfManager);
          } catch (ex) {
            pdfManagerCapability.reject(ex);
          }

          return pdfManagerCapability.promise;
        }

        var pdfStream,
            cachedChunks = [];

        try {
          pdfStream = new _worker_stream.PDFWorkerStream(handler);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
          return pdfManagerCapability.promise;
        }

        var fullRequest = pdfStream.getFullReader();
        fullRequest.headersReady.then(function () {
          if (!fullRequest.isRangeSupported) {
            return;
          }

          var disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
          newPdfManager = new _pdf_manager.NetworkPdfManager(docId, pdfStream, {
            msgHandler: handler,
            password: source.password,
            length: fullRequest.contentLength,
            disableAutoFetch: disableAutoFetch,
            rangeChunkSize: source.rangeChunkSize
          }, evaluatorOptions, docBaseUrl);

          for (var i = 0; i < cachedChunks.length; i++) {
            newPdfManager.sendProgressiveData(cachedChunks[i]);
          }

          cachedChunks = [];
          pdfManagerCapability.resolve(newPdfManager);
          cancelXHRs = null;
        })["catch"](function (reason) {
          pdfManagerCapability.reject(reason);
          cancelXHRs = null;
        });
        var loaded = 0;

        var flushChunks = function flushChunks() {
          var pdfFile = (0, _util.arraysToBytes)(cachedChunks);

          if (source.length && pdfFile.length !== source.length) {
            (0, _util.warn)("reported HTTP length is different from actual");
          }

          try {
            newPdfManager = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, docBaseUrl);
            pdfManagerCapability.resolve(newPdfManager);
          } catch (ex) {
            pdfManagerCapability.reject(ex);
          }

          cachedChunks = [];
        };

        var readPromise = new Promise(function (resolve, reject) {
          var readChunk = function readChunk(_ref) {
            var value = _ref.value,
                done = _ref.done;

            try {
              ensureNotTerminated();

              if (done) {
                if (!newPdfManager) {
                  flushChunks();
                }

                cancelXHRs = null;
                return;
              }

              loaded += (0, _util.arrayByteLength)(value);

              if (!fullRequest.isStreamingSupported) {
                handler.send("DocProgress", {
                  loaded: loaded,
                  total: Math.max(loaded, fullRequest.contentLength || 0)
                });
              }

              if (newPdfManager) {
                newPdfManager.sendProgressiveData(value);
              } else {
                cachedChunks.push(value);
              }

              fullRequest.read().then(readChunk, reject);
            } catch (e) {
              reject(e);
            }
          };

          fullRequest.read().then(readChunk, reject);
        });
        readPromise["catch"](function (e) {
          pdfManagerCapability.reject(e);
          cancelXHRs = null;
        });

        cancelXHRs = function cancelXHRs(reason) {
          pdfStream.cancelAllRequests(reason);
        };

        return pdfManagerCapability.promise;
      }

      function setupDoc(data) {
        function onSuccess(doc) {
          ensureNotTerminated();
          handler.send("GetDoc", {
            pdfInfo: doc
          });
        }

        function onFailure(ex) {
          ensureNotTerminated();

          if (ex instanceof _util.PasswordException) {
            var task = new WorkerTask("PasswordException: response ".concat(ex.code));
            startWorkerTask(task);
            handler.sendWithPromise("PasswordRequest", ex).then(function (_ref2) {
              var password = _ref2.password;
              finishWorkerTask(task);
              pdfManager.updatePassword(password);
              pdfManagerReady();
            })["catch"](function () {
              finishWorkerTask(task);
              handler.send("DocException", ex);
            });
          } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
            handler.send("DocException", ex);
          } else {
            handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
          }
        }

        function pdfManagerReady() {
          ensureNotTerminated();
          loadDocument(false).then(onSuccess, function (reason) {
            ensureNotTerminated();

            if (!(reason instanceof _core_utils.XRefParseException)) {
              onFailure(reason);
              return;
            }

            pdfManager.requestLoadedStream();
            pdfManager.onLoadedStream().then(function () {
              ensureNotTerminated();
              loadDocument(true).then(onSuccess, onFailure);
            });
          });
        }

        ensureNotTerminated();
        var evaluatorOptions = {
          maxImageSize: data.maxImageSize,
          disableFontFace: data.disableFontFace,
          ignoreErrors: data.ignoreErrors,
          isEvalSupported: data.isEvalSupported,
          fontExtraProperties: data.fontExtraProperties
        };
        getPdfManager(data, evaluatorOptions).then(function (newPdfManager) {
          if (terminated) {
            newPdfManager.terminate(new _util.AbortException("Worker was terminated."));
            throw new Error("Worker was terminated");
          }

          pdfManager = newPdfManager;
          pdfManager.onLoadedStream().then(function (stream) {
            handler.send("DataLoaded", {
              length: stream.bytes.byteLength
            });
          });
        }).then(pdfManagerReady, onFailure);
      }

      handler.on("GetPage", function wphSetupGetPage(data) {
        return pdfManager.getPage(data.pageIndex).then(function (page) {
          return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 4),
                rotate = _ref4[0],
                ref = _ref4[1],
                userUnit = _ref4[2],
                view = _ref4[3];

            return {
              rotate: rotate,
              ref: ref,
              userUnit: userUnit,
              view: view
            };
          });
        });
      });
      handler.on("GetPageIndex", function wphSetupGetPageIndex(_ref5) {
        var ref = _ref5.ref;

        var pageRef = _primitives.Ref.get(ref.num, ref.gen);

        return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
      });
      handler.on("GetDestinations", function wphSetupGetDestinations(data) {
        return pdfManager.ensureCatalog("destinations");
      });
      handler.on("GetDestination", function wphSetupGetDestination(data) {
        return pdfManager.ensureCatalog("getDestination", [data.id]);
      });
      handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
        return pdfManager.ensureCatalog("pageLabels");
      });
      handler.on("GetPageLayout", function wphSetupGetPageLayout(data) {
        return pdfManager.ensureCatalog("pageLayout");
      });
      handler.on("GetPageMode", function wphSetupGetPageMode(data) {
        return pdfManager.ensureCatalog("pageMode");
      });
      handler.on("GetViewerPreferences", function (data) {
        return pdfManager.ensureCatalog("viewerPreferences");
      });
      handler.on("GetOpenAction", function (data) {
        return pdfManager.ensureCatalog("openAction");
      });
      handler.on("GetAttachments", function wphSetupGetAttachments(data) {
        return pdfManager.ensureCatalog("attachments");
      });
      handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
        return pdfManager.ensureCatalog("javaScript");
      });
      handler.on("GetDocJSActions", function wphSetupGetDocJSActions(data) {
        return pdfManager.ensureCatalog("jsActions");
      });
      handler.on("GetPageJSActions", function (_ref6) {
        var pageIndex = _ref6.pageIndex;
        return pdfManager.getPage(pageIndex).then(function (page) {
          return page.jsActions;
        });
      });
      handler.on("GetOutline", function wphSetupGetOutline(data) {
        return pdfManager.ensureCatalog("documentOutline");
      });
      handler.on("GetOptionalContentConfig", function (data) {
        return pdfManager.ensureCatalog("optionalContentConfig");
      });
      handler.on("GetPermissions", function (data) {
        return pdfManager.ensureCatalog("permissions");
      });
      handler.on("GetMetadata", function wphSetupGetMetadata(data) {
        return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
      });
      handler.on("GetMarkInfo", function wphSetupGetMarkInfo(data) {
        return pdfManager.ensureCatalog("markInfo");
      });
      handler.on("GetData", function wphSetupGetData(data) {
        pdfManager.requestLoadedStream();
        return pdfManager.onLoadedStream().then(function (stream) {
          return stream.bytes;
        });
      });
      handler.on("GetStats", function wphSetupGetStats(data) {
        return pdfManager.ensureXRef("stats");
      });
      handler.on("GetAnnotations", function (_ref7) {
        var pageIndex = _ref7.pageIndex,
            intent = _ref7.intent;
        return pdfManager.getPage(pageIndex).then(function (page) {
          return page.getAnnotationsData(intent);
        });
      });
      handler.on("GetFieldObjects", function (data) {
        return pdfManager.ensureDoc("fieldObjects");
      });
      handler.on("HasJSActions", function (data) {
        return pdfManager.ensureDoc("hasJSActions");
      });
      handler.on("GetCalculationOrderIds", function (data) {
        return pdfManager.ensureDoc("calculationOrderIds");
      });
      handler.on("SaveDocument", function (_ref8) {
        var numPages = _ref8.numPages,
            annotationStorage = _ref8.annotationStorage,
            filename = _ref8.filename;
        pdfManager.requestLoadedStream();
        var promises = [pdfManager.onLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("startXRef")];

        var _loop = function _loop(pageIndex) {
          promises.push(pdfManager.getPage(pageIndex).then(function (page) {
            var task = new WorkerTask("Save: page ".concat(pageIndex));
            startWorkerTask(task);
            return page.save(handler, task, annotationStorage)["finally"](function () {
              finishWorkerTask(task);
            });
          }));
        };

        for (var pageIndex = 0; pageIndex < numPages; pageIndex++) {
          _loop(pageIndex);
        }

        return Promise.all(promises).then(function (_ref9) {
          var _ref10 = _toArray(_ref9),
              stream = _ref10[0],
              acroForm = _ref10[1],
              xref = _ref10[2],
              startXRef = _ref10[3],
              refs = _ref10.slice(4);

          var newRefs = [];

          var _iterator = _createForOfIteratorHelper(refs),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var ref = _step.value;
              newRefs = ref.filter(function (x) {
                return x !== null;
              }).reduce(function (a, b) {
                return a.concat(b);
              }, newRefs);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (newRefs.length === 0) {
            return stream.bytes;
          }

          var xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || [];
          var xfaDatasets = null;

          if (Array.isArray(xfa)) {
            for (var i = 0, ii = xfa.length; i < ii; i += 2) {
              if (xfa[i] === "datasets") {
                xfaDatasets = xfa[i + 1];
              }
            }
          } else {
            (0, _util.warn)("Unsupported XFA type.");
          }

          var newXrefInfo = Object.create(null);

          if (xref.trailer) {
            var infoObj = Object.create(null);
            var xrefInfo = xref.trailer.get("Info") || null;

            if (xrefInfo instanceof _primitives.Dict) {
              xrefInfo.forEach(function (key, value) {
                if ((0, _util.isString)(key) && (0, _util.isString)(value)) {
                  infoObj[key] = (0, _util.stringToPDFString)(value);
                }
              });
            }

            newXrefInfo = {
              rootRef: xref.trailer.getRaw("Root") || null,
              encrypt: xref.trailer.getRaw("Encrypt") || null,
              newRef: xref.getNewRef(),
              infoRef: xref.trailer.getRaw("Info") || null,
              info: infoObj,
              fileIds: xref.trailer.getRaw("ID") || null,
              startXRef: startXRef,
              filename: filename
            };
          }

          xref.resetNewRef();
          return (0, _writer.incrementalUpdate)({
            originalData: stream.bytes,
            xrefInfo: newXrefInfo,
            newRefs: newRefs,
            xref: xref,
            datasetsRef: xfaDatasets
          });
        });
      });
      handler.on("GetOperatorList", function wphSetupRenderPage(data, sink) {
        var pageIndex = data.pageIndex;
        pdfManager.getPage(pageIndex).then(function (page) {
          var task = new WorkerTask("GetOperatorList: page ".concat(pageIndex));
          startWorkerTask(task);
          var start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
          page.getOperatorList({
            handler: handler,
            sink: sink,
            task: task,
            intent: data.intent,
            renderInteractiveForms: data.renderInteractiveForms,
            annotationStorage: data.annotationStorage
          }).then(function (operatorListInfo) {
            finishWorkerTask(task);

            if (start) {
              (0, _util.info)("page=".concat(pageIndex + 1, " - getOperatorList: time=") + "".concat(Date.now() - start, "ms, len=").concat(operatorListInfo.length));
            }

            sink.close();
          }, function (reason) {
            finishWorkerTask(task);

            if (task.terminated) {
              return;
            }

            handler.send("UnsupportedFeature", {
              featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
            });
            sink.error(reason);
          });
        });
      });
      handler.on("GetTextContent", function wphExtractText(data, sink) {
        var pageIndex = data.pageIndex;

        sink.onPull = function (desiredSize) {};

        sink.onCancel = function (reason) {};

        pdfManager.getPage(pageIndex).then(function (page) {
          var task = new WorkerTask("GetTextContent: page " + pageIndex);
          startWorkerTask(task);
          var start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
          page.extractTextContent({
            handler: handler,
            task: task,
            sink: sink,
            normalizeWhitespace: data.normalizeWhitespace,
            combineTextItems: data.combineTextItems
          }).then(function () {
            finishWorkerTask(task);

            if (start) {
              (0, _util.info)("page=".concat(pageIndex + 1, " - getTextContent: time=") + "".concat(Date.now() - start, "ms"));
            }

            sink.close();
          }, function (reason) {
            finishWorkerTask(task);

            if (task.terminated) {
              return;
            }

            sink.error(reason);
          });
        });
      });
      handler.on("FontFallback", function (data) {
        return pdfManager.fontFallback(data.id, handler);
      });
      handler.on("Cleanup", function wphCleanup(data) {
        return pdfManager.cleanup(true);
      });
      handler.on("Terminate", function wphTerminate(data) {
        terminated = true;
        var waitOn = [];

        if (pdfManager) {
          pdfManager.terminate(new _util.AbortException("Worker was terminated."));
          var cleanupPromise = pdfManager.cleanup();
          waitOn.push(cleanupPromise);
          pdfManager = null;
        } else {
          (0, _primitives.clearPrimitiveCaches)();
        }

        if (cancelXHRs) {
          cancelXHRs(new _util.AbortException("Worker was terminated."));
        }

        WorkerTasks.forEach(function (task) {
          waitOn.push(task.finished);
          task.terminate();
        });
        return Promise.all(waitOn).then(function () {
          handler.destroy();
          handler = null;
        });
      });
      handler.on("Ready", function wphReady(data) {
        setupDoc(docParams);
        docParams = null;
      });
      return workerHandlerName;
    }
  }, {
    key: "initializeFromPort",
    value: function initializeFromPort(port) {
      var handler = new _message_handler.MessageHandler("worker", "main", port);
      WorkerMessageHandler.setup(handler, port);
      handler.send("ready", null);
    }
  }]);

  return WorkerMessageHandler;
}();

exports.WorkerMessageHandler = WorkerMessageHandler;

function isMessagePort(maybePort) {
  return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
}

if (typeof window === "undefined" && !_is_node.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
  WorkerMessageHandler.initializeFromPort(self);
}

/***/ }),
/* 2 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";


module.exports = __w_pdfjs_require__(3);

/***/ }),
/* 3 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";
/* module decorator */ module = __w_pdfjs_require__.nmd(module);


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined;
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);
    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap;

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator;

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator["return"]) {
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      context[delegate.resultName] = info.value;
      context.next = delegate.nextLoc;

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      return info;
    }

    context.delegate = null;
    return ContinueSentinel;
  }

  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator");

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse();
    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
  return exports;
}(( false ? 0 : _typeof(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.encodeToXmlString = encodeToXmlString;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.isBool = isBool;
exports.isNum = isNum;
exports.isSameOrigin = isSameOrigin;
exports.isString = isString;
exports.objectFromEntries = objectFromEntries;
exports.objectSize = objectSize;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.createObjectURL = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

__w_pdfjs_require__(5);

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
var PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
var AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
var AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
var AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
var AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
var AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
var AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
var AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
var DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
var PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
var StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
var FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
var CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
var UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
var verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log("Info: ".concat(msg));
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log("Warning: ".concat(msg));
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function isSameOrigin(baseUrl, otherUrl) {
  var base;

  try {
    base = new URL(baseUrl);

    if (!base.origin || base.origin === "null") {
      return false;
    }
  } catch (e) {
    return false;
  }

  var other = new URL(otherUrl, base);
  return base.origin === other.origin;
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }

  try {
    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

var BaseException = function BaseExceptionClosure() {
  function BaseException(message) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = this.constructor.name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

var PasswordException = /*#__PURE__*/function (_BaseException) {
  _inherits(PasswordException, _BaseException);

  var _super = _createSuper(PasswordException);

  function PasswordException(msg, code) {
    var _this;

    _classCallCheck(this, PasswordException);

    _this = _super.call(this, msg);
    _this.code = code;
    return _this;
  }

  return PasswordException;
}(BaseException);

exports.PasswordException = PasswordException;

var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
  _inherits(UnknownErrorException, _BaseException2);

  var _super2 = _createSuper(UnknownErrorException);

  function UnknownErrorException(msg, details) {
    var _this2;

    _classCallCheck(this, UnknownErrorException);

    _this2 = _super2.call(this, msg);
    _this2.details = details;
    return _this2;
  }

  return UnknownErrorException;
}(BaseException);

exports.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
  _inherits(InvalidPDFException, _BaseException3);

  var _super3 = _createSuper(InvalidPDFException);

  function InvalidPDFException() {
    _classCallCheck(this, InvalidPDFException);

    return _super3.apply(this, arguments);
  }

  return InvalidPDFException;
}(BaseException);

exports.InvalidPDFException = InvalidPDFException;

var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
  _inherits(MissingPDFException, _BaseException4);

  var _super4 = _createSuper(MissingPDFException);

  function MissingPDFException() {
    _classCallCheck(this, MissingPDFException);

    return _super4.apply(this, arguments);
  }

  return MissingPDFException;
}(BaseException);

exports.MissingPDFException = MissingPDFException;

var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
  _inherits(UnexpectedResponseException, _BaseException5);

  var _super5 = _createSuper(UnexpectedResponseException);

  function UnexpectedResponseException(msg, status) {
    var _this3;

    _classCallCheck(this, UnexpectedResponseException);

    _this3 = _super5.call(this, msg);
    _this3.status = status;
    return _this3;
  }

  return UnexpectedResponseException;
}(BaseException);

exports.UnexpectedResponseException = UnexpectedResponseException;

var FormatError = /*#__PURE__*/function (_BaseException6) {
  _inherits(FormatError, _BaseException6);

  var _super6 = _createSuper(FormatError);

  function FormatError() {
    _classCallCheck(this, FormatError);

    return _super6.apply(this, arguments);
  }

  return FormatError;
}(BaseException);

exports.FormatError = FormatError;

var AbortException = /*#__PURE__*/function (_BaseException7) {
  _inherits(AbortException, _BaseException7);

  var _super7 = _createSuper(AbortException);

  function AbortException() {
    _classCallCheck(this, AbortException);

    return _super7.apply(this, arguments);
  }

  return AbortException;
}(BaseException);

exports.AbortException = AbortException;
var NullCharactersRegExp = /\x00/g;

function removeNullCharacters(str) {
  if (typeof str !== "string") {
    warn("The argument for removeNullCharacters must be a string.");
    return str;
  }

  return str.replace(NullCharactersRegExp, "");
}

function bytesToString(bytes) {
  assert(bytes !== null && _typeof(bytes) === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  var strBuf = [];

  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  assert(typeof str === "string", "Invalid argument for stringToBytes");
  var length = str.length;
  var bytes = new Uint8Array(length);

  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
  return arr.byteLength;
}

function arraysToBytes(arr) {
  var length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  var resultLength = 0;

  for (var i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  var pos = 0;
  var data = new Uint8Array(resultLength);

  for (var _i = 0; _i < length; _i++) {
    var item = arr[_i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    var itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromEntries(iterable) {
  return Object.assign(Object.create(null), Object.fromEntries(iterable));
}

function isLittleEndian() {
  var buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

var IsLittleEndianCached = {
  get value() {
    return shadow(this, "value", isLittleEndian());
  }

};
exports.IsLittleEndianCached = IsLittleEndianCached;

function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}

var IsEvalSupportedCached = {
  get value() {
    return shadow(this, "value", isEvalSupported());
  }

};
exports.IsEvalSupportedCached = IsEvalSupportedCached;

var hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {
  return n.toString(16).padStart(2, "0");
});

var Util = /*#__PURE__*/function () {
  function Util() {
    _classCallCheck(this, Util);
  }

  _createClass(Util, null, [{
    key: "makeHexColor",
    value: function makeHexColor(r, g, b) {
      return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
    }
  }, {
    key: "transform",
    value: function transform(m1, m2) {
      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
    }
  }, {
    key: "applyTransform",
    value: function applyTransform(p, m) {
      var xt = p[0] * m[0] + p[1] * m[2] + m[4];
      var yt = p[0] * m[1] + p[1] * m[3] + m[5];
      return [xt, yt];
    }
  }, {
    key: "applyInverseTransform",
    value: function applyInverseTransform(p, m) {
      var d = m[0] * m[3] - m[1] * m[2];
      var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
      var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
      return [xt, yt];
    }
  }, {
    key: "getAxialAlignedBoundingBox",
    value: function getAxialAlignedBoundingBox(r, m) {
      var p1 = Util.applyTransform(r, m);
      var p2 = Util.applyTransform(r.slice(2, 4), m);
      var p3 = Util.applyTransform([r[0], r[3]], m);
      var p4 = Util.applyTransform([r[2], r[1]], m);
      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
    }
  }, {
    key: "inverseTransform",
    value: function inverseTransform(m) {
      var d = m[0] * m[3] - m[1] * m[2];
      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
    }
  }, {
    key: "apply3dTransform",
    value: function apply3dTransform(m, v) {
      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
    }
  }, {
    key: "singularValueDecompose2dScale",
    value: function singularValueDecompose2dScale(m) {
      var transpose = [m[0], m[2], m[1], m[3]];
      var a = m[0] * transpose[0] + m[1] * transpose[2];
      var b = m[0] * transpose[1] + m[1] * transpose[3];
      var c = m[2] * transpose[0] + m[3] * transpose[2];
      var d = m[2] * transpose[1] + m[3] * transpose[3];
      var first = (a + d) / 2;
      var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
      var sx = first + second || 1;
      var sy = first - second || 1;
      return [Math.sqrt(sx), Math.sqrt(sy)];
    }
  }, {
    key: "normalizeRect",
    value: function normalizeRect(rect) {
      var r = rect.slice(0);

      if (rect[0] > rect[2]) {
        r[0] = rect[2];
        r[2] = rect[0];
      }

      if (rect[1] > rect[3]) {
        r[1] = rect[3];
        r[3] = rect[1];
      }

      return r;
    }
  }, {
    key: "intersect",
    value: function intersect(rect1, rect2) {
      function compare(a, b) {
        return a - b;
      }

      var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
      var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
      var result = [];
      rect1 = Util.normalizeRect(rect1);
      rect2 = Util.normalizeRect(rect2);

      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
        result[0] = orderedX[1];
        result[2] = orderedX[2];
      } else {
        return null;
      }

      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
        result[1] = orderedY[1];
        result[3] = orderedY[2];
      } else {
        return null;
      }

      return result;
    }
  }]);

  return Util;
}();

exports.Util = Util;
var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

function stringToPDFString(str) {
  var length = str.length,
      strBuf = [];

  if (str[0] === "\xFE" && str[1] === "\xFF") {
    for (var i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
    for (var _i2 = 2; _i2 < length; _i2 += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
    }
  } else {
    for (var _i3 = 0; _i3 < length; ++_i3) {
      var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
    }
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, function (match) {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return "\\".concat(match);
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  var buf = ["\xFE\xFF"];

  for (var i = 0, ii = str.length; i < ii; i++) {
    var _char = str.charCodeAt(i);

    buf.push(String.fromCharCode(_char >> 8 & 0xff));
    buf.push(String.fromCharCode(_char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isBool(v) {
  return typeof v === "boolean";
}

function isNum(v) {
  return typeof v === "number";
}

function isString(v) {
  return typeof v === "string";
}

function isArrayBuffer(v) {
  return _typeof(v) === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  return arr1.every(function (element, index) {
    return element === arr2[index];
  });
}

function getModificationDate() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  var capability = Object.create(null);
  var isSettled = false;
  Object.defineProperty(capability, "settled", {
    get: function get() {
      return isSettled;
    }
  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

var createObjectURL = function createObjectURLClosure() {
  var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  return function createObjectURL(data, contentType) {
    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!forceDataSchema && URL.createObjectURL) {
      var blob = new Blob([data], {
        type: contentType
      });
      return URL.createObjectURL(blob);
    }

    var buffer = "data:".concat(contentType, ";base64,");

    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xff;
      var b2 = data[i + 1] & 0xff;
      var b3 = data[i + 2] & 0xff;
      var d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
      var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
      var d4 = i + 2 < ii ? b3 & 0x3f : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }

    return buffer;
  };
}();

exports.createObjectURL = createObjectURL;
var XMLEntities = {
  0x3c: "&lt;",
  0x3e: "&gt;",
  0x26: "&amp;",
  0x22: "&quot;",
  0x27: "&apos;"
};

function encodeToXmlString(str) {
  var buffer = [];
  var start = 0;

  for (var i = 0, ii = str.length; i < ii; i++) {
    var _char2 = str.codePointAt(i);

    if (0x20 <= _char2 && _char2 <= 0x7e) {
      var entity = XMLEntities[_char2];

      if (entity) {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }

        buffer.push(entity);
        start = i + 1;
      }
    } else {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }

      buffer.push("&#x".concat(_char2.toString(16).toUpperCase(), ";"));

      if (_char2 > 0xd7ff && (_char2 < 0xe000 || _char2 > 0xfffd)) {
        i++;
      }

      start = i + 1;
    }
  }

  if (buffer.length === 0) {
    return str;
  }

  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }

  return buffer.join("");
}

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";


var _is_node = __w_pdfjs_require__(6);

if (typeof globalThis === "undefined" || !globalThis._pdfjsCompatibilityChecked) {
  if (typeof globalThis === "undefined" || globalThis.Math !== Math) {
    globalThis = __w_pdfjs_require__(7);
  }

  globalThis._pdfjsCompatibilityChecked = true;

  (function checkNodeBtoa() {
    if (globalThis.btoa || !_is_node.isNodeJS) {
      return;
    }

    globalThis.btoa = function (chars) {
      return Buffer.from(chars, "binary").toString("base64");
    };
  })();

  (function checkNodeAtob() {
    if (globalThis.atob || !_is_node.isNodeJS) {
      return;
    }

    globalThis.atob = function (input) {
      return Buffer.from(input, "base64").toString("binary");
    };
  })();

  (function checkObjectFromEntries() {
    if (Object.fromEntries) {
      return;
    }

    __w_pdfjs_require__(52);
  })();

  (function checkPromise() {
    if (globalThis.Promise.allSettled) {
      return;
    }

    globalThis.Promise = __w_pdfjs_require__(82);
  })();

  (function checkURL() {
    globalThis.URL = __w_pdfjs_require__(111);
  })();

  (function checkReadableStream() {
    var isReadableStreamSupported = false;

    if (typeof ReadableStream !== "undefined") {
      try {
        new ReadableStream({
          start: function start(controller) {
            controller.close();
          }
        });
        isReadableStreamSupported = true;
      } catch (e) {}
    }

    if (isReadableStreamSupported) {
      return;
    }

    globalThis.ReadableStream = __w_pdfjs_require__(121).ReadableStream;
  })();

  (function checkStringPadStart() {
    if (String.prototype.padStart) {
      return;
    }

    __w_pdfjs_require__(122);
  })();

  (function checkStringPadEnd() {
    if (String.prototype.padEnd) {
      return;
    }

    __w_pdfjs_require__(128);
  })();

  (function checkObjectValues() {
    if (Object.values) {
      return;
    }

    Object.values = __w_pdfjs_require__(130);
  })();

  (function checkObjectEntries() {
    if (Object.entries) {
      return;
    }

    Object.entries = __w_pdfjs_require__(133);
  })();
}

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 7 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(8);
module.exports = __w_pdfjs_require__(10);

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(9);
var global = __w_pdfjs_require__(10);
$({ global: true }, { globalThis: global });

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var getOwnPropertyDescriptor = __w_pdfjs_require__(11).f;
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var redefine = __w_pdfjs_require__(28);
var setGlobal = __w_pdfjs_require__(29);
var copyConstructorProperties = __w_pdfjs_require__(39);
var isForced = __w_pdfjs_require__(51);
module.exports = function (options, source) {
 var TARGET = options.target;
 var GLOBAL = options.global;
 var STATIC = options.stat;
 var FORCED, target, key, targetProperty, sourceProperty, descriptor;
 if (GLOBAL) {
  target = global;
 } else if (STATIC) {
  target = global[TARGET] || setGlobal(TARGET, {});
 } else {
  target = (global[TARGET] || {}).prototype;
 }
 if (target)
  for (key in source) {
   sourceProperty = source[key];
   if (options.noTargetGet) {
    descriptor = getOwnPropertyDescriptor(target, key);
    targetProperty = descriptor && descriptor.value;
   } else
    targetProperty = target[key];
   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
   if (!FORCED && targetProperty !== undefined) {
    if (typeof sourceProperty === typeof targetProperty)
     continue;
    copyConstructorProperties(sourceProperty, targetProperty);
   }
   if (options.sham || targetProperty && targetProperty.sham) {
    createNonEnumerableProperty(sourceProperty, 'sham', true);
   }
   redefine(target, key, sourceProperty, options);
  }
};

/***/ }),
/* 10 */
/***/ ((module) => {

var check = function (it) {
 return it && it.Math == Math && it;
};
module.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || function () {
 return this;
}() || Function('return this')();

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var propertyIsEnumerableModule = __w_pdfjs_require__(14);
var createPropertyDescriptor = __w_pdfjs_require__(15);
var toIndexedObject = __w_pdfjs_require__(16);
var toPrimitive = __w_pdfjs_require__(20);
var has = __w_pdfjs_require__(22);
var IE8_DOM_DEFINE = __w_pdfjs_require__(23);
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
 O = toIndexedObject(O);
 P = toPrimitive(P, true);
 if (IE8_DOM_DEFINE)
  try {
   return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
  }
 if (has(O, P))
  return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

/***/ }),
/* 12 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
module.exports = !fails(function () {
 return Object.defineProperty({}, 1, {
  get: function () {
   return 7;
  }
 })[1] != 7;
});

/***/ }),
/* 13 */
/***/ ((module) => {

module.exports = function (exec) {
 try {
  return !!exec();
 } catch (error) {
  return true;
 }
};

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
 var descriptor = getOwnPropertyDescriptor(this, V);
 return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

/***/ }),
/* 15 */
/***/ ((module) => {

module.exports = function (bitmap, value) {
 return {
  enumerable: !(bitmap & 1),
  configurable: !(bitmap & 2),
  writable: !(bitmap & 4),
  value: value
 };
};

/***/ }),
/* 16 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IndexedObject = __w_pdfjs_require__(17);
var requireObjectCoercible = __w_pdfjs_require__(19);
module.exports = function (it) {
 return IndexedObject(requireObjectCoercible(it));
};

/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
var classof = __w_pdfjs_require__(18);
var split = ''.split;
module.exports = fails(function () {
 return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
 return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

/***/ }),
/* 18 */
/***/ ((module) => {

var toString = {}.toString;
module.exports = function (it) {
 return toString.call(it).slice(8, -1);
};

/***/ }),
/* 19 */
/***/ ((module) => {

module.exports = function (it) {
 if (it == undefined)
  throw TypeError("Can't call method on " + it);
 return it;
};

/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isObject = __w_pdfjs_require__(21);
module.exports = function (input, PREFERRED_STRING) {
 if (!isObject(input))
  return input;
 var fn, val;
 if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))
  return val;
 if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input)))
  return val;
 if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))
  return val;
 throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 21 */
/***/ ((module) => {

module.exports = function (it) {
 return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 22 */
/***/ ((module) => {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
 return hasOwnProperty.call(it, key);
};

/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var fails = __w_pdfjs_require__(13);
var createElement = __w_pdfjs_require__(24);
module.exports = !DESCRIPTORS && !fails(function () {
 return Object.defineProperty(createElement('div'), 'a', {
  get: function () {
   return 7;
  }
 }).a != 7;
});

/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var isObject = __w_pdfjs_require__(21);
var document = global.document;
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
 return EXISTS ? document.createElement(it) : {};
};

/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var definePropertyModule = __w_pdfjs_require__(26);
var createPropertyDescriptor = __w_pdfjs_require__(15);
module.exports = DESCRIPTORS ? function (object, key, value) {
 return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
 object[key] = value;
 return object;
};

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var IE8_DOM_DEFINE = __w_pdfjs_require__(23);
var anObject = __w_pdfjs_require__(27);
var toPrimitive = __w_pdfjs_require__(20);
var nativeDefineProperty = Object.defineProperty;
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
 anObject(O);
 P = toPrimitive(P, true);
 anObject(Attributes);
 if (IE8_DOM_DEFINE)
  try {
   return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
  }
 if ('get' in Attributes || 'set' in Attributes)
  throw TypeError('Accessors not supported');
 if ('value' in Attributes)
  O[P] = Attributes.value;
 return O;
};

/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isObject = __w_pdfjs_require__(21);
module.exports = function (it) {
 if (!isObject(it)) {
  throw TypeError(String(it) + ' is not an object');
 }
 return it;
};

/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var has = __w_pdfjs_require__(22);
var setGlobal = __w_pdfjs_require__(29);
var inspectSource = __w_pdfjs_require__(30);
var InternalStateModule = __w_pdfjs_require__(32);
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function (O, key, value, options) {
 var unsafe = options ? !!options.unsafe : false;
 var simple = options ? !!options.enumerable : false;
 var noTargetGet = options ? !!options.noTargetGet : false;
 var state;
 if (typeof value == 'function') {
  if (typeof key == 'string' && !has(value, 'name')) {
   createNonEnumerableProperty(value, 'name', key);
  }
  state = enforceInternalState(value);
  if (!state.source) {
   state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
 }
 if (O === global) {
  if (simple)
   O[key] = value;
  else
   setGlobal(key, value);
  return;
 } else if (!unsafe) {
  delete O[key];
 } else if (!noTargetGet && O[key]) {
  simple = true;
 }
 if (simple)
  O[key] = value;
 else
  createNonEnumerableProperty(O, key, value);
})(Function.prototype, 'toString', function toString() {
 return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
module.exports = function (key, value) {
 try {
  createNonEnumerableProperty(global, key, value);
 } catch (error) {
  global[key] = value;
 }
 return value;
};

/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var store = __w_pdfjs_require__(31);
var functionToString = Function.toString;
if (typeof store.inspectSource != 'function') {
 store.inspectSource = function (it) {
  return functionToString.call(it);
 };
}
module.exports = store.inspectSource;

/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var setGlobal = __w_pdfjs_require__(29);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});
module.exports = store;

/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_WEAK_MAP = __w_pdfjs_require__(33);
var global = __w_pdfjs_require__(10);
var isObject = __w_pdfjs_require__(21);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var objectHas = __w_pdfjs_require__(22);
var shared = __w_pdfjs_require__(31);
var sharedKey = __w_pdfjs_require__(34);
var hiddenKeys = __w_pdfjs_require__(38);
var WeakMap = global.WeakMap;
var set, get, has;
var enforce = function (it) {
 return has(it) ? get(it) : set(it, {});
};
var getterFor = function (TYPE) {
 return function (it) {
  var state;
  if (!isObject(it) || (state = get(it)).type !== TYPE) {
   throw TypeError('Incompatible receiver, ' + TYPE + ' required');
  }
  return state;
 };
};
if (NATIVE_WEAK_MAP) {
 var store = shared.state || (shared.state = new WeakMap());
 var wmget = store.get;
 var wmhas = store.has;
 var wmset = store.set;
 set = function (it, metadata) {
  metadata.facade = it;
  wmset.call(store, it, metadata);
  return metadata;
 };
 get = function (it) {
  return wmget.call(store, it) || {};
 };
 has = function (it) {
  return wmhas.call(store, it);
 };
} else {
 var STATE = sharedKey('state');
 hiddenKeys[STATE] = true;
 set = function (it, metadata) {
  metadata.facade = it;
  createNonEnumerableProperty(it, STATE, metadata);
  return metadata;
 };
 get = function (it) {
  return objectHas(it, STATE) ? it[STATE] : {};
 };
 has = function (it) {
  return objectHas(it, STATE);
 };
}
module.exports = {
 set: set,
 get: get,
 has: has,
 enforce: enforce,
 getterFor: getterFor
};

/***/ }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var inspectSource = __w_pdfjs_require__(30);
var WeakMap = global.WeakMap;
module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var shared = __w_pdfjs_require__(35);
var uid = __w_pdfjs_require__(37);
var keys = shared('keys');
module.exports = function (key) {
 return keys[key] || (keys[key] = uid(key));
};

/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IS_PURE = __w_pdfjs_require__(36);
var store = __w_pdfjs_require__(31);
(module.exports = function (key, value) {
 return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
 version: '3.8.3',
 mode: IS_PURE ? 'pure' : 'global',
 copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});

/***/ }),
/* 36 */
/***/ ((module) => {

module.exports = false;

/***/ }),
/* 37 */
/***/ ((module) => {

var id = 0;
var postfix = Math.random();
module.exports = function (key) {
 return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

/***/ }),
/* 38 */
/***/ ((module) => {

module.exports = {};

/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var has = __w_pdfjs_require__(22);
var ownKeys = __w_pdfjs_require__(40);
var getOwnPropertyDescriptorModule = __w_pdfjs_require__(11);
var definePropertyModule = __w_pdfjs_require__(26);
module.exports = function (target, source) {
 var keys = ownKeys(source);
 var defineProperty = definePropertyModule.f;
 var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
 for (var i = 0; i < keys.length; i++) {
  var key = keys[i];
  if (!has(target, key))
   defineProperty(target, key, getOwnPropertyDescriptor(source, key));
 }
};

/***/ }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(41);
var getOwnPropertyNamesModule = __w_pdfjs_require__(43);
var getOwnPropertySymbolsModule = __w_pdfjs_require__(50);
var anObject = __w_pdfjs_require__(27);
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
 var keys = getOwnPropertyNamesModule.f(anObject(it));
 var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
 return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var path = __w_pdfjs_require__(42);
var global = __w_pdfjs_require__(10);
var aFunction = function (variable) {
 return typeof variable == 'function' ? variable : undefined;
};
module.exports = function (namespace, method) {
 return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

/***/ }),
/* 42 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
module.exports = global;

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var internalObjectKeys = __w_pdfjs_require__(44);
var enumBugKeys = __w_pdfjs_require__(49);
var hiddenKeys = enumBugKeys.concat('length', 'prototype');
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
 return internalObjectKeys(O, hiddenKeys);
};

/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var has = __w_pdfjs_require__(22);
var toIndexedObject = __w_pdfjs_require__(16);
var indexOf = __w_pdfjs_require__(45).indexOf;
var hiddenKeys = __w_pdfjs_require__(38);
module.exports = function (object, names) {
 var O = toIndexedObject(object);
 var i = 0;
 var result = [];
 var key;
 for (key in O)
  !has(hiddenKeys, key) && has(O, key) && result.push(key);
 while (names.length > i)
  if (has(O, key = names[i++])) {
   ~indexOf(result, key) || result.push(key);
  }
 return result;
};

/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toIndexedObject = __w_pdfjs_require__(16);
var toLength = __w_pdfjs_require__(46);
var toAbsoluteIndex = __w_pdfjs_require__(48);
var createMethod = function (IS_INCLUDES) {
 return function ($this, el, fromIndex) {
  var O = toIndexedObject($this);
  var length = toLength(O.length);
  var index = toAbsoluteIndex(fromIndex, length);
  var value;
  if (IS_INCLUDES && el != el)
   while (length > index) {
    value = O[index++];
    if (value != value)
     return true;
   }
  else
   for (; length > index; index++) {
    if ((IS_INCLUDES || index in O) && O[index] === el)
     return IS_INCLUDES || index || 0;
   }
  return !IS_INCLUDES && -1;
 };
};
module.exports = {
 includes: createMethod(true),
 indexOf: createMethod(false)
};

/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toInteger = __w_pdfjs_require__(47);
var min = Math.min;
module.exports = function (argument) {
 return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0;
};

/***/ }),
/* 47 */
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (argument) {
 return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toInteger = __w_pdfjs_require__(47);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
 var integer = toInteger(index);
 return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),
/* 49 */
/***/ ((module) => {

module.exports = [
 'constructor',
 'hasOwnProperty',
 'isPrototypeOf',
 'propertyIsEnumerable',
 'toLocaleString',
 'toString',
 'valueOf'
];

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports) => {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
var replacement = /#|\.prototype\./;
var isForced = function (feature, detection) {
 var value = data[normalize(feature)];
 return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function (string) {
 return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(53);
__w_pdfjs_require__(72);
var path = __w_pdfjs_require__(42);
module.exports = path.Object.fromEntries;

/***/ }),
/* 53 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var toIndexedObject = __w_pdfjs_require__(16);
var addToUnscopables = __w_pdfjs_require__(54);
var Iterators = __w_pdfjs_require__(62);
var InternalStateModule = __w_pdfjs_require__(32);
var defineIterator = __w_pdfjs_require__(63);
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
 setInternalState(this, {
  type: ARRAY_ITERATOR,
  target: toIndexedObject(iterated),
  index: 0,
  kind: kind
 });
}, function () {
 var state = getInternalState(this);
 var target = state.target;
 var kind = state.kind;
 var index = state.index++;
 if (!target || index >= target.length) {
  state.target = undefined;
  return {
   value: undefined,
   done: true
  };
 }
 if (kind == 'keys')
  return {
   value: index,
   done: false
  };
 if (kind == 'values')
  return {
   value: target[index],
   done: false
  };
 return {
  value: [
   index,
   target[index]
  ],
  done: false
 };
}, 'values');
Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(55);
var create = __w_pdfjs_require__(58);
var definePropertyModule = __w_pdfjs_require__(26);
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == undefined) {
 definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
  configurable: true,
  value: create(null)
 });
}
module.exports = function (key) {
 ArrayPrototype[UNSCOPABLES][key] = true;
};

/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var shared = __w_pdfjs_require__(35);
var has = __w_pdfjs_require__(22);
var uid = __w_pdfjs_require__(37);
var NATIVE_SYMBOL = __w_pdfjs_require__(56);
var USE_SYMBOL_AS_UID = __w_pdfjs_require__(57);
var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function (name) {
 if (!has(WellKnownSymbolsStore, name)) {
  if (NATIVE_SYMBOL && has(Symbol, name))
   WellKnownSymbolsStore[name] = Symbol[name];
  else
   WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
 }
 return WellKnownSymbolsStore[name];
};

/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
 return !String(Symbol());
});

/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_SYMBOL = __w_pdfjs_require__(56);
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

/***/ }),
/* 58 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var defineProperties = __w_pdfjs_require__(59);
var enumBugKeys = __w_pdfjs_require__(49);
var hiddenKeys = __w_pdfjs_require__(38);
var html = __w_pdfjs_require__(61);
var documentCreateElement = __w_pdfjs_require__(24);
var sharedKey = __w_pdfjs_require__(34);
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function () {
};
var scriptTag = function (content) {
 return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function (activeXDocument) {
 activeXDocument.write(scriptTag(''));
 activeXDocument.close();
 var temp = activeXDocument.parentWindow.Object;
 activeXDocument = null;
 return temp;
};
var NullProtoObjectViaIFrame = function () {
 var iframe = documentCreateElement('iframe');
 var JS = 'java' + SCRIPT + ':';
 var iframeDocument;
 iframe.style.display = 'none';
 html.appendChild(iframe);
 iframe.src = String(JS);
 iframeDocument = iframe.contentWindow.document;
 iframeDocument.open();
 iframeDocument.write(scriptTag('document.F=Object'));
 iframeDocument.close();
 return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function () {
 try {
  activeXDocument = document.domain && new ActiveXObject('htmlfile');
 } catch (error) {
 }
 NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
 var length = enumBugKeys.length;
 while (length--)
  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
 return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
module.exports = Object.create || function create(O, Properties) {
 var result;
 if (O !== null) {
  EmptyConstructor[PROTOTYPE] = anObject(O);
  result = new EmptyConstructor();
  EmptyConstructor[PROTOTYPE] = null;
  result[IE_PROTO] = O;
 } else
  result = NullProtoObject();
 return Properties === undefined ? result : defineProperties(result, Properties);
};

/***/ }),
/* 59 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var definePropertyModule = __w_pdfjs_require__(26);
var anObject = __w_pdfjs_require__(27);
var objectKeys = __w_pdfjs_require__(60);
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
 anObject(O);
 var keys = objectKeys(Properties);
 var length = keys.length;
 var index = 0;
 var key;
 while (length > index)
  definePropertyModule.f(O, key = keys[index++], Properties[key]);
 return O;
};

/***/ }),
/* 60 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var internalObjectKeys = __w_pdfjs_require__(44);
var enumBugKeys = __w_pdfjs_require__(49);
module.exports = Object.keys || function keys(O) {
 return internalObjectKeys(O, enumBugKeys);
};

/***/ }),
/* 61 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(41);
module.exports = getBuiltIn('document', 'documentElement');

/***/ }),
/* 62 */
/***/ ((module) => {

module.exports = {};

/***/ }),
/* 63 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var createIteratorConstructor = __w_pdfjs_require__(64);
var getPrototypeOf = __w_pdfjs_require__(66);
var setPrototypeOf = __w_pdfjs_require__(70);
var setToStringTag = __w_pdfjs_require__(69);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var redefine = __w_pdfjs_require__(28);
var wellKnownSymbol = __w_pdfjs_require__(55);
var IS_PURE = __w_pdfjs_require__(36);
var Iterators = __w_pdfjs_require__(62);
var IteratorsCore = __w_pdfjs_require__(65);
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function () {
 return this;
};
module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
 createIteratorConstructor(IteratorConstructor, NAME, next);
 var getIterationMethod = function (KIND) {
  if (KIND === DEFAULT && defaultIterator)
   return defaultIterator;
  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
   return IterablePrototype[KIND];
  switch (KIND) {
  case KEYS:
   return function keys() {
    return new IteratorConstructor(this, KIND);
   };
  case VALUES:
   return function values() {
    return new IteratorConstructor(this, KIND);
   };
  case ENTRIES:
   return function entries() {
    return new IteratorConstructor(this, KIND);
   };
  }
  return function () {
   return new IteratorConstructor(this);
  };
 };
 var TO_STRING_TAG = NAME + ' Iterator';
 var INCORRECT_VALUES_NAME = false;
 var IterablePrototype = Iterable.prototype;
 var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
 var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
 var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
 var CurrentIteratorPrototype, methods, KEY;
 if (anyNativeIterator) {
  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
  if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
   if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
    if (setPrototypeOf) {
     setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
    } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
     createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
    }
   }
   setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
   if (IS_PURE)
    Iterators[TO_STRING_TAG] = returnThis;
  }
 }
 if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
  INCORRECT_VALUES_NAME = true;
  defaultIterator = function values() {
   return nativeIterator.call(this);
  };
 }
 if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
  createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
 }
 Iterators[NAME] = defaultIterator;
 if (DEFAULT) {
  methods = {
   values: getIterationMethod(VALUES),
   keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
   entries: getIterationMethod(ENTRIES)
  };
  if (FORCED)
   for (KEY in methods) {
    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
     redefine(IterablePrototype, KEY, methods[KEY]);
    }
   }
  else
   $({
    target: NAME,
    proto: true,
    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
   }, methods);
 }
 return methods;
};

/***/ }),
/* 64 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var IteratorPrototype = __w_pdfjs_require__(65).IteratorPrototype;
var create = __w_pdfjs_require__(58);
var createPropertyDescriptor = __w_pdfjs_require__(15);
var setToStringTag = __w_pdfjs_require__(69);
var Iterators = __w_pdfjs_require__(62);
var returnThis = function () {
 return this;
};
module.exports = function (IteratorConstructor, NAME, next) {
 var TO_STRING_TAG = NAME + ' Iterator';
 IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
 setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
 Iterators[TO_STRING_TAG] = returnThis;
 return IteratorConstructor;
};

/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var fails = __w_pdfjs_require__(13);
var getPrototypeOf = __w_pdfjs_require__(66);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var has = __w_pdfjs_require__(22);
var wellKnownSymbol = __w_pdfjs_require__(55);
var IS_PURE = __w_pdfjs_require__(36);
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
var returnThis = function () {
 return this;
};
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
 arrayIterator = [].keys();
 if (!('next' in arrayIterator))
  BUGGY_SAFARI_ITERATORS = true;
 else {
  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
   IteratorPrototype = PrototypeOfArrayIteratorPrototype;
 }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
 var test = {};
 return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE)
 IteratorPrototype = {};
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
 createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}
module.exports = {
 IteratorPrototype: IteratorPrototype,
 BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

/***/ }),
/* 66 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var has = __w_pdfjs_require__(22);
var toObject = __w_pdfjs_require__(67);
var sharedKey = __w_pdfjs_require__(34);
var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(68);
var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
 O = toObject(O);
 if (has(O, IE_PROTO))
  return O[IE_PROTO];
 if (typeof O.constructor == 'function' && O instanceof O.constructor) {
  return O.constructor.prototype;
 }
 return O instanceof Object ? ObjectPrototype : null;
};

/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var requireObjectCoercible = __w_pdfjs_require__(19);
module.exports = function (argument) {
 return Object(requireObjectCoercible(argument));
};

/***/ }),
/* 68 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
module.exports = !fails(function () {
 function F() {
 }
 F.prototype.constructor = null;
 return Object.getPrototypeOf(new F()) !== F.prototype;
});

/***/ }),
/* 69 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var defineProperty = __w_pdfjs_require__(26).f;
var has = __w_pdfjs_require__(22);
var wellKnownSymbol = __w_pdfjs_require__(55);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function (it, TAG, STATIC) {
 if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
  defineProperty(it, TO_STRING_TAG, {
   configurable: true,
   value: TAG
  });
 }
};

/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var aPossiblePrototype = __w_pdfjs_require__(71);
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
 var CORRECT_SETTER = false;
 var test = {};
 var setter;
 try {
  setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
  setter.call(test, []);
  CORRECT_SETTER = test instanceof Array;
 } catch (error) {
 }
 return function setPrototypeOf(O, proto) {
  anObject(O);
  aPossiblePrototype(proto);
  if (CORRECT_SETTER)
   setter.call(O, proto);
  else
   O.__proto__ = proto;
  return O;
 };
}() : undefined);

/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isObject = __w_pdfjs_require__(21);
module.exports = function (it) {
 if (!isObject(it) && it !== null) {
  throw TypeError("Can't set " + String(it) + ' as a prototype');
 }
 return it;
};

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(9);
var iterate = __w_pdfjs_require__(73);
var createProperty = __w_pdfjs_require__(81);
$({
 target: 'Object',
 stat: true
}, {
 fromEntries: function fromEntries(iterable) {
  var obj = {};
  iterate(iterable, function (k, v) {
   createProperty(obj, k, v);
  }, { AS_ENTRIES: true });
  return obj;
 }
});

/***/ }),
/* 73 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var isArrayIteratorMethod = __w_pdfjs_require__(74);
var toLength = __w_pdfjs_require__(46);
var bind = __w_pdfjs_require__(75);
var getIteratorMethod = __w_pdfjs_require__(77);
var iteratorClose = __w_pdfjs_require__(80);
var Result = function (stopped, result) {
 this.stopped = stopped;
 this.result = result;
};
module.exports = function (iterable, unboundFunction, options) {
 var that = options && options.that;
 var AS_ENTRIES = !!(options && options.AS_ENTRIES);
 var IS_ITERATOR = !!(options && options.IS_ITERATOR);
 var INTERRUPTED = !!(options && options.INTERRUPTED);
 var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
 var iterator, iterFn, index, length, result, next, step;
 var stop = function (condition) {
  if (iterator)
   iteratorClose(iterator);
  return new Result(true, condition);
 };
 var callFn = function (value) {
  if (AS_ENTRIES) {
   anObject(value);
   return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
  }
  return INTERRUPTED ? fn(value, stop) : fn(value);
 };
 if (IS_ITERATOR) {
  iterator = iterable;
 } else {
  iterFn = getIteratorMethod(iterable);
  if (typeof iterFn != 'function')
   throw TypeError('Target is not iterable');
  if (isArrayIteratorMethod(iterFn)) {
   for (index = 0, length = toLength(iterable.length); length > index; index++) {
    result = callFn(iterable[index]);
    if (result && result instanceof Result)
     return result;
   }
   return new Result(false);
  }
  iterator = iterFn.call(iterable);
 }
 next = iterator.next;
 while (!(step = next.call(iterator)).done) {
  try {
   result = callFn(step.value);
  } catch (error) {
   iteratorClose(iterator);
   throw error;
  }
  if (typeof result == 'object' && result && result instanceof Result)
   return result;
 }
 return new Result(false);
};

/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(55);
var Iterators = __w_pdfjs_require__(62);
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;
module.exports = function (it) {
 return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var aFunction = __w_pdfjs_require__(76);
module.exports = function (fn, that, length) {
 aFunction(fn);
 if (that === undefined)
  return fn;
 switch (length) {
 case 0:
  return function () {
   return fn.call(that);
  };
 case 1:
  return function (a) {
   return fn.call(that, a);
  };
 case 2:
  return function (a, b) {
   return fn.call(that, a, b);
  };
 case 3:
  return function (a, b, c) {
   return fn.call(that, a, b, c);
  };
 }
 return function () {
  return fn.apply(that, arguments);
 };
};

/***/ }),
/* 76 */
/***/ ((module) => {

module.exports = function (it) {
 if (typeof it != 'function') {
  throw TypeError(String(it) + ' is not a function');
 }
 return it;
};

/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var classof = __w_pdfjs_require__(78);
var Iterators = __w_pdfjs_require__(62);
var wellKnownSymbol = __w_pdfjs_require__(55);
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function (it) {
 if (it != undefined)
  return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);
var classofRaw = __w_pdfjs_require__(18);
var wellKnownSymbol = __w_pdfjs_require__(55);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var CORRECT_ARGUMENTS = classofRaw(function () {
 return arguments;
}()) == 'Arguments';
var tryGet = function (it, key) {
 try {
  return it[key];
 } catch (error) {
 }
};
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
 var O, tag, result;
 return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

/***/ }),
/* 79 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(55);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
module.exports = function (iterator) {
 var returnMethod = iterator['return'];
 if (returnMethod !== undefined) {
  return anObject(returnMethod.call(iterator)).value;
 }
};

/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var toPrimitive = __w_pdfjs_require__(20);
var definePropertyModule = __w_pdfjs_require__(26);
var createPropertyDescriptor = __w_pdfjs_require__(15);
module.exports = function (object, key, value) {
 var propertyKey = toPrimitive(key);
 if (propertyKey in object)
  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
 else
  object[propertyKey] = value;
};

/***/ }),
/* 82 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(83);
__w_pdfjs_require__(84);
__w_pdfjs_require__(86);
__w_pdfjs_require__(104);
__w_pdfjs_require__(105);
__w_pdfjs_require__(106);
__w_pdfjs_require__(107);
__w_pdfjs_require__(109);
var path = __w_pdfjs_require__(42);
module.exports = path.Promise;

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var getPrototypeOf = __w_pdfjs_require__(66);
var setPrototypeOf = __w_pdfjs_require__(70);
var create = __w_pdfjs_require__(58);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var createPropertyDescriptor = __w_pdfjs_require__(15);
var iterate = __w_pdfjs_require__(73);
var $AggregateError = function AggregateError(errors, message) {
 var that = this;
 if (!(that instanceof $AggregateError))
  return new $AggregateError(errors, message);
 if (setPrototypeOf) {
  that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
 }
 if (message !== undefined)
  createNonEnumerableProperty(that, 'message', String(message));
 var errorsArray = [];
 iterate(errors, errorsArray.push, { that: errorsArray });
 createNonEnumerableProperty(that, 'errors', errorsArray);
 return that;
};
$AggregateError.prototype = create(Error.prototype, {
 constructor: createPropertyDescriptor(5, $AggregateError),
 message: createPropertyDescriptor(5, ''),
 name: createPropertyDescriptor(5, 'AggregateError')
});
$({ global: true }, { AggregateError: $AggregateError });

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);
var redefine = __w_pdfjs_require__(28);
var toString = __w_pdfjs_require__(85);
if (!TO_STRING_TAG_SUPPORT) {
 redefine(Object.prototype, 'toString', toString, { unsafe: true });
}

/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);
var classof = __w_pdfjs_require__(78);
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
 return '[object ' + classof(this) + ']';
};

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var IS_PURE = __w_pdfjs_require__(36);
var global = __w_pdfjs_require__(10);
var getBuiltIn = __w_pdfjs_require__(41);
var NativePromise = __w_pdfjs_require__(87);
var redefine = __w_pdfjs_require__(28);
var redefineAll = __w_pdfjs_require__(88);
var setToStringTag = __w_pdfjs_require__(69);
var setSpecies = __w_pdfjs_require__(89);
var isObject = __w_pdfjs_require__(21);
var aFunction = __w_pdfjs_require__(76);
var anInstance = __w_pdfjs_require__(90);
var inspectSource = __w_pdfjs_require__(30);
var iterate = __w_pdfjs_require__(73);
var checkCorrectnessOfIteration = __w_pdfjs_require__(91);
var speciesConstructor = __w_pdfjs_require__(92);
var task = __w_pdfjs_require__(93).set;
var microtask = __w_pdfjs_require__(97);
var promiseResolve = __w_pdfjs_require__(99);
var hostReportErrors = __w_pdfjs_require__(101);
var newPromiseCapabilityModule = __w_pdfjs_require__(100);
var perform = __w_pdfjs_require__(102);
var InternalStateModule = __w_pdfjs_require__(32);
var isForced = __w_pdfjs_require__(51);
var wellKnownSymbol = __w_pdfjs_require__(55);
var IS_NODE = __w_pdfjs_require__(96);
var V8_VERSION = __w_pdfjs_require__(103);
var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function () {
 var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
 if (!GLOBAL_CORE_JS_PROMISE) {
  if (V8_VERSION === 66)
   return true;
  if (!IS_NODE && !NATIVE_REJECTION_EVENT)
   return true;
 }
 if (IS_PURE && !PromiseConstructor.prototype['finally'])
  return true;
 if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))
  return false;
 var promise = PromiseConstructor.resolve(1);
 var FakePromise = function (exec) {
  exec(function () {
  }, function () {
  });
 };
 var constructor = promise.constructor = {};
 constructor[SPECIES] = FakePromise;
 return !(promise.then(function () {
 }) instanceof FakePromise);
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
 PromiseConstructor.all(iterable)['catch'](function () {
 });
});
var isThenable = function (it) {
 var then;
 return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (state, isReject) {
 if (state.notified)
  return;
 state.notified = true;
 var chain = state.reactions;
 microtask(function () {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var index = 0;
  while (chain.length > index) {
   var reaction = chain[index++];
   var handler = ok ? reaction.ok : reaction.fail;
   var resolve = reaction.resolve;
   var reject = reaction.reject;
   var domain = reaction.domain;
   var result, then, exited;
   try {
    if (handler) {
     if (!ok) {
      if (state.rejection === UNHANDLED)
       onHandleUnhandled(state);
      state.rejection = HANDLED;
     }
     if (handler === true)
      result = value;
     else {
      if (domain)
       domain.enter();
      result = handler(value);
      if (domain) {
       domain.exit();
       exited = true;
      }
     }
     if (result === reaction.promise) {
      reject(TypeError('Promise-chain cycle'));
     } else if (then = isThenable(result)) {
      then.call(result, resolve, reject);
     } else
      resolve(result);
    } else
     reject(value);
   } catch (error) {
    if (domain && !exited)
     domain.exit();
    reject(error);
   }
  }
  state.reactions = [];
  state.notified = false;
  if (isReject && !state.rejection)
   onUnhandled(state);
 });
};
var dispatchEvent = function (name, promise, reason) {
 var event, handler;
 if (DISPATCH_EVENT) {
  event = document.createEvent('Event');
  event.promise = promise;
  event.reason = reason;
  event.initEvent(name, false, true);
  global.dispatchEvent(event);
 } else
  event = {
   promise: promise,
   reason: reason
  };
 if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name]))
  handler(event);
 else if (name === UNHANDLED_REJECTION)
  hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function (state) {
 task.call(global, function () {
  var promise = state.facade;
  var value = state.value;
  var IS_UNHANDLED = isUnhandled(state);
  var result;
  if (IS_UNHANDLED) {
   result = perform(function () {
    if (IS_NODE) {
     process.emit('unhandledRejection', value, promise);
    } else
     dispatchEvent(UNHANDLED_REJECTION, promise, value);
   });
   state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
   if (result.error)
    throw result.value;
  }
 });
};
var isUnhandled = function (state) {
 return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function (state) {
 task.call(global, function () {
  var promise = state.facade;
  if (IS_NODE) {
   process.emit('rejectionHandled', promise);
  } else
   dispatchEvent(REJECTION_HANDLED, promise, state.value);
 });
};
var bind = function (fn, state, unwrap) {
 return function (value) {
  fn(state, value, unwrap);
 };
};
var internalReject = function (state, value, unwrap) {
 if (state.done)
  return;
 state.done = true;
 if (unwrap)
  state = unwrap;
 state.value = value;
 state.state = REJECTED;
 notify(state, true);
};
var internalResolve = function (state, value, unwrap) {
 if (state.done)
  return;
 state.done = true;
 if (unwrap)
  state = unwrap;
 try {
  if (state.facade === value)
   throw TypeError("Promise can't be resolved itself");
  var then = isThenable(value);
  if (then) {
   microtask(function () {
    var wrapper = { done: false };
    try {
     then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
    } catch (error) {
     internalReject(wrapper, error, state);
    }
   });
  } else {
   state.value = value;
   state.state = FULFILLED;
   notify(state, false);
  }
 } catch (error) {
  internalReject({ done: false }, error, state);
 }
};
if (FORCED) {
 PromiseConstructor = function Promise(executor) {
  anInstance(this, PromiseConstructor, PROMISE);
  aFunction(executor);
  Internal.call(this);
  var state = getInternalState(this);
  try {
   executor(bind(internalResolve, state), bind(internalReject, state));
  } catch (error) {
   internalReject(state, error);
  }
 };
 Internal = function Promise(executor) {
  setInternalState(this, {
   type: PROMISE,
   done: false,
   notified: false,
   parent: false,
   reactions: [],
   rejection: false,
   state: PENDING,
   value: undefined
  });
 };
 Internal.prototype = redefineAll(PromiseConstructor.prototype, {
  then: function then(onFulfilled, onRejected) {
   var state = getInternalPromiseState(this);
   var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
   reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
   reaction.fail = typeof onRejected == 'function' && onRejected;
   reaction.domain = IS_NODE ? process.domain : undefined;
   state.parent = true;
   state.reactions.push(reaction);
   if (state.state != PENDING)
    notify(state, false);
   return reaction.promise;
  },
  'catch': function (onRejected) {
   return this.then(undefined, onRejected);
  }
 });
 OwnPromiseCapability = function () {
  var promise = new Internal();
  var state = getInternalState(promise);
  this.promise = promise;
  this.resolve = bind(internalResolve, state);
  this.reject = bind(internalReject, state);
 };
 newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
  return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
 };
 if (!IS_PURE && typeof NativePromise == 'function') {
  nativeThen = NativePromise.prototype.then;
  redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
   var that = this;
   return new PromiseConstructor(function (resolve, reject) {
    nativeThen.call(that, resolve, reject);
   }).then(onFulfilled, onRejected);
  }, { unsafe: true });
  if (typeof $fetch == 'function')
   $({
    global: true,
    enumerable: true,
    forced: true
   }, {
    fetch: function fetch(input) {
     return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
    }
   });
 }
}
$({
 global: true,
 wrap: true,
 forced: FORCED
}, { Promise: PromiseConstructor });
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);
$({
 target: PROMISE,
 stat: true,
 forced: FORCED
}, {
 reject: function reject(r) {
  var capability = newPromiseCapability(this);
  capability.reject.call(undefined, r);
  return capability.promise;
 }
});
$({
 target: PROMISE,
 stat: true,
 forced: IS_PURE || FORCED
}, {
 resolve: function resolve(x) {
  return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
 }
});
$({
 target: PROMISE,
 stat: true,
 forced: INCORRECT_ITERATION
}, {
 all: function all(iterable) {
  var C = this;
  var capability = newPromiseCapability(C);
  var resolve = capability.resolve;
  var reject = capability.reject;
  var result = perform(function () {
   var $promiseResolve = aFunction(C.resolve);
   var values = [];
   var counter = 0;
   var remaining = 1;
   iterate(iterable, function (promise) {
    var index = counter++;
    var alreadyCalled = false;
    values.push(undefined);
    remaining++;
    $promiseResolve.call(C, promise).then(function (value) {
     if (alreadyCalled)
      return;
     alreadyCalled = true;
     values[index] = value;
     --remaining || resolve(values);
    }, reject);
   });
   --remaining || resolve(values);
  });
  if (result.error)
   reject(result.value);
  return capability.promise;
 },
 race: function race(iterable) {
  var C = this;
  var capability = newPromiseCapability(C);
  var reject = capability.reject;
  var result = perform(function () {
   var $promiseResolve = aFunction(C.resolve);
   iterate(iterable, function (promise) {
    $promiseResolve.call(C, promise).then(capability.resolve, reject);
   });
  });
  if (result.error)
   reject(result.value);
  return capability.promise;
 }
});

/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
module.exports = global.Promise;

/***/ }),
/* 88 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var redefine = __w_pdfjs_require__(28);
module.exports = function (target, src, options) {
 for (var key in src)
  redefine(target, key, src[key], options);
 return target;
};

/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var getBuiltIn = __w_pdfjs_require__(41);
var definePropertyModule = __w_pdfjs_require__(26);
var wellKnownSymbol = __w_pdfjs_require__(55);
var DESCRIPTORS = __w_pdfjs_require__(12);
var SPECIES = wellKnownSymbol('species');
module.exports = function (CONSTRUCTOR_NAME) {
 var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
 var defineProperty = definePropertyModule.f;
 if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
  defineProperty(Constructor, SPECIES, {
   configurable: true,
   get: function () {
    return this;
   }
  });
 }
};

/***/ }),
/* 90 */
/***/ ((module) => {

module.exports = function (it, Constructor, name) {
 if (!(it instanceof Constructor)) {
  throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
 }
 return it;
};

/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(55);
var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;
try {
 var called = 0;
 var iteratorWithReturn = {
  next: function () {
   return { done: !!called++ };
  },
  'return': function () {
   SAFE_CLOSING = true;
  }
 };
 iteratorWithReturn[ITERATOR] = function () {
  return this;
 };
 Array.from(iteratorWithReturn, function () {
  throw 2;
 });
} catch (error) {
}
module.exports = function (exec, SKIP_CLOSING) {
 if (!SKIP_CLOSING && !SAFE_CLOSING)
  return false;
 var ITERATION_SUPPORT = false;
 try {
  var object = {};
  object[ITERATOR] = function () {
   return {
    next: function () {
     return { done: ITERATION_SUPPORT = true };
    }
   };
  };
  exec(object);
 } catch (error) {
 }
 return ITERATION_SUPPORT;
};

/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var aFunction = __w_pdfjs_require__(76);
var wellKnownSymbol = __w_pdfjs_require__(55);
var SPECIES = wellKnownSymbol('species');
module.exports = function (O, defaultConstructor) {
 var C = anObject(O).constructor;
 var S;
 return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var fails = __w_pdfjs_require__(13);
var bind = __w_pdfjs_require__(75);
var html = __w_pdfjs_require__(61);
var createElement = __w_pdfjs_require__(24);
var IS_IOS = __w_pdfjs_require__(94);
var IS_NODE = __w_pdfjs_require__(96);
var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function (id) {
 if (queue.hasOwnProperty(id)) {
  var fn = queue[id];
  delete queue[id];
  fn();
 }
};
var runner = function (id) {
 return function () {
  run(id);
 };
};
var listener = function (event) {
 run(event.data);
};
var post = function (id) {
 global.postMessage(id + '', location.protocol + '//' + location.host);
};
if (!set || !clear) {
 set = function setImmediate(fn) {
  var args = [];
  var i = 1;
  while (arguments.length > i)
   args.push(arguments[i++]);
  queue[++counter] = function () {
   (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
  };
  defer(counter);
  return counter;
 };
 clear = function clearImmediate(id) {
  delete queue[id];
 };
 if (IS_NODE) {
  defer = function (id) {
   process.nextTick(runner(id));
  };
 } else if (Dispatch && Dispatch.now) {
  defer = function (id) {
   Dispatch.now(runner(id));
  };
 } else if (MessageChannel && !IS_IOS) {
  channel = new MessageChannel();
  port = channel.port2;
  channel.port1.onmessage = listener;
  defer = bind(port.postMessage, port, 1);
 } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
  defer = post;
  global.addEventListener('message', listener, false);
 } else if (ONREADYSTATECHANGE in createElement('script')) {
  defer = function (id) {
   html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
    html.removeChild(this);
    run(id);
   };
  };
 } else {
  defer = function (id) {
   setTimeout(runner(id), 0);
  };
 }
}
module.exports = {
 set: set,
 clear: clear
};

/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var userAgent = __w_pdfjs_require__(95);
module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

/***/ }),
/* 95 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(41);
module.exports = getBuiltIn('navigator', 'userAgent') || '';

/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var classof = __w_pdfjs_require__(18);
var global = __w_pdfjs_require__(10);
module.exports = classof(global.process) == 'process';

/***/ }),
/* 97 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var getOwnPropertyDescriptor = __w_pdfjs_require__(11).f;
var macrotask = __w_pdfjs_require__(93).set;
var IS_IOS = __w_pdfjs_require__(94);
var IS_WEBOS_WEBKIT = __w_pdfjs_require__(98);
var IS_NODE = __w_pdfjs_require__(96);
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then;
if (!queueMicrotask) {
 flush = function () {
  var parent, fn;
  if (IS_NODE && (parent = process.domain))
   parent.exit();
  while (head) {
   fn = head.fn;
   head = head.next;
   try {
    fn();
   } catch (error) {
    if (head)
     notify();
    else
     last = undefined;
    throw error;
   }
  }
  last = undefined;
  if (parent)
   parent.enter();
 };
 if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
  toggle = true;
  node = document.createTextNode('');
  new MutationObserver(flush).observe(node, { characterData: true });
  notify = function () {
   node.data = toggle = !toggle;
  };
 } else if (Promise && Promise.resolve) {
  promise = Promise.resolve(undefined);
  then = promise.then;
  notify = function () {
   then.call(promise, flush);
  };
 } else if (IS_NODE) {
  notify = function () {
   process.nextTick(flush);
  };
 } else {
  notify = function () {
   macrotask.call(global, flush);
  };
 }
}
module.exports = queueMicrotask || function (fn) {
 var task = {
  fn: fn,
  next: undefined
 };
 if (last)
  last.next = task;
 if (!head) {
  head = task;
  notify();
 }
 last = task;
};

/***/ }),
/* 98 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var userAgent = __w_pdfjs_require__(95);
module.exports = /web0s(?!.*chrome)/i.test(userAgent);

/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var isObject = __w_pdfjs_require__(21);
var newPromiseCapability = __w_pdfjs_require__(100);
module.exports = function (C, x) {
 anObject(C);
 if (isObject(x) && x.constructor === C)
  return x;
 var promiseCapability = newPromiseCapability.f(C);
 var resolve = promiseCapability.resolve;
 resolve(x);
 return promiseCapability.promise;
};

/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var aFunction = __w_pdfjs_require__(76);
var PromiseCapability = function (C) {
 var resolve, reject;
 this.promise = new C(function ($$resolve, $$reject) {
  if (resolve !== undefined || reject !== undefined)
   throw TypeError('Bad Promise constructor');
  resolve = $$resolve;
  reject = $$reject;
 });
 this.resolve = aFunction(resolve);
 this.reject = aFunction(reject);
};
module.exports.f = function (C) {
 return new PromiseCapability(C);
};

/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
module.exports = function (a, b) {
 var console = global.console;
 if (console && console.error) {
  arguments.length === 1 ? console.error(a) : console.error(a, b);
 }
};

/***/ }),
/* 102 */
/***/ ((module) => {

module.exports = function (exec) {
 try {
  return {
   error: false,
   value: exec()
  };
 } catch (error) {
  return {
   error: true,
   value: error
  };
 }
};

/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var userAgent = __w_pdfjs_require__(95);
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
 match = v8.split('.');
 version = match[0] + match[1];
} else if (userAgent) {
 match = userAgent.match(/Edge\/(\d+)/);
 if (!match || match[1] >= 74) {
  match = userAgent.match(/Chrome\/(\d+)/);
  if (match)
   version = match[1];
 }
}
module.exports = version && +version;

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var aFunction = __w_pdfjs_require__(76);
var newPromiseCapabilityModule = __w_pdfjs_require__(100);
var perform = __w_pdfjs_require__(102);
var iterate = __w_pdfjs_require__(73);
$({
 target: 'Promise',
 stat: true
}, {
 allSettled: function allSettled(iterable) {
  var C = this;
  var capability = newPromiseCapabilityModule.f(C);
  var resolve = capability.resolve;
  var reject = capability.reject;
  var result = perform(function () {
   var promiseResolve = aFunction(C.resolve);
   var values = [];
   var counter = 0;
   var remaining = 1;
   iterate(iterable, function (promise) {
    var index = counter++;
    var alreadyCalled = false;
    values.push(undefined);
    remaining++;
    promiseResolve.call(C, promise).then(function (value) {
     if (alreadyCalled)
      return;
     alreadyCalled = true;
     values[index] = {
      status: 'fulfilled',
      value: value
     };
     --remaining || resolve(values);
    }, function (error) {
     if (alreadyCalled)
      return;
     alreadyCalled = true;
     values[index] = {
      status: 'rejected',
      reason: error
     };
     --remaining || resolve(values);
    });
   });
   --remaining || resolve(values);
  });
  if (result.error)
   reject(result.value);
  return capability.promise;
 }
});

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var aFunction = __w_pdfjs_require__(76);
var getBuiltIn = __w_pdfjs_require__(41);
var newPromiseCapabilityModule = __w_pdfjs_require__(100);
var perform = __w_pdfjs_require__(102);
var iterate = __w_pdfjs_require__(73);
var PROMISE_ANY_ERROR = 'No one promise resolved';
$({
 target: 'Promise',
 stat: true
}, {
 any: function any(iterable) {
  var C = this;
  var capability = newPromiseCapabilityModule.f(C);
  var resolve = capability.resolve;
  var reject = capability.reject;
  var result = perform(function () {
   var promiseResolve = aFunction(C.resolve);
   var errors = [];
   var counter = 0;
   var remaining = 1;
   var alreadyResolved = false;
   iterate(iterable, function (promise) {
    var index = counter++;
    var alreadyRejected = false;
    errors.push(undefined);
    remaining++;
    promiseResolve.call(C, promise).then(function (value) {
     if (alreadyRejected || alreadyResolved)
      return;
     alreadyResolved = true;
     resolve(value);
    }, function (error) {
     if (alreadyRejected || alreadyResolved)
      return;
     alreadyRejected = true;
     errors[index] = error;
     --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
   });
   --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
  });
  if (result.error)
   reject(result.value);
  return capability.promise;
 }
});

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var IS_PURE = __w_pdfjs_require__(36);
var NativePromise = __w_pdfjs_require__(87);
var fails = __w_pdfjs_require__(13);
var getBuiltIn = __w_pdfjs_require__(41);
var speciesConstructor = __w_pdfjs_require__(92);
var promiseResolve = __w_pdfjs_require__(99);
var redefine = __w_pdfjs_require__(28);
var NON_GENERIC = !!NativePromise && fails(function () {
 NativePromise.prototype['finally'].call({
  then: function () {
  }
 }, function () {
 });
});
$({
 target: 'Promise',
 proto: true,
 real: true,
 forced: NON_GENERIC
}, {
 'finally': function (onFinally) {
  var C = speciesConstructor(this, getBuiltIn('Promise'));
  var isFunction = typeof onFinally == 'function';
  return this.then(isFunction ? function (x) {
   return promiseResolve(C, onFinally()).then(function () {
    return x;
   });
  } : onFinally, isFunction ? function (e) {
   return promiseResolve(C, onFinally()).then(function () {
    throw e;
   });
  } : onFinally);
 }
});
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
 redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var charAt = __w_pdfjs_require__(108).charAt;
var InternalStateModule = __w_pdfjs_require__(32);
var defineIterator = __w_pdfjs_require__(63);
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
defineIterator(String, 'String', function (iterated) {
 setInternalState(this, {
  type: STRING_ITERATOR,
  string: String(iterated),
  index: 0
 });
}, function next() {
 var state = getInternalState(this);
 var string = state.string;
 var index = state.index;
 var point;
 if (index >= string.length)
  return {
   value: undefined,
   done: true
  };
 point = charAt(string, index);
 state.index += point.length;
 return {
  value: point,
  done: false
 };
});

/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toInteger = __w_pdfjs_require__(47);
var requireObjectCoercible = __w_pdfjs_require__(19);
var createMethod = function (CONVERT_TO_STRING) {
 return function ($this, pos) {
  var S = String(requireObjectCoercible($this));
  var position = toInteger(pos);
  var size = S.length;
  var first, second;
  if (position < 0 || position >= size)
   return CONVERT_TO_STRING ? '' : undefined;
  first = S.charCodeAt(position);
  return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
 };
};
module.exports = {
 codeAt: createMethod(false),
 charAt: createMethod(true)
};

/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var DOMIterables = __w_pdfjs_require__(110);
var ArrayIteratorMethods = __w_pdfjs_require__(53);
var createNonEnumerableProperty = __w_pdfjs_require__(25);
var wellKnownSymbol = __w_pdfjs_require__(55);
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;
for (var COLLECTION_NAME in DOMIterables) {
 var Collection = global[COLLECTION_NAME];
 var CollectionPrototype = Collection && Collection.prototype;
 if (CollectionPrototype) {
  if (CollectionPrototype[ITERATOR] !== ArrayValues)
   try {
    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
   } catch (error) {
    CollectionPrototype[ITERATOR] = ArrayValues;
   }
  if (!CollectionPrototype[TO_STRING_TAG]) {
   createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }
  if (DOMIterables[COLLECTION_NAME])
   for (var METHOD_NAME in ArrayIteratorMethods) {
    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
     try {
      createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
     } catch (error) {
      CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
     }
   }
 }
}

/***/ }),
/* 110 */
/***/ ((module) => {

module.exports = {
 CSSRuleList: 0,
 CSSStyleDeclaration: 0,
 CSSValueList: 0,
 ClientRectList: 0,
 DOMRectList: 0,
 DOMStringList: 0,
 DOMTokenList: 1,
 DataTransferItemList: 0,
 FileList: 0,
 HTMLAllCollection: 0,
 HTMLCollection: 0,
 HTMLFormElement: 0,
 HTMLSelectElement: 0,
 MediaList: 0,
 MimeTypeArray: 0,
 NamedNodeMap: 0,
 NodeList: 1,
 PaintRequestList: 0,
 Plugin: 0,
 PluginArray: 0,
 SVGLengthList: 0,
 SVGNumberList: 0,
 SVGPathSegList: 0,
 SVGPointList: 0,
 SVGStringList: 0,
 SVGTransformList: 0,
 SourceBufferList: 0,
 StyleSheetList: 0,
 TextTrackCueList: 0,
 TextTrackList: 0,
 TouchList: 0
};

/***/ }),
/* 111 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(112);
__w_pdfjs_require__(120);
__w_pdfjs_require__(118);
var path = __w_pdfjs_require__(42);
module.exports = path.URL;

/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

__w_pdfjs_require__(107);
var $ = __w_pdfjs_require__(9);
var DESCRIPTORS = __w_pdfjs_require__(12);
var USE_NATIVE_URL = __w_pdfjs_require__(113);
var global = __w_pdfjs_require__(10);
var defineProperties = __w_pdfjs_require__(59);
var redefine = __w_pdfjs_require__(28);
var anInstance = __w_pdfjs_require__(90);
var has = __w_pdfjs_require__(22);
var assign = __w_pdfjs_require__(114);
var arrayFrom = __w_pdfjs_require__(115);
var codeAt = __w_pdfjs_require__(108).codeAt;
var toASCII = __w_pdfjs_require__(117);
var setToStringTag = __w_pdfjs_require__(69);
var URLSearchParamsModule = __w_pdfjs_require__(118);
var InternalStateModule = __w_pdfjs_require__(32);
var NativeURL = global.URL;
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;
var parseHost = function (url, input) {
 var result, codePoints, index;
 if (input.charAt(0) == '[') {
  if (input.charAt(input.length - 1) != ']')
   return INVALID_HOST;
  result = parseIPv6(input.slice(1, -1));
  if (!result)
   return INVALID_HOST;
  url.host = result;
 } else if (!isSpecial(url)) {
  if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
   return INVALID_HOST;
  result = '';
  codePoints = arrayFrom(input);
  for (index = 0; index < codePoints.length; index++) {
   result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
  }
  url.host = result;
 } else {
  input = toASCII(input);
  if (FORBIDDEN_HOST_CODE_POINT.test(input))
   return INVALID_HOST;
  result = parseIPv4(input);
  if (result === null)
   return INVALID_HOST;
  url.host = result;
 }
};
var parseIPv4 = function (input) {
 var parts = input.split('.');
 var partsLength, numbers, index, part, radix, number, ipv4;
 if (parts.length && parts[parts.length - 1] == '') {
  parts.pop();
 }
 partsLength = parts.length;
 if (partsLength > 4)
  return input;
 numbers = [];
 for (index = 0; index < partsLength; index++) {
  part = parts[index];
  if (part == '')
   return input;
  radix = 10;
  if (part.length > 1 && part.charAt(0) == '0') {
   radix = HEX_START.test(part) ? 16 : 8;
   part = part.slice(radix == 8 ? 1 : 2);
  }
  if (part === '') {
   number = 0;
  } else {
   if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))
    return input;
   number = parseInt(part, radix);
  }
  numbers.push(number);
 }
 for (index = 0; index < partsLength; index++) {
  number = numbers[index];
  if (index == partsLength - 1) {
   if (number >= pow(256, 5 - partsLength))
    return null;
  } else if (number > 255)
   return null;
 }
 ipv4 = numbers.pop();
 for (index = 0; index < numbers.length; index++) {
  ipv4 += numbers[index] * pow(256, 3 - index);
 }
 return ipv4;
};
var parseIPv6 = function (input) {
 var address = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 ];
 var pieceIndex = 0;
 var compress = null;
 var pointer = 0;
 var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
 var char = function () {
  return input.charAt(pointer);
 };
 if (char() == ':') {
  if (input.charAt(1) != ':')
   return;
  pointer += 2;
  pieceIndex++;
  compress = pieceIndex;
 }
 while (char()) {
  if (pieceIndex == 8)
   return;
  if (char() == ':') {
   if (compress !== null)
    return;
   pointer++;
   pieceIndex++;
   compress = pieceIndex;
   continue;
  }
  value = length = 0;
  while (length < 4 && HEX.test(char())) {
   value = value * 16 + parseInt(char(), 16);
   pointer++;
   length++;
  }
  if (char() == '.') {
   if (length == 0)
    return;
   pointer -= length;
   if (pieceIndex > 6)
    return;
   numbersSeen = 0;
   while (char()) {
    ipv4Piece = null;
    if (numbersSeen > 0) {
     if (char() == '.' && numbersSeen < 4)
      pointer++;
     else
      return;
    }
    if (!DIGIT.test(char()))
     return;
    while (DIGIT.test(char())) {
     number = parseInt(char(), 10);
     if (ipv4Piece === null)
      ipv4Piece = number;
     else if (ipv4Piece == 0)
      return;
     else
      ipv4Piece = ipv4Piece * 10 + number;
     if (ipv4Piece > 255)
      return;
     pointer++;
    }
    address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
    numbersSeen++;
    if (numbersSeen == 2 || numbersSeen == 4)
     pieceIndex++;
   }
   if (numbersSeen != 4)
    return;
   break;
  } else if (char() == ':') {
   pointer++;
   if (!char())
    return;
  } else if (char())
   return;
  address[pieceIndex++] = value;
 }
 if (compress !== null) {
  swaps = pieceIndex - compress;
  pieceIndex = 7;
  while (pieceIndex != 0 && swaps > 0) {
   swap = address[pieceIndex];
   address[pieceIndex--] = address[compress + swaps - 1];
   address[compress + --swaps] = swap;
  }
 } else if (pieceIndex != 8)
  return;
 return address;
};
var findLongestZeroSequence = function (ipv6) {
 var maxIndex = null;
 var maxLength = 1;
 var currStart = null;
 var currLength = 0;
 var index = 0;
 for (; index < 8; index++) {
  if (ipv6[index] !== 0) {
   if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
   }
   currStart = null;
   currLength = 0;
  } else {
   if (currStart === null)
    currStart = index;
   ++currLength;
  }
 }
 if (currLength > maxLength) {
  maxIndex = currStart;
  maxLength = currLength;
 }
 return maxIndex;
};
var serializeHost = function (host) {
 var result, index, compress, ignore0;
 if (typeof host == 'number') {
  result = [];
  for (index = 0; index < 4; index++) {
   result.unshift(host % 256);
   host = floor(host / 256);
  }
  return result.join('.');
 } else if (typeof host == 'object') {
  result = '';
  compress = findLongestZeroSequence(host);
  for (index = 0; index < 8; index++) {
   if (ignore0 && host[index] === 0)
    continue;
   if (ignore0)
    ignore0 = false;
   if (compress === index) {
    result += index ? ':' : '::';
    ignore0 = true;
   } else {
    result += host[index].toString(16);
    if (index < 7)
     result += ':';
   }
  }
  return '[' + result + ']';
 }
 return host;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
 ' ': 1,
 '"': 1,
 '<': 1,
 '>': 1,
 '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
 '#': 1,
 '?': 1,
 '{': 1,
 '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
 '/': 1,
 ':': 1,
 ';': 1,
 '=': 1,
 '@': 1,
 '[': 1,
 '\\': 1,
 ']': 1,
 '^': 1,
 '|': 1
});
var percentEncode = function (char, set) {
 var code = codeAt(char, 0);
 return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};
var specialSchemes = {
 ftp: 21,
 file: null,
 http: 80,
 https: 443,
 ws: 80,
 wss: 443
};
var isSpecial = function (url) {
 return has(specialSchemes, url.scheme);
};
var includesCredentials = function (url) {
 return url.username != '' || url.password != '';
};
var cannotHaveUsernamePasswordPort = function (url) {
 return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};
var isWindowsDriveLetter = function (string, normalized) {
 var second;
 return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
};
var startsWithWindowsDriveLetter = function (string) {
 var third;
 return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#'));
};
var shortenURLsPath = function (url) {
 var path = url.path;
 var pathSize = path.length;
 if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
  path.pop();
 }
};
var isSingleDot = function (segment) {
 return segment === '.' || segment.toLowerCase() === '%2e';
};
var isDoubleDot = function (segment) {
 segment = segment.toLowerCase();
 return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};
var parseURL = function (url, input, stateOverride, base) {
 var state = stateOverride || SCHEME_START;
 var pointer = 0;
 var buffer = '';
 var seenAt = false;
 var seenBracket = false;
 var seenPasswordToken = false;
 var codePoints, char, bufferCodePoints, failure;
 if (!stateOverride) {
  url.scheme = '';
  url.username = '';
  url.password = '';
  url.host = null;
  url.port = null;
  url.path = [];
  url.query = null;
  url.fragment = null;
  url.cannotBeABaseURL = false;
  input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
 }
 input = input.replace(TAB_AND_NEW_LINE, '');
 codePoints = arrayFrom(input);
 while (pointer <= codePoints.length) {
  char = codePoints[pointer];
  switch (state) {
  case SCHEME_START:
   if (char && ALPHA.test(char)) {
    buffer += char.toLowerCase();
    state = SCHEME;
   } else if (!stateOverride) {
    state = NO_SCHEME;
    continue;
   } else
    return INVALID_SCHEME;
   break;
  case SCHEME:
   if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
    buffer += char.toLowerCase();
   } else if (char == ':') {
    if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host))
     return;
    url.scheme = buffer;
    if (stateOverride) {
     if (isSpecial(url) && specialSchemes[url.scheme] == url.port)
      url.port = null;
     return;
    }
    buffer = '';
    if (url.scheme == 'file') {
     state = FILE;
    } else if (isSpecial(url) && base && base.scheme == url.scheme) {
     state = SPECIAL_RELATIVE_OR_AUTHORITY;
    } else if (isSpecial(url)) {
     state = SPECIAL_AUTHORITY_SLASHES;
    } else if (codePoints[pointer + 1] == '/') {
     state = PATH_OR_AUTHORITY;
     pointer++;
    } else {
     url.cannotBeABaseURL = true;
     url.path.push('');
     state = CANNOT_BE_A_BASE_URL_PATH;
    }
   } else if (!stateOverride) {
    buffer = '';
    state = NO_SCHEME;
    pointer = 0;
    continue;
   } else
    return INVALID_SCHEME;
   break;
  case NO_SCHEME:
   if (!base || base.cannotBeABaseURL && char != '#')
    return INVALID_SCHEME;
   if (base.cannotBeABaseURL && char == '#') {
    url.scheme = base.scheme;
    url.path = base.path.slice();
    url.query = base.query;
    url.fragment = '';
    url.cannotBeABaseURL = true;
    state = FRAGMENT;
    break;
   }
   state = base.scheme == 'file' ? FILE : RELATIVE;
   continue;
  case SPECIAL_RELATIVE_OR_AUTHORITY:
   if (char == '/' && codePoints[pointer + 1] == '/') {
    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
    pointer++;
   } else {
    state = RELATIVE;
    continue;
   }
   break;
  case PATH_OR_AUTHORITY:
   if (char == '/') {
    state = AUTHORITY;
    break;
   } else {
    state = PATH;
    continue;
   }
  case RELATIVE:
   url.scheme = base.scheme;
   if (char == EOF) {
    url.username = base.username;
    url.password = base.password;
    url.host = base.host;
    url.port = base.port;
    url.path = base.path.slice();
    url.query = base.query;
   } else if (char == '/' || char == '\\' && isSpecial(url)) {
    state = RELATIVE_SLASH;
   } else if (char == '?') {
    url.username = base.username;
    url.password = base.password;
    url.host = base.host;
    url.port = base.port;
    url.path = base.path.slice();
    url.query = '';
    state = QUERY;
   } else if (char == '#') {
    url.username = base.username;
    url.password = base.password;
    url.host = base.host;
    url.port = base.port;
    url.path = base.path.slice();
    url.query = base.query;
    url.fragment = '';
    state = FRAGMENT;
   } else {
    url.username = base.username;
    url.password = base.password;
    url.host = base.host;
    url.port = base.port;
    url.path = base.path.slice();
    url.path.pop();
    state = PATH;
    continue;
   }
   break;
  case RELATIVE_SLASH:
   if (isSpecial(url) && (char == '/' || char == '\\')) {
    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
   } else if (char == '/') {
    state = AUTHORITY;
   } else {
    url.username = base.username;
    url.password = base.password;
    url.host = base.host;
    url.port = base.port;
    state = PATH;
    continue;
   }
   break;
  case SPECIAL_AUTHORITY_SLASHES:
   state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
   if (char != '/' || buffer.charAt(pointer + 1) != '/')
    continue;
   pointer++;
   break;
  case SPECIAL_AUTHORITY_IGNORE_SLASHES:
   if (char != '/' && char != '\\') {
    state = AUTHORITY;
    continue;
   }
   break;
  case AUTHORITY:
   if (char == '@') {
    if (seenAt)
     buffer = '%40' + buffer;
    seenAt = true;
    bufferCodePoints = arrayFrom(buffer);
    for (var i = 0; i < bufferCodePoints.length; i++) {
     var codePoint = bufferCodePoints[i];
     if (codePoint == ':' && !seenPasswordToken) {
      seenPasswordToken = true;
      continue;
     }
     var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
     if (seenPasswordToken)
      url.password += encodedCodePoints;
     else
      url.username += encodedCodePoints;
    }
    buffer = '';
   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
    if (seenAt && buffer == '')
     return INVALID_AUTHORITY;
    pointer -= arrayFrom(buffer).length + 1;
    buffer = '';
    state = HOST;
   } else
    buffer += char;
   break;
  case HOST:
  case HOSTNAME:
   if (stateOverride && url.scheme == 'file') {
    state = FILE_HOST;
    continue;
   } else if (char == ':' && !seenBracket) {
    if (buffer == '')
     return INVALID_HOST;
    failure = parseHost(url, buffer);
    if (failure)
     return failure;
    buffer = '';
    state = PORT;
    if (stateOverride == HOSTNAME)
     return;
   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
    if (isSpecial(url) && buffer == '')
     return INVALID_HOST;
    if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null))
     return;
    failure = parseHost(url, buffer);
    if (failure)
     return failure;
    buffer = '';
    state = PATH_START;
    if (stateOverride)
     return;
    continue;
   } else {
    if (char == '[')
     seenBracket = true;
    else if (char == ']')
     seenBracket = false;
    buffer += char;
   }
   break;
  case PORT:
   if (DIGIT.test(char)) {
    buffer += char;
   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
    if (buffer != '') {
     var port = parseInt(buffer, 10);
     if (port > 0xFFFF)
      return INVALID_PORT;
     url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
     buffer = '';
    }
    if (stateOverride)
     return;
    state = PATH_START;
    continue;
   } else
    return INVALID_PORT;
   break;
  case FILE:
   url.scheme = 'file';
   if (char == '/' || char == '\\')
    state = FILE_SLASH;
   else if (base && base.scheme == 'file') {
    if (char == EOF) {
     url.host = base.host;
     url.path = base.path.slice();
     url.query = base.query;
    } else if (char == '?') {
     url.host = base.host;
     url.path = base.path.slice();
     url.query = '';
     state = QUERY;
    } else if (char == '#') {
     url.host = base.host;
     url.path = base.path.slice();
     url.query = base.query;
     url.fragment = '';
     state = FRAGMENT;
    } else {
     if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
      url.host = base.host;
      url.path = base.path.slice();
      shortenURLsPath(url);
     }
     state = PATH;
     continue;
    }
   } else {
    state = PATH;
    continue;
   }
   break;
  case FILE_SLASH:
   if (char == '/' || char == '\\') {
    state = FILE_HOST;
    break;
   }
   if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
    if (isWindowsDriveLetter(base.path[0], true))
     url.path.push(base.path[0]);
    else
     url.host = base.host;
   }
   state = PATH;
   continue;
  case FILE_HOST:
   if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
    if (!stateOverride && isWindowsDriveLetter(buffer)) {
     state = PATH;
    } else if (buffer == '') {
     url.host = '';
     if (stateOverride)
      return;
     state = PATH_START;
    } else {
     failure = parseHost(url, buffer);
     if (failure)
      return failure;
     if (url.host == 'localhost')
      url.host = '';
     if (stateOverride)
      return;
     buffer = '';
     state = PATH_START;
    }
    continue;
   } else
    buffer += char;
   break;
  case PATH_START:
   if (isSpecial(url)) {
    state = PATH;
    if (char != '/' && char != '\\')
     continue;
   } else if (!stateOverride && char == '?') {
    url.query = '';
    state = QUERY;
   } else if (!stateOverride && char == '#') {
    url.fragment = '';
    state = FRAGMENT;
   } else if (char != EOF) {
    state = PATH;
    if (char != '/')
     continue;
   }
   break;
  case PATH:
   if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
    if (isDoubleDot(buffer)) {
     shortenURLsPath(url);
     if (char != '/' && !(char == '\\' && isSpecial(url))) {
      url.path.push('');
     }
    } else if (isSingleDot(buffer)) {
     if (char != '/' && !(char == '\\' && isSpecial(url))) {
      url.path.push('');
     }
    } else {
     if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
      if (url.host)
       url.host = '';
      buffer = buffer.charAt(0) + ':';
     }
     url.path.push(buffer);
    }
    buffer = '';
    if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
     while (url.path.length > 1 && url.path[0] === '') {
      url.path.shift();
     }
    }
    if (char == '?') {
     url.query = '';
     state = QUERY;
    } else if (char == '#') {
     url.fragment = '';
     state = FRAGMENT;
    }
   } else {
    buffer += percentEncode(char, pathPercentEncodeSet);
   }
   break;
  case CANNOT_BE_A_BASE_URL_PATH:
   if (char == '?') {
    url.query = '';
    state = QUERY;
   } else if (char == '#') {
    url.fragment = '';
    state = FRAGMENT;
   } else if (char != EOF) {
    url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
   }
   break;
  case QUERY:
   if (!stateOverride && char == '#') {
    url.fragment = '';
    state = FRAGMENT;
   } else if (char != EOF) {
    if (char == "'" && isSpecial(url))
     url.query += '%27';
    else if (char == '#')
     url.query += '%23';
    else
     url.query += percentEncode(char, C0ControlPercentEncodeSet);
   }
   break;
  case FRAGMENT:
   if (char != EOF)
    url.fragment += percentEncode(char, fragmentPercentEncodeSet);
   break;
  }
  pointer++;
 }
};
var URLConstructor = function URL(url) {
 var that = anInstance(this, URLConstructor, 'URL');
 var base = arguments.length > 1 ? arguments[1] : undefined;
 var urlString = String(url);
 var state = setInternalState(that, { type: 'URL' });
 var baseState, failure;
 if (base !== undefined) {
  if (base instanceof URLConstructor)
   baseState = getInternalURLState(base);
  else {
   failure = parseURL(baseState = {}, String(base));
   if (failure)
    throw TypeError(failure);
  }
 }
 failure = parseURL(state, urlString, null, baseState);
 if (failure)
  throw TypeError(failure);
 var searchParams = state.searchParams = new URLSearchParams();
 var searchParamsState = getInternalSearchParamsState(searchParams);
 searchParamsState.updateSearchParams(state.query);
 searchParamsState.updateURL = function () {
  state.query = String(searchParams) || null;
 };
 if (!DESCRIPTORS) {
  that.href = serializeURL.call(that);
  that.origin = getOrigin.call(that);
  that.protocol = getProtocol.call(that);
  that.username = getUsername.call(that);
  that.password = getPassword.call(that);
  that.host = getHost.call(that);
  that.hostname = getHostname.call(that);
  that.port = getPort.call(that);
  that.pathname = getPathname.call(that);
  that.search = getSearch.call(that);
  that.searchParams = getSearchParams.call(that);
  that.hash = getHash.call(that);
 }
};
var URLPrototype = URLConstructor.prototype;
var serializeURL = function () {
 var url = getInternalURLState(this);
 var scheme = url.scheme;
 var username = url.username;
 var password = url.password;
 var host = url.host;
 var port = url.port;
 var path = url.path;
 var query = url.query;
 var fragment = url.fragment;
 var output = scheme + ':';
 if (host !== null) {
  output += '//';
  if (includesCredentials(url)) {
   output += username + (password ? ':' + password : '') + '@';
  }
  output += serializeHost(host);
  if (port !== null)
   output += ':' + port;
 } else if (scheme == 'file')
  output += '//';
 output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
 if (query !== null)
  output += '?' + query;
 if (fragment !== null)
  output += '#' + fragment;
 return output;
};
var getOrigin = function () {
 var url = getInternalURLState(this);
 var scheme = url.scheme;
 var port = url.port;
 if (scheme == 'blob')
  try {
   return new URL(scheme.path[0]).origin;
  } catch (error) {
   return 'null';
  }
 if (scheme == 'file' || !isSpecial(url))
  return 'null';
 return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};
var getProtocol = function () {
 return getInternalURLState(this).scheme + ':';
};
var getUsername = function () {
 return getInternalURLState(this).username;
};
var getPassword = function () {
 return getInternalURLState(this).password;
};
var getHost = function () {
 var url = getInternalURLState(this);
 var host = url.host;
 var port = url.port;
 return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
};
var getHostname = function () {
 var host = getInternalURLState(this).host;
 return host === null ? '' : serializeHost(host);
};
var getPort = function () {
 var port = getInternalURLState(this).port;
 return port === null ? '' : String(port);
};
var getPathname = function () {
 var url = getInternalURLState(this);
 var path = url.path;
 return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};
var getSearch = function () {
 var query = getInternalURLState(this).query;
 return query ? '?' + query : '';
};
var getSearchParams = function () {
 return getInternalURLState(this).searchParams;
};
var getHash = function () {
 var fragment = getInternalURLState(this).fragment;
 return fragment ? '#' + fragment : '';
};
var accessorDescriptor = function (getter, setter) {
 return {
  get: getter,
  set: setter,
  configurable: true,
  enumerable: true
 };
};
if (DESCRIPTORS) {
 defineProperties(URLPrototype, {
  href: accessorDescriptor(serializeURL, function (href) {
   var url = getInternalURLState(this);
   var urlString = String(href);
   var failure = parseURL(url, urlString);
   if (failure)
    throw TypeError(failure);
   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
  }),
  origin: accessorDescriptor(getOrigin),
  protocol: accessorDescriptor(getProtocol, function (protocol) {
   var url = getInternalURLState(this);
   parseURL(url, String(protocol) + ':', SCHEME_START);
  }),
  username: accessorDescriptor(getUsername, function (username) {
   var url = getInternalURLState(this);
   var codePoints = arrayFrom(String(username));
   if (cannotHaveUsernamePasswordPort(url))
    return;
   url.username = '';
   for (var i = 0; i < codePoints.length; i++) {
    url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
   }
  }),
  password: accessorDescriptor(getPassword, function (password) {
   var url = getInternalURLState(this);
   var codePoints = arrayFrom(String(password));
   if (cannotHaveUsernamePasswordPort(url))
    return;
   url.password = '';
   for (var i = 0; i < codePoints.length; i++) {
    url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
   }
  }),
  host: accessorDescriptor(getHost, function (host) {
   var url = getInternalURLState(this);
   if (url.cannotBeABaseURL)
    return;
   parseURL(url, String(host), HOST);
  }),
  hostname: accessorDescriptor(getHostname, function (hostname) {
   var url = getInternalURLState(this);
   if (url.cannotBeABaseURL)
    return;
   parseURL(url, String(hostname), HOSTNAME);
  }),
  port: accessorDescriptor(getPort, function (port) {
   var url = getInternalURLState(this);
   if (cannotHaveUsernamePasswordPort(url))
    return;
   port = String(port);
   if (port == '')
    url.port = null;
   else
    parseURL(url, port, PORT);
  }),
  pathname: accessorDescriptor(getPathname, function (pathname) {
   var url = getInternalURLState(this);
   if (url.cannotBeABaseURL)
    return;
   url.path = [];
   parseURL(url, pathname + '', PATH_START);
  }),
  search: accessorDescriptor(getSearch, function (search) {
   var url = getInternalURLState(this);
   search = String(search);
   if (search == '') {
    url.query = null;
   } else {
    if ('?' == search.charAt(0))
     search = search.slice(1);
    url.query = '';
    parseURL(url, search, QUERY);
   }
   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
  }),
  searchParams: accessorDescriptor(getSearchParams),
  hash: accessorDescriptor(getHash, function (hash) {
   var url = getInternalURLState(this);
   hash = String(hash);
   if (hash == '') {
    url.fragment = null;
    return;
   }
   if ('#' == hash.charAt(0))
    hash = hash.slice(1);
   url.fragment = '';
   parseURL(url, hash, FRAGMENT);
  })
 });
}
redefine(URLPrototype, 'toJSON', function toJSON() {
 return serializeURL.call(this);
}, { enumerable: true });
redefine(URLPrototype, 'toString', function toString() {
 return serializeURL.call(this);
}, { enumerable: true });
if (NativeURL) {
 var nativeCreateObjectURL = NativeURL.createObjectURL;
 var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
 if (nativeCreateObjectURL)
  redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
   return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
 if (nativeRevokeObjectURL)
  redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
   return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}
setToStringTag(URLConstructor, 'URL');
$({
 global: true,
 forced: !USE_NATIVE_URL,
 sham: !DESCRIPTORS
}, { URL: URLConstructor });

/***/ }),
/* 113 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(13);
var wellKnownSymbol = __w_pdfjs_require__(55);
var IS_PURE = __w_pdfjs_require__(36);
var ITERATOR = wellKnownSymbol('iterator');
module.exports = !fails(function () {
 var url = new URL('b?a=1&b=2&c=3', 'http://a');
 var searchParams = url.searchParams;
 var result = '';
 url.pathname = 'c%20d';
 searchParams.forEach(function (value, key) {
  searchParams['delete']('b');
  result += key + value;
 });
 return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://').host !== 'xn--e1aybc' || new URL('http://a#').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';
});

/***/ }),
/* 114 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var DESCRIPTORS = __w_pdfjs_require__(12);
var fails = __w_pdfjs_require__(13);
var objectKeys = __w_pdfjs_require__(60);
var getOwnPropertySymbolsModule = __w_pdfjs_require__(50);
var propertyIsEnumerableModule = __w_pdfjs_require__(14);
var toObject = __w_pdfjs_require__(67);
var IndexedObject = __w_pdfjs_require__(17);
var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;
module.exports = !nativeAssign || fails(function () {
 if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
   enumerable: true,
   get: function () {
    defineProperty(this, 'b', {
     value: 3,
     enumerable: false
    });
   }
  }), { b: 2 })).b !== 1)
  return true;
 var A = {};
 var B = {};
 var symbol = Symbol();
 var alphabet = 'abcdefghijklmnopqrst';
 A[symbol] = 7;
 alphabet.split('').forEach(function (chr) {
  B[chr] = chr;
 });
 return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
 var T = toObject(target);
 var argumentsLength = arguments.length;
 var index = 1;
 var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
 var propertyIsEnumerable = propertyIsEnumerableModule.f;
 while (argumentsLength > index) {
  var S = IndexedObject(arguments[index++]);
  var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
  var length = keys.length;
  var j = 0;
  var key;
  while (length > j) {
   key = keys[j++];
   if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
    T[key] = S[key];
  }
 }
 return T;
} : nativeAssign;

/***/ }),
/* 115 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var bind = __w_pdfjs_require__(75);
var toObject = __w_pdfjs_require__(67);
var callWithSafeIterationClosing = __w_pdfjs_require__(116);
var isArrayIteratorMethod = __w_pdfjs_require__(74);
var toLength = __w_pdfjs_require__(46);
var createProperty = __w_pdfjs_require__(81);
var getIteratorMethod = __w_pdfjs_require__(77);
module.exports = function from(arrayLike) {
 var O = toObject(arrayLike);
 var C = typeof this == 'function' ? this : Array;
 var argumentsLength = arguments.length;
 var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
 var mapping = mapfn !== undefined;
 var iteratorMethod = getIteratorMethod(O);
 var index = 0;
 var length, result, step, iterator, next, value;
 if (mapping)
  mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
 if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
  iterator = iteratorMethod.call(O);
  next = iterator.next;
  result = new C();
  for (; !(step = next.call(iterator)).done; index++) {
   value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [
    step.value,
    index
   ], true) : step.value;
   createProperty(result, index, value);
  }
 } else {
  length = toLength(O.length);
  result = new C(length);
  for (; length > index; index++) {
   value = mapping ? mapfn(O[index], index) : O[index];
   createProperty(result, index, value);
  }
 }
 result.length = index;
 return result;
};

/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var iteratorClose = __w_pdfjs_require__(80);
module.exports = function (iterator, fn, value, ENTRIES) {
 try {
  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
 } catch (error) {
  iteratorClose(iterator);
  throw error;
 }
};

/***/ }),
/* 117 */
/***/ ((module) => {

"use strict";

var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = '-';
var regexNonASCII = /[^\0-\u007E]/;
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
var ucs2decode = function (string) {
 var output = [];
 var counter = 0;
 var length = string.length;
 while (counter < length) {
  var value = string.charCodeAt(counter++);
  if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
   var extra = string.charCodeAt(counter++);
   if ((extra & 0xFC00) == 0xDC00) {
    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
   } else {
    output.push(value);
    counter--;
   }
  } else {
   output.push(value);
  }
 }
 return output;
};
var digitToBasic = function (digit) {
 return digit + 22 + 75 * (digit < 26);
};
var adapt = function (delta, numPoints, firstTime) {
 var k = 0;
 delta = firstTime ? floor(delta / damp) : delta >> 1;
 delta += floor(delta / numPoints);
 for (; delta > baseMinusTMin * tMax >> 1; k += base) {
  delta = floor(delta / baseMinusTMin);
 }
 return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var encode = function (input) {
 var output = [];
 input = ucs2decode(input);
 var inputLength = input.length;
 var n = initialN;
 var delta = 0;
 var bias = initialBias;
 var i, currentValue;
 for (i = 0; i < input.length; i++) {
  currentValue = input[i];
  if (currentValue < 0x80) {
   output.push(stringFromCharCode(currentValue));
  }
 }
 var basicLength = output.length;
 var handledCPCount = basicLength;
 if (basicLength) {
  output.push(delimiter);
 }
 while (handledCPCount < inputLength) {
  var m = maxInt;
  for (i = 0; i < input.length; i++) {
   currentValue = input[i];
   if (currentValue >= n && currentValue < m) {
    m = currentValue;
   }
  }
  var handledCPCountPlusOne = handledCPCount + 1;
  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
   throw RangeError(OVERFLOW_ERROR);
  }
  delta += (m - n) * handledCPCountPlusOne;
  n = m;
  for (i = 0; i < input.length; i++) {
   currentValue = input[i];
   if (currentValue < n && ++delta > maxInt) {
    throw RangeError(OVERFLOW_ERROR);
   }
   if (currentValue == n) {
    var q = delta;
    for (var k = base;; k += base) {
     var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
     if (q < t)
      break;
     var qMinusT = q - t;
     var baseMinusT = base - t;
     output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
     q = floor(qMinusT / baseMinusT);
    }
    output.push(stringFromCharCode(digitToBasic(q)));
    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    delta = 0;
    ++handledCPCount;
   }
  }
  ++delta;
  ++n;
 }
 return output.join('');
};
module.exports = function (input) {
 var encoded = [];
 var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
 var i, label;
 for (i = 0; i < labels.length; i++) {
  label = labels[i];
  encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
 }
 return encoded.join('.');
};

/***/ }),
/* 118 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

__w_pdfjs_require__(53);
var $ = __w_pdfjs_require__(9);
var getBuiltIn = __w_pdfjs_require__(41);
var USE_NATIVE_URL = __w_pdfjs_require__(113);
var redefine = __w_pdfjs_require__(28);
var redefineAll = __w_pdfjs_require__(88);
var setToStringTag = __w_pdfjs_require__(69);
var createIteratorConstructor = __w_pdfjs_require__(64);
var InternalStateModule = __w_pdfjs_require__(32);
var anInstance = __w_pdfjs_require__(90);
var hasOwn = __w_pdfjs_require__(22);
var bind = __w_pdfjs_require__(75);
var classof = __w_pdfjs_require__(78);
var anObject = __w_pdfjs_require__(27);
var isObject = __w_pdfjs_require__(21);
var create = __w_pdfjs_require__(58);
var createPropertyDescriptor = __w_pdfjs_require__(15);
var getIterator = __w_pdfjs_require__(119);
var getIteratorMethod = __w_pdfjs_require__(77);
var wellKnownSymbol = __w_pdfjs_require__(55);
var $fetch = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var plus = /\+/g;
var sequences = Array(4);
var percentSequence = function (bytes) {
 return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};
var percentDecode = function (sequence) {
 try {
  return decodeURIComponent(sequence);
 } catch (error) {
  return sequence;
 }
};
var deserialize = function (it) {
 var result = it.replace(plus, ' ');
 var bytes = 4;
 try {
  return decodeURIComponent(result);
 } catch (error) {
  while (bytes) {
   result = result.replace(percentSequence(bytes--), percentDecode);
  }
  return result;
 }
};
var find = /[!'()~]|%20/g;
var replace = {
 '!': '%21',
 "'": '%27',
 '(': '%28',
 ')': '%29',
 '~': '%7E',
 '%20': '+'
};
var replacer = function (match) {
 return replace[match];
};
var serialize = function (it) {
 return encodeURIComponent(it).replace(find, replacer);
};
var parseSearchParams = function (result, query) {
 if (query) {
  var attributes = query.split('&');
  var index = 0;
  var attribute, entry;
  while (index < attributes.length) {
   attribute = attributes[index++];
   if (attribute.length) {
    entry = attribute.split('=');
    result.push({
     key: deserialize(entry.shift()),
     value: deserialize(entry.join('='))
    });
   }
  }
 }
};
var updateSearchParams = function (query) {
 this.entries.length = 0;
 parseSearchParams(this.entries, query);
};
var validateArgumentsLength = function (passed, required) {
 if (passed < required)
  throw TypeError('Not enough arguments');
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
 setInternalState(this, {
  type: URL_SEARCH_PARAMS_ITERATOR,
  iterator: getIterator(getInternalParamsState(params).entries),
  kind: kind
 });
}, 'Iterator', function next() {
 var state = getInternalIteratorState(this);
 var kind = state.kind;
 var step = state.iterator.next();
 var entry = step.value;
 if (!step.done) {
  step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [
   entry.key,
   entry.value
  ];
 }
 return step;
});
var URLSearchParamsConstructor = function URLSearchParams() {
 anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
 var init = arguments.length > 0 ? arguments[0] : undefined;
 var that = this;
 var entries = [];
 var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
 setInternalState(that, {
  type: URL_SEARCH_PARAMS,
  entries: entries,
  updateURL: function () {
  },
  updateSearchParams: updateSearchParams
 });
 if (init !== undefined) {
  if (isObject(init)) {
   iteratorMethod = getIteratorMethod(init);
   if (typeof iteratorMethod === 'function') {
    iterator = iteratorMethod.call(init);
    next = iterator.next;
    while (!(step = next.call(iterator)).done) {
     entryIterator = getIterator(anObject(step.value));
     entryNext = entryIterator.next;
     if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)
      throw TypeError('Expected sequence with length 2');
     entries.push({
      key: first.value + '',
      value: second.value + ''
     });
    }
   } else
    for (key in init)
     if (hasOwn(init, key))
      entries.push({
       key: key,
       value: init[key] + ''
      });
  } else {
   parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
  }
 }
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
 append: function append(name, value) {
  validateArgumentsLength(arguments.length, 2);
  var state = getInternalParamsState(this);
  state.entries.push({
   key: name + '',
   value: value + ''
  });
  state.updateURL();
 },
 'delete': function (name) {
  validateArgumentsLength(arguments.length, 1);
  var state = getInternalParamsState(this);
  var entries = state.entries;
  var key = name + '';
  var index = 0;
  while (index < entries.length) {
   if (entries[index].key === key)
    entries.splice(index, 1);
   else
    index++;
  }
  state.updateURL();
 },
 get: function get(name) {
  validateArgumentsLength(arguments.length, 1);
  var entries = getInternalParamsState(this).entries;
  var key = name + '';
  var index = 0;
  for (; index < entries.length; index++) {
   if (entries[index].key === key)
    return entries[index].value;
  }
  return null;
 },
 getAll: function getAll(name) {
  validateArgumentsLength(arguments.length, 1);
  var entries = getInternalParamsState(this).entries;
  var key = name + '';
  var result = [];
  var index = 0;
  for (; index < entries.length; index++) {
   if (entries[index].key === key)
    result.push(entries[index].value);
  }
  return result;
 },
 has: function has(name) {
  validateArgumentsLength(arguments.length, 1);
  var entries = getInternalParamsState(this).entries;
  var key = name + '';
  var index = 0;
  while (index < entries.length) {
   if (entries[index++].key === key)
    return true;
  }
  return false;
 },
 set: function set(name, value) {
  validateArgumentsLength(arguments.length, 1);
  var state = getInternalParamsState(this);
  var entries = state.entries;
  var found = false;
  var key = name + '';
  var val = value + '';
  var index = 0;
  var entry;
  for (; index < entries.length; index++) {
   entry = entries[index];
   if (entry.key === key) {
    if (found)
     entries.splice(index--, 1);
    else {
     found = true;
     entry.value = val;
    }
   }
  }
  if (!found)
   entries.push({
    key: key,
    value: val
   });
  state.updateURL();
 },
 sort: function sort() {
  var state = getInternalParamsState(this);
  var entries = state.entries;
  var slice = entries.slice();
  var entry, entriesIndex, sliceIndex;
  entries.length = 0;
  for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
   entry = slice[sliceIndex];
   for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
    if (entries[entriesIndex].key > entry.key) {
     entries.splice(entriesIndex, 0, entry);
     break;
    }
   }
   if (entriesIndex === sliceIndex)
    entries.push(entry);
  }
  state.updateURL();
 },
 forEach: function forEach(callback) {
  var entries = getInternalParamsState(this).entries;
  var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
  var index = 0;
  var entry;
  while (index < entries.length) {
   entry = entries[index++];
   boundFunction(entry.value, entry.key, this);
  }
 },
 keys: function keys() {
  return new URLSearchParamsIterator(this, 'keys');
 },
 values: function values() {
  return new URLSearchParamsIterator(this, 'values');
 },
 entries: function entries() {
  return new URLSearchParamsIterator(this, 'entries');
 }
}, { enumerable: true });
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
redefine(URLSearchParamsPrototype, 'toString', function toString() {
 var entries = getInternalParamsState(this).entries;
 var result = [];
 var index = 0;
 var entry;
 while (index < entries.length) {
  entry = entries[index++];
  result.push(serialize(entry.key) + '=' + serialize(entry.value));
 }
 return result.join('&');
}, { enumerable: true });
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$({
 global: true,
 forced: !USE_NATIVE_URL
}, { URLSearchParams: URLSearchParamsConstructor });
if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {
 $({
  global: true,
  enumerable: true,
  forced: true
 }, {
  fetch: function fetch(input) {
   var args = [input];
   var init, body, headers;
   if (arguments.length > 1) {
    init = arguments[1];
    if (isObject(init)) {
     body = init.body;
     if (classof(body) === URL_SEARCH_PARAMS) {
      headers = init.headers ? new Headers(init.headers) : new Headers();
      if (!headers.has('content-type')) {
       headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
      init = create(init, {
       body: createPropertyDescriptor(0, String(body)),
       headers: createPropertyDescriptor(0, headers)
      });
     }
    }
    args.push(init);
   }
   return $fetch.apply(this, args);
  }
 });
}
module.exports = {
 URLSearchParams: URLSearchParamsConstructor,
 getState: getInternalParamsState
};

/***/ }),
/* 119 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(27);
var getIteratorMethod = __w_pdfjs_require__(77);
module.exports = function (it) {
 var iteratorMethod = getIteratorMethod(it);
 if (typeof iteratorMethod != 'function') {
  throw TypeError(String(it) + ' is not iterable');
 }
 return anObject(iteratorMethod.call(it));
};

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
$({
 target: 'URL',
 proto: true,
 enumerable: true
}, {
 toJSON: function toJSON() {
  return URL.prototype.toString.call(this);
 }
});

/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
  true ? factory(exports) : 0;
}(this, function (exports) {
 'use strict';
 var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {
  return "Symbol(" + description + ")";
 };
 function noop() {
 }
 function getGlobals() {
  if (typeof self !== 'undefined') {
   return self;
  } else if (typeof window !== 'undefined') {
   return window;
  } else if (typeof global !== 'undefined') {
   return global;
  }
  return undefined;
 }
 var globals = getGlobals();
 function typeIsObject(x) {
  return typeof x === 'object' && x !== null || typeof x === 'function';
 }
 var rethrowAssertionErrorRejection = noop;
 var originalPromise = Promise;
 var originalPromiseThen = Promise.prototype.then;
 var originalPromiseResolve = Promise.resolve.bind(originalPromise);
 var originalPromiseReject = Promise.reject.bind(originalPromise);
 function newPromise(executor) {
  return new originalPromise(executor);
 }
 function promiseResolvedWith(value) {
  return originalPromiseResolve(value);
 }
 function promiseRejectedWith(reason) {
  return originalPromiseReject(reason);
 }
 function PerformPromiseThen(promise, onFulfilled, onRejected) {
  return originalPromiseThen.call(promise, onFulfilled, onRejected);
 }
 function uponPromise(promise, onFulfilled, onRejected) {
  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
 }
 function uponFulfillment(promise, onFulfilled) {
  uponPromise(promise, onFulfilled);
 }
 function uponRejection(promise, onRejected) {
  uponPromise(promise, undefined, onRejected);
 }
 function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
 }
 function setPromiseIsHandledToTrue(promise) {
  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
 }
 var queueMicrotask = function () {
  var globalQueueMicrotask = globals && globals.queueMicrotask;
  if (typeof globalQueueMicrotask === 'function') {
   return globalQueueMicrotask;
  }
  var resolvedPromise = promiseResolvedWith(undefined);
  return function (fn) {
   return PerformPromiseThen(resolvedPromise, fn);
  };
 }();
 function reflectCall(F, V, args) {
  if (typeof F !== 'function') {
   throw new TypeError('Argument is not a function');
  }
  return Function.prototype.apply.call(F, V, args);
 }
 function promiseCall(F, V, args) {
  try {
   return promiseResolvedWith(reflectCall(F, V, args));
  } catch (value) {
   return promiseRejectedWith(value);
  }
 }
 var QUEUE_MAX_ARRAY_SIZE = 16384;
 var SimpleQueue = function () {
  function SimpleQueue() {
   this._cursor = 0;
   this._size = 0;
   this._front = {
    _elements: [],
    _next: undefined
   };
   this._back = this._front;
   this._cursor = 0;
   this._size = 0;
  }
  Object.defineProperty(SimpleQueue.prototype, "length", {
   get: function () {
    return this._size;
   },
   enumerable: false,
   configurable: true
  });
  SimpleQueue.prototype.push = function (element) {
   var oldBack = this._back;
   var newBack = oldBack;
   if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
    newBack = {
     _elements: [],
     _next: undefined
    };
   }
   oldBack._elements.push(element);
   if (newBack !== oldBack) {
    this._back = newBack;
    oldBack._next = newBack;
   }
   ++this._size;
  };
  SimpleQueue.prototype.shift = function () {
   var oldFront = this._front;
   var newFront = oldFront;
   var oldCursor = this._cursor;
   var newCursor = oldCursor + 1;
   var elements = oldFront._elements;
   var element = elements[oldCursor];
   if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
    newFront = oldFront._next;
    newCursor = 0;
   }
   --this._size;
   this._cursor = newCursor;
   if (oldFront !== newFront) {
    this._front = newFront;
   }
   elements[oldCursor] = undefined;
   return element;
  };
  SimpleQueue.prototype.forEach = function (callback) {
   var i = this._cursor;
   var node = this._front;
   var elements = node._elements;
   while (i !== elements.length || node._next !== undefined) {
    if (i === elements.length) {
     node = node._next;
     elements = node._elements;
     i = 0;
     if (elements.length === 0) {
      break;
     }
    }
    callback(elements[i]);
    ++i;
   }
  };
  SimpleQueue.prototype.peek = function () {
   var front = this._front;
   var cursor = this._cursor;
   return front._elements[cursor];
  };
  return SimpleQueue;
 }();
 function ReadableStreamReaderGenericInitialize(reader, stream) {
  reader._ownerReadableStream = stream;
  stream._reader = reader;
  if (stream._state === 'readable') {
   defaultReaderClosedPromiseInitialize(reader);
  } else if (stream._state === 'closed') {
   defaultReaderClosedPromiseInitializeAsResolved(reader);
  } else {
   defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
  }
 }
 function ReadableStreamReaderGenericCancel(reader, reason) {
  var stream = reader._ownerReadableStream;
  return ReadableStreamCancel(stream, reason);
 }
 function ReadableStreamReaderGenericRelease(reader) {
  if (reader._ownerReadableStream._state === 'readable') {
   defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  } else {
   defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  }
  reader._ownerReadableStream._reader = undefined;
  reader._ownerReadableStream = undefined;
 }
 function readerLockException(name) {
  return new TypeError('Cannot ' + name + ' a stream using a released reader');
 }
 function defaultReaderClosedPromiseInitialize(reader) {
  reader._closedPromise = newPromise(function (resolve, reject) {
   reader._closedPromise_resolve = resolve;
   reader._closedPromise_reject = reject;
  });
 }
 function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseReject(reader, reason);
 }
 function defaultReaderClosedPromiseInitializeAsResolved(reader) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseResolve(reader);
 }
 function defaultReaderClosedPromiseReject(reader, reason) {
  if (reader._closedPromise_reject === undefined) {
   return;
  }
  setPromiseIsHandledToTrue(reader._closedPromise);
  reader._closedPromise_reject(reason);
  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
 }
 function defaultReaderClosedPromiseResetToRejected(reader, reason) {
  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
 }
 function defaultReaderClosedPromiseResolve(reader) {
  if (reader._closedPromise_resolve === undefined) {
   return;
  }
  reader._closedPromise_resolve(undefined);
  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
 }
 var AbortSteps = SymbolPolyfill('[[AbortSteps]]');
 var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
 var CancelSteps = SymbolPolyfill('[[CancelSteps]]');
 var PullSteps = SymbolPolyfill('[[PullSteps]]');
 var NumberIsFinite = Number.isFinite || function (x) {
  return typeof x === 'number' && isFinite(x);
 };
 var MathTrunc = Math.trunc || function (v) {
  return v < 0 ? Math.ceil(v) : Math.floor(v);
 };
 function isDictionary(x) {
  return typeof x === 'object' || typeof x === 'function';
 }
 function assertDictionary(obj, context) {
  if (obj !== undefined && !isDictionary(obj)) {
   throw new TypeError(context + " is not an object.");
  }
 }
 function assertFunction(x, context) {
  if (typeof x !== 'function') {
   throw new TypeError(context + " is not a function.");
  }
 }
 function isObject(x) {
  return typeof x === 'object' && x !== null || typeof x === 'function';
 }
 function assertObject(x, context) {
  if (!isObject(x)) {
   throw new TypeError(context + " is not an object.");
  }
 }
 function assertRequiredArgument(x, position, context) {
  if (x === undefined) {
   throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
  }
 }
 function assertRequiredField(x, field, context) {
  if (x === undefined) {
   throw new TypeError(field + " is required in '" + context + "'.");
  }
 }
 function convertUnrestrictedDouble(value) {
  return Number(value);
 }
 function censorNegativeZero(x) {
  return x === 0 ? 0 : x;
 }
 function integerPart(x) {
  return censorNegativeZero(MathTrunc(x));
 }
 function convertUnsignedLongLongWithEnforceRange(value, context) {
  var lowerBound = 0;
  var upperBound = Number.MAX_SAFE_INTEGER;
  var x = Number(value);
  x = censorNegativeZero(x);
  if (!NumberIsFinite(x)) {
   throw new TypeError(context + " is not a finite number");
  }
  x = integerPart(x);
  if (x < lowerBound || x > upperBound) {
   throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
  }
  if (!NumberIsFinite(x) || x === 0) {
   return 0;
  }
  return x;
 }
 function assertReadableStream(x, context) {
  if (!IsReadableStream(x)) {
   throw new TypeError(context + " is not a ReadableStream.");
  }
 }
 function AcquireReadableStreamDefaultReader(stream) {
  return new ReadableStreamDefaultReader(stream);
 }
 function ReadableStreamAddReadRequest(stream, readRequest) {
  stream._reader._readRequests.push(readRequest);
 }
 function ReadableStreamFulfillReadRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readRequest = reader._readRequests.shift();
  if (done) {
   readRequest._closeSteps();
  } else {
   readRequest._chunkSteps(chunk);
  }
 }
 function ReadableStreamGetNumReadRequests(stream) {
  return stream._reader._readRequests.length;
 }
 function ReadableStreamHasDefaultReader(stream) {
  var reader = stream._reader;
  if (reader === undefined) {
   return false;
  }
  if (!IsReadableStreamDefaultReader(reader)) {
   return false;
  }
  return true;
 }
 var ReadableStreamDefaultReader = function () {
  function ReadableStreamDefaultReader(stream) {
   assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
   assertReadableStream(stream, 'First parameter');
   if (IsReadableStreamLocked(stream)) {
    throw new TypeError('This stream has already been locked for exclusive reading by another reader');
   }
   ReadableStreamReaderGenericInitialize(this, stream);
   this._readRequests = new SimpleQueue();
  }
  Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", {
   get: function () {
    if (!IsReadableStreamDefaultReader(this)) {
     return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
    }
    return this._closedPromise;
   },
   enumerable: false,
   configurable: true
  });
  ReadableStreamDefaultReader.prototype.cancel = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsReadableStreamDefaultReader(this)) {
    return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
   }
   if (this._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('cancel'));
   }
   return ReadableStreamReaderGenericCancel(this, reason);
  };
  ReadableStreamDefaultReader.prototype.read = function () {
   if (!IsReadableStreamDefaultReader(this)) {
    return promiseRejectedWith(defaultReaderBrandCheckException('read'));
   }
   if (this._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('read from'));
   }
   var resolvePromise;
   var rejectPromise;
   var promise = newPromise(function (resolve, reject) {
    resolvePromise = resolve;
    rejectPromise = reject;
   });
   var readRequest = {
    _chunkSteps: function (chunk) {
     return resolvePromise({
      value: chunk,
      done: false
     });
    },
    _closeSteps: function () {
     return resolvePromise({
      value: undefined,
      done: true
     });
    },
    _errorSteps: function (e) {
     return rejectPromise(e);
    }
   };
   ReadableStreamDefaultReaderRead(this, readRequest);
   return promise;
  };
  ReadableStreamDefaultReader.prototype.releaseLock = function () {
   if (!IsReadableStreamDefaultReader(this)) {
    throw defaultReaderBrandCheckException('releaseLock');
   }
   if (this._ownerReadableStream === undefined) {
    return;
   }
   if (this._readRequests.length > 0) {
    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
   }
   ReadableStreamReaderGenericRelease(this);
  };
  return ReadableStreamDefaultReader;
 }();
 Object.defineProperties(ReadableStreamDefaultReader.prototype, {
  cancel: { enumerable: true },
  read: { enumerable: true },
  releaseLock: { enumerable: true },
  closed: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableStreamDefaultReader',
   configurable: true
  });
 }
 function IsReadableStreamDefaultReader(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
   return false;
  }
  return true;
 }
 function ReadableStreamDefaultReaderRead(reader, readRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === 'closed') {
   readRequest._closeSteps();
  } else if (stream._state === 'errored') {
   readRequest._errorSteps(stream._storedError);
  } else {
   stream._readableStreamController[PullSteps](readRequest);
  }
 }
 function defaultReaderBrandCheckException(name) {
  return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
 }
 var _a;
 var AsyncIteratorPrototype;
 if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
  AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function () {
   return this;
  }, _a);
  Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
 }
 var ReadableStreamAsyncIteratorImpl = function () {
  function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {
   this._ongoingPromise = undefined;
   this._isFinished = false;
   this._reader = reader;
   this._preventCancel = preventCancel;
  }
  ReadableStreamAsyncIteratorImpl.prototype.next = function () {
   var _this = this;
   var nextSteps = function () {
    return _this._nextSteps();
   };
   this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
   return this._ongoingPromise;
  };
  ReadableStreamAsyncIteratorImpl.prototype.return = function (value) {
   var _this = this;
   var returnSteps = function () {
    return _this._returnSteps(value);
   };
   return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
  };
  ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function () {
   var _this = this;
   if (this._isFinished) {
    return Promise.resolve({
     value: undefined,
     done: true
    });
   }
   var reader = this._reader;
   if (reader._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('iterate'));
   }
   var resolvePromise;
   var rejectPromise;
   var promise = newPromise(function (resolve, reject) {
    resolvePromise = resolve;
    rejectPromise = reject;
   });
   var readRequest = {
    _chunkSteps: function (chunk) {
     _this._ongoingPromise = undefined;
     queueMicrotask(function () {
      return resolvePromise({
       value: chunk,
       done: false
      });
     });
    },
    _closeSteps: function () {
     _this._ongoingPromise = undefined;
     _this._isFinished = true;
     ReadableStreamReaderGenericRelease(reader);
     resolvePromise({
      value: undefined,
      done: true
     });
    },
    _errorSteps: function (reason) {
     _this._ongoingPromise = undefined;
     _this._isFinished = true;
     ReadableStreamReaderGenericRelease(reader);
     rejectPromise(reason);
    }
   };
   ReadableStreamDefaultReaderRead(reader, readRequest);
   return promise;
  };
  ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function (value) {
   if (this._isFinished) {
    return Promise.resolve({
     value: value,
     done: true
    });
   }
   this._isFinished = true;
   var reader = this._reader;
   if (reader._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('finish iterating'));
   }
   if (!this._preventCancel) {
    var result = ReadableStreamReaderGenericCancel(reader, value);
    ReadableStreamReaderGenericRelease(reader);
    return transformPromiseWith(result, function () {
     return {
      value: value,
      done: true
     };
    });
   }
   ReadableStreamReaderGenericRelease(reader);
   return promiseResolvedWith({
    value: value,
    done: true
   });
  };
  return ReadableStreamAsyncIteratorImpl;
 }();
 var ReadableStreamAsyncIteratorPrototype = {
  next: function () {
   if (!IsReadableStreamAsyncIterator(this)) {
    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
   }
   return this._asyncIteratorImpl.next();
  },
  return: function (value) {
   if (!IsReadableStreamAsyncIterator(this)) {
    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
   }
   return this._asyncIteratorImpl.return(value);
  }
 };
 if (AsyncIteratorPrototype !== undefined) {
  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
 }
 function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
  iterator._asyncIteratorImpl = impl;
  return iterator;
 }
 function IsReadableStreamAsyncIterator(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
   return false;
  }
  return true;
 }
 function streamAsyncIteratorBrandCheckException(name) {
  return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
 }
 var NumberIsNaN = Number.isNaN || function (x) {
  return x !== x;
 };
 function IsFiniteNonNegativeNumber(v) {
  if (!IsNonNegativeNumber(v)) {
   return false;
  }
  if (v === Infinity) {
   return false;
  }
  return true;
 }
 function IsNonNegativeNumber(v) {
  if (typeof v !== 'number') {
   return false;
  }
  if (NumberIsNaN(v)) {
   return false;
  }
  if (v < 0) {
   return false;
  }
  return true;
 }
 function DequeueValue(container) {
  var pair = container._queue.shift();
  container._queueTotalSize -= pair.size;
  if (container._queueTotalSize < 0) {
   container._queueTotalSize = 0;
  }
  return pair.value;
 }
 function EnqueueValueWithSize(container, value, size) {
  size = Number(size);
  if (!IsFiniteNonNegativeNumber(size)) {
   throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
  }
  container._queue.push({
   value: value,
   size: size
  });
  container._queueTotalSize += size;
 }
 function PeekQueueValue(container) {
  var pair = container._queue.peek();
  return pair.value;
 }
 function ResetQueue(container) {
  container._queue = new SimpleQueue();
  container._queueTotalSize = 0;
 }
 function CreateArrayFromList(elements) {
  return elements.slice();
 }
 function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
 }
 function TransferArrayBuffer(O) {
  return O;
 }
 function IsDetachedBuffer(O) {
  return false;
 }
 var ReadableStreamBYOBRequest = function () {
  function ReadableStreamBYOBRequest() {
   throw new TypeError('Illegal constructor');
  }
  Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", {
   get: function () {
    if (!IsReadableStreamBYOBRequest(this)) {
     throw byobRequestBrandCheckException('view');
    }
    return this._view;
   },
   enumerable: false,
   configurable: true
  });
  ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {
   if (!IsReadableStreamBYOBRequest(this)) {
    throw byobRequestBrandCheckException('respond');
   }
   assertRequiredArgument(bytesWritten, 1, 'respond');
   bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
   if (this._associatedReadableByteStreamController === undefined) {
    throw new TypeError('This BYOB request has been invalidated');
   }
   if (IsDetachedBuffer(this._view.buffer));
   ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
  };
  ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {
   if (!IsReadableStreamBYOBRequest(this)) {
    throw byobRequestBrandCheckException('respondWithNewView');
   }
   assertRequiredArgument(view, 1, 'respondWithNewView');
   if (!ArrayBuffer.isView(view)) {
    throw new TypeError('You can only respond with array buffer views');
   }
   if (view.byteLength === 0) {
    throw new TypeError('chunk must have non-zero byteLength');
   }
   if (view.buffer.byteLength === 0) {
    throw new TypeError("chunk's buffer must have non-zero byteLength");
   }
   if (this._associatedReadableByteStreamController === undefined) {
    throw new TypeError('This BYOB request has been invalidated');
   }
   ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
  };
  return ReadableStreamBYOBRequest;
 }();
 Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
  respond: { enumerable: true },
  respondWithNewView: { enumerable: true },
  view: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableStreamBYOBRequest',
   configurable: true
  });
 }
 var ReadableByteStreamController = function () {
  function ReadableByteStreamController() {
   throw new TypeError('Illegal constructor');
  }
  Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", {
   get: function () {
    if (!IsReadableByteStreamController(this)) {
     throw byteStreamControllerBrandCheckException('byobRequest');
    }
    if (this._byobRequest === null && this._pendingPullIntos.length > 0) {
     var firstDescriptor = this._pendingPullIntos.peek();
     var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
     var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
     SetUpReadableStreamBYOBRequest(byobRequest, this, view);
     this._byobRequest = byobRequest;
    }
    return this._byobRequest;
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", {
   get: function () {
    if (!IsReadableByteStreamController(this)) {
     throw byteStreamControllerBrandCheckException('desiredSize');
    }
    return ReadableByteStreamControllerGetDesiredSize(this);
   },
   enumerable: false,
   configurable: true
  });
  ReadableByteStreamController.prototype.close = function () {
   if (!IsReadableByteStreamController(this)) {
    throw byteStreamControllerBrandCheckException('close');
   }
   if (this._closeRequested) {
    throw new TypeError('The stream has already been closed; do not close it again!');
   }
   var state = this._controlledReadableByteStream._state;
   if (state !== 'readable') {
    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
   }
   ReadableByteStreamControllerClose(this);
  };
  ReadableByteStreamController.prototype.enqueue = function (chunk) {
   if (!IsReadableByteStreamController(this)) {
    throw byteStreamControllerBrandCheckException('enqueue');
   }
   assertRequiredArgument(chunk, 1, 'enqueue');
   if (!ArrayBuffer.isView(chunk)) {
    throw new TypeError('chunk must be an array buffer view');
   }
   if (chunk.byteLength === 0) {
    throw new TypeError('chunk must have non-zero byteLength');
   }
   if (chunk.buffer.byteLength === 0) {
    throw new TypeError("chunk's buffer must have non-zero byteLength");
   }
   if (this._closeRequested) {
    throw new TypeError('stream is closed or draining');
   }
   var state = this._controlledReadableByteStream._state;
   if (state !== 'readable') {
    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
   }
   ReadableByteStreamControllerEnqueue(this, chunk);
  };
  ReadableByteStreamController.prototype.error = function (e) {
   if (e === void 0) {
    e = undefined;
   }
   if (!IsReadableByteStreamController(this)) {
    throw byteStreamControllerBrandCheckException('error');
   }
   ReadableByteStreamControllerError(this, e);
  };
  ReadableByteStreamController.prototype[CancelSteps] = function (reason) {
   if (this._pendingPullIntos.length > 0) {
    var firstDescriptor = this._pendingPullIntos.peek();
    firstDescriptor.bytesFilled = 0;
   }
   ResetQueue(this);
   var result = this._cancelAlgorithm(reason);
   ReadableByteStreamControllerClearAlgorithms(this);
   return result;
  };
  ReadableByteStreamController.prototype[PullSteps] = function (readRequest) {
   var stream = this._controlledReadableByteStream;
   if (this._queueTotalSize > 0) {
    var entry = this._queue.shift();
    this._queueTotalSize -= entry.byteLength;
    ReadableByteStreamControllerHandleQueueDrain(this);
    var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
    readRequest._chunkSteps(view);
    return;
   }
   var autoAllocateChunkSize = this._autoAllocateChunkSize;
   if (autoAllocateChunkSize !== undefined) {
    var buffer = void 0;
    try {
     buffer = new ArrayBuffer(autoAllocateChunkSize);
    } catch (bufferE) {
     readRequest._errorSteps(bufferE);
     return;
    }
    var pullIntoDescriptor = {
     buffer: buffer,
     byteOffset: 0,
     byteLength: autoAllocateChunkSize,
     bytesFilled: 0,
     elementSize: 1,
     viewConstructor: Uint8Array,
     readerType: 'default'
    };
    this._pendingPullIntos.push(pullIntoDescriptor);
   }
   ReadableStreamAddReadRequest(stream, readRequest);
   ReadableByteStreamControllerCallPullIfNeeded(this);
  };
  return ReadableByteStreamController;
 }();
 Object.defineProperties(ReadableByteStreamController.prototype, {
  close: { enumerable: true },
  enqueue: { enumerable: true },
  error: { enumerable: true },
  byobRequest: { enumerable: true },
  desiredSize: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableByteStreamController',
   configurable: true
  });
 }
 function IsReadableByteStreamController(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
   return false;
  }
  return true;
 }
 function IsReadableStreamBYOBRequest(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
   return false;
  }
  return true;
 }
 function ReadableByteStreamControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
  if (!shouldPull) {
   return;
  }
  if (controller._pulling) {
   controller._pullAgain = true;
   return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function () {
   controller._pulling = false;
   if (controller._pullAgain) {
    controller._pullAgain = false;
    ReadableByteStreamControllerCallPullIfNeeded(controller);
   }
  }, function (e) {
   ReadableByteStreamControllerError(controller, e);
  });
 }
 function ReadableByteStreamControllerClearPendingPullIntos(controller) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  controller._pendingPullIntos = new SimpleQueue();
 }
 function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
  var done = false;
  if (stream._state === 'closed') {
   done = true;
  }
  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
  if (pullIntoDescriptor.readerType === 'default') {
   ReadableStreamFulfillReadRequest(stream, filledView, done);
  } else {
   ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
  }
 }
 function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
  var bytesFilled = pullIntoDescriptor.bytesFilled;
  var elementSize = pullIntoDescriptor.elementSize;
  return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
 }
 function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
  controller._queue.push({
   buffer: buffer,
   byteOffset: byteOffset,
   byteLength: byteLength
  });
  controller._queueTotalSize += byteLength;
 }
 function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
  var elementSize = pullIntoDescriptor.elementSize;
  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
  var totalBytesToCopyRemaining = maxBytesToCopy;
  var ready = false;
  if (maxAlignedBytes > currentAlignedBytes) {
   totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
   ready = true;
  }
  var queue = controller._queue;
  while (totalBytesToCopyRemaining > 0) {
   var headOfQueue = queue.peek();
   var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
   var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
   CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
   if (headOfQueue.byteLength === bytesToCopy) {
    queue.shift();
   } else {
    headOfQueue.byteOffset += bytesToCopy;
    headOfQueue.byteLength -= bytesToCopy;
   }
   controller._queueTotalSize -= bytesToCopy;
   ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
   totalBytesToCopyRemaining -= bytesToCopy;
  }
  return ready;
 }
 function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  pullIntoDescriptor.bytesFilled += size;
 }
 function ReadableByteStreamControllerHandleQueueDrain(controller) {
  if (controller._queueTotalSize === 0 && controller._closeRequested) {
   ReadableByteStreamControllerClearAlgorithms(controller);
   ReadableStreamClose(controller._controlledReadableByteStream);
  } else {
   ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
 }
 function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
  if (controller._byobRequest === null) {
   return;
  }
  controller._byobRequest._associatedReadableByteStreamController = undefined;
  controller._byobRequest._view = null;
  controller._byobRequest = null;
 }
 function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
  while (controller._pendingPullIntos.length > 0) {
   if (controller._queueTotalSize === 0) {
    return;
   }
   var pullIntoDescriptor = controller._pendingPullIntos.peek();
   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
    ReadableByteStreamControllerShiftPendingPullInto(controller);
    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
   }
  }
 }
 function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
  var stream = controller._controlledReadableByteStream;
  var elementSize = 1;
  if (view.constructor !== DataView) {
   elementSize = view.constructor.BYTES_PER_ELEMENT;
  }
  var ctor = view.constructor;
  var buffer = TransferArrayBuffer(view.buffer);
  var pullIntoDescriptor = {
   buffer: buffer,
   byteOffset: view.byteOffset,
   byteLength: view.byteLength,
   bytesFilled: 0,
   elementSize: elementSize,
   viewConstructor: ctor,
   readerType: 'byob'
  };
  if (controller._pendingPullIntos.length > 0) {
   controller._pendingPullIntos.push(pullIntoDescriptor);
   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
   return;
  }
  if (stream._state === 'closed') {
   var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
   readIntoRequest._closeSteps(emptyView);
   return;
  }
  if (controller._queueTotalSize > 0) {
   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
    ReadableByteStreamControllerHandleQueueDrain(controller);
    readIntoRequest._chunkSteps(filledView);
    return;
   }
   if (controller._closeRequested) {
    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
    ReadableByteStreamControllerError(controller, e);
    readIntoRequest._errorSteps(e);
    return;
   }
  }
  controller._pendingPullIntos.push(pullIntoDescriptor);
  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
  ReadableByteStreamControllerCallPullIfNeeded(controller);
 }
 function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
  var stream = controller._controlledReadableByteStream;
  if (ReadableStreamHasBYOBReader(stream)) {
   while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
   }
  }
 }
 function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
   throw new RangeError('bytesWritten out of range');
  }
  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
   return;
  }
  ReadableByteStreamControllerShiftPendingPullInto(controller);
  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
  if (remainderSize > 0) {
   var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
   var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
   ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
  }
  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
  pullIntoDescriptor.bytesFilled -= remainderSize;
  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
 }
 function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  var state = controller._controlledReadableByteStream._state;
  if (state === 'closed') {
   if (bytesWritten !== 0) {
    throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
   }
   ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
  } else {
   ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
 }
 function ReadableByteStreamControllerShiftPendingPullInto(controller) {
  var descriptor = controller._pendingPullIntos.shift();
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  return descriptor;
 }
 function ReadableByteStreamControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== 'readable') {
   return false;
  }
  if (controller._closeRequested) {
   return false;
  }
  if (!controller._started) {
   return false;
  }
  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
   return true;
  }
  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
   return true;
  }
  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
   return true;
  }
  return false;
 }
 function ReadableByteStreamControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = undefined;
  controller._cancelAlgorithm = undefined;
 }
 function ReadableByteStreamControllerClose(controller) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== 'readable') {
   return;
  }
  if (controller._queueTotalSize > 0) {
   controller._closeRequested = true;
   return;
  }
  if (controller._pendingPullIntos.length > 0) {
   var firstPendingPullInto = controller._pendingPullIntos.peek();
   if (firstPendingPullInto.bytesFilled > 0) {
    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
    ReadableByteStreamControllerError(controller, e);
    throw e;
   }
  }
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamClose(stream);
 }
 function ReadableByteStreamControllerEnqueue(controller, chunk) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== 'readable') {
   return;
  }
  var buffer = chunk.buffer;
  var byteOffset = chunk.byteOffset;
  var byteLength = chunk.byteLength;
  var transferredBuffer = TransferArrayBuffer(buffer);
  if (ReadableStreamHasDefaultReader(stream)) {
   if (ReadableStreamGetNumReadRequests(stream) === 0) {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
   } else {
    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
    ReadableStreamFulfillReadRequest(stream, transferredView, false);
   }
  } else if (ReadableStreamHasBYOBReader(stream)) {
   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
   ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  } else {
   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
 }
 function ReadableByteStreamControllerError(controller, e) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== 'readable') {
   return;
  }
  ReadableByteStreamControllerClearPendingPullIntos(controller);
  ResetQueue(controller);
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
 }
 function ReadableByteStreamControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableByteStream._state;
  if (state === 'errored') {
   return null;
  }
  if (state === 'closed') {
   return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
 }
 function ReadableByteStreamControllerRespond(controller, bytesWritten) {
  bytesWritten = Number(bytesWritten);
  if (!IsFiniteNonNegativeNumber(bytesWritten)) {
   throw new RangeError('bytesWritten must be a finite');
  }
  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
 }
 function ReadableByteStreamControllerRespondWithNewView(controller, view) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
   throw new RangeError('The region specified by view does not match byobRequest');
  }
  if (firstDescriptor.byteLength !== view.byteLength) {
   throw new RangeError('The buffer of view has different capacity than byobRequest');
  }
  firstDescriptor.buffer = view.buffer;
  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
 }
 function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
  controller._controlledReadableByteStream = stream;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._byobRequest = null;
  controller._queue = controller._queueTotalSize = undefined;
  ResetQueue(controller);
  controller._closeRequested = false;
  controller._started = false;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  controller._autoAllocateChunkSize = autoAllocateChunkSize;
  controller._pendingPullIntos = new SimpleQueue();
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function () {
   controller._started = true;
   ReadableByteStreamControllerCallPullIfNeeded(controller);
  }, function (r) {
   ReadableByteStreamControllerError(controller, r);
  });
 }
 function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
  var controller = Object.create(ReadableByteStreamController.prototype);
  var startAlgorithm = function () {
   return undefined;
  };
  var pullAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  var cancelAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  if (underlyingByteSource.start !== undefined) {
   startAlgorithm = function () {
    return underlyingByteSource.start(controller);
   };
  }
  if (underlyingByteSource.pull !== undefined) {
   pullAlgorithm = function () {
    return underlyingByteSource.pull(controller);
   };
  }
  if (underlyingByteSource.cancel !== undefined) {
   cancelAlgorithm = function (reason) {
    return underlyingByteSource.cancel(reason);
   };
  }
  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
 }
 function SetUpReadableStreamBYOBRequest(request, controller, view) {
  request._associatedReadableByteStreamController = controller;
  request._view = view;
 }
 function byobRequestBrandCheckException(name) {
  return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
 }
 function byteStreamControllerBrandCheckException(name) {
  return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
 }
 function AcquireReadableStreamBYOBReader(stream) {
  return new ReadableStreamBYOBReader(stream);
 }
 function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
  stream._reader._readIntoRequests.push(readIntoRequest);
 }
 function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readIntoRequest = reader._readIntoRequests.shift();
  if (done) {
   readIntoRequest._closeSteps(chunk);
  } else {
   readIntoRequest._chunkSteps(chunk);
  }
 }
 function ReadableStreamGetNumReadIntoRequests(stream) {
  return stream._reader._readIntoRequests.length;
 }
 function ReadableStreamHasBYOBReader(stream) {
  var reader = stream._reader;
  if (reader === undefined) {
   return false;
  }
  if (!IsReadableStreamBYOBReader(reader)) {
   return false;
  }
  return true;
 }
 var ReadableStreamBYOBReader = function () {
  function ReadableStreamBYOBReader(stream) {
   assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
   assertReadableStream(stream, 'First parameter');
   if (IsReadableStreamLocked(stream)) {
    throw new TypeError('This stream has already been locked for exclusive reading by another reader');
   }
   if (!IsReadableByteStreamController(stream._readableStreamController)) {
    throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
   }
   ReadableStreamReaderGenericInitialize(this, stream);
   this._readIntoRequests = new SimpleQueue();
  }
  Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", {
   get: function () {
    if (!IsReadableStreamBYOBReader(this)) {
     return promiseRejectedWith(byobReaderBrandCheckException('closed'));
    }
    return this._closedPromise;
   },
   enumerable: false,
   configurable: true
  });
  ReadableStreamBYOBReader.prototype.cancel = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsReadableStreamBYOBReader(this)) {
    return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
   }
   if (this._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('cancel'));
   }
   return ReadableStreamReaderGenericCancel(this, reason);
  };
  ReadableStreamBYOBReader.prototype.read = function (view) {
   if (!IsReadableStreamBYOBReader(this)) {
    return promiseRejectedWith(byobReaderBrandCheckException('read'));
   }
   if (!ArrayBuffer.isView(view)) {
    return promiseRejectedWith(new TypeError('view must be an array buffer view'));
   }
   if (view.byteLength === 0) {
    return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
   }
   if (view.buffer.byteLength === 0) {
    return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
   }
   if (this._ownerReadableStream === undefined) {
    return promiseRejectedWith(readerLockException('read from'));
   }
   var resolvePromise;
   var rejectPromise;
   var promise = newPromise(function (resolve, reject) {
    resolvePromise = resolve;
    rejectPromise = reject;
   });
   var readIntoRequest = {
    _chunkSteps: function (chunk) {
     return resolvePromise({
      value: chunk,
      done: false
     });
    },
    _closeSteps: function (chunk) {
     return resolvePromise({
      value: chunk,
      done: true
     });
    },
    _errorSteps: function (e) {
     return rejectPromise(e);
    }
   };
   ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
   return promise;
  };
  ReadableStreamBYOBReader.prototype.releaseLock = function () {
   if (!IsReadableStreamBYOBReader(this)) {
    throw byobReaderBrandCheckException('releaseLock');
   }
   if (this._ownerReadableStream === undefined) {
    return;
   }
   if (this._readIntoRequests.length > 0) {
    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
   }
   ReadableStreamReaderGenericRelease(this);
  };
  return ReadableStreamBYOBReader;
 }();
 Object.defineProperties(ReadableStreamBYOBReader.prototype, {
  cancel: { enumerable: true },
  read: { enumerable: true },
  releaseLock: { enumerable: true },
  closed: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableStreamBYOBReader',
   configurable: true
  });
 }
 function IsReadableStreamBYOBReader(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
   return false;
  }
  return true;
 }
 function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === 'errored') {
   readIntoRequest._errorSteps(stream._storedError);
  } else {
   ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
  }
 }
 function byobReaderBrandCheckException(name) {
  return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
 }
 function ExtractHighWaterMark(strategy, defaultHWM) {
  var highWaterMark = strategy.highWaterMark;
  if (highWaterMark === undefined) {
   return defaultHWM;
  }
  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
   throw new RangeError('Invalid highWaterMark');
  }
  return highWaterMark;
 }
 function ExtractSizeAlgorithm(strategy) {
  var size = strategy.size;
  if (!size) {
   return function () {
    return 1;
   };
  }
  return size;
 }
 function convertQueuingStrategy(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  var size = init === null || init === void 0 ? void 0 : init.size;
  return {
   highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
   size: size === undefined ? undefined : convertQueuingStrategySize(size, context + " has member 'size' that")
  };
 }
 function convertQueuingStrategySize(fn, context) {
  assertFunction(fn, context);
  return function (chunk) {
   return convertUnrestrictedDouble(fn(chunk));
  };
 }
 function convertUnderlyingSink(original, context) {
  assertDictionary(original, context);
  var abort = original === null || original === void 0 ? void 0 : original.abort;
  var close = original === null || original === void 0 ? void 0 : original.close;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  var write = original === null || original === void 0 ? void 0 : original.write;
  return {
   abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
   close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
   start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
   write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
   type: type
  };
 }
 function convertUnderlyingSinkAbortCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (reason) {
   return promiseCall(fn, original, [reason]);
  };
 }
 function convertUnderlyingSinkCloseCallback(fn, original, context) {
  assertFunction(fn, context);
  return function () {
   return promiseCall(fn, original, []);
  };
 }
 function convertUnderlyingSinkStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (controller) {
   return reflectCall(fn, original, [controller]);
  };
 }
 function convertUnderlyingSinkWriteCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (chunk, controller) {
   return promiseCall(fn, original, [
    chunk,
    controller
   ]);
  };
 }
 function assertWritableStream(x, context) {
  if (!IsWritableStream(x)) {
   throw new TypeError(context + " is not a WritableStream.");
  }
 }
 var WritableStream = function () {
  function WritableStream(rawUnderlyingSink, rawStrategy) {
   if (rawUnderlyingSink === void 0) {
    rawUnderlyingSink = {};
   }
   if (rawStrategy === void 0) {
    rawStrategy = {};
   }
   if (rawUnderlyingSink === undefined) {
    rawUnderlyingSink = null;
   } else {
    assertObject(rawUnderlyingSink, 'First parameter');
   }
   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
   var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
   InitializeWritableStream(this);
   var type = underlyingSink.type;
   if (type !== undefined) {
    throw new RangeError('Invalid type is specified');
   }
   var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
   var highWaterMark = ExtractHighWaterMark(strategy, 1);
   SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
  }
  Object.defineProperty(WritableStream.prototype, "locked", {
   get: function () {
    if (!IsWritableStream(this)) {
     throw streamBrandCheckException('locked');
    }
    return IsWritableStreamLocked(this);
   },
   enumerable: false,
   configurable: true
  });
  WritableStream.prototype.abort = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsWritableStream(this)) {
    return promiseRejectedWith(streamBrandCheckException('abort'));
   }
   if (IsWritableStreamLocked(this)) {
    return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
   }
   return WritableStreamAbort(this, reason);
  };
  WritableStream.prototype.close = function () {
   if (!IsWritableStream(this)) {
    return promiseRejectedWith(streamBrandCheckException('close'));
   }
   if (IsWritableStreamLocked(this)) {
    return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
   }
   if (WritableStreamCloseQueuedOrInFlight(this)) {
    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
   }
   return WritableStreamClose(this);
  };
  WritableStream.prototype.getWriter = function () {
   if (!IsWritableStream(this)) {
    throw streamBrandCheckException('getWriter');
   }
   return AcquireWritableStreamDefaultWriter(this);
  };
  return WritableStream;
 }();
 Object.defineProperties(WritableStream.prototype, {
  abort: { enumerable: true },
  close: { enumerable: true },
  getWriter: { enumerable: true },
  locked: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
   value: 'WritableStream',
   configurable: true
  });
 }
 function AcquireWritableStreamDefaultWriter(stream) {
  return new WritableStreamDefaultWriter(stream);
 }
 function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
   highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
   sizeAlgorithm = function () {
    return 1;
   };
  }
  var stream = Object.create(WritableStream.prototype);
  InitializeWritableStream(stream);
  var controller = Object.create(WritableStreamDefaultController.prototype);
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
 }
 function InitializeWritableStream(stream) {
  stream._state = 'writable';
  stream._storedError = undefined;
  stream._writer = undefined;
  stream._writableStreamController = undefined;
  stream._writeRequests = new SimpleQueue();
  stream._inFlightWriteRequest = undefined;
  stream._closeRequest = undefined;
  stream._inFlightCloseRequest = undefined;
  stream._pendingAbortRequest = undefined;
  stream._backpressure = false;
 }
 function IsWritableStream(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
   return false;
  }
  return true;
 }
 function IsWritableStreamLocked(stream) {
  if (stream._writer === undefined) {
   return false;
  }
  return true;
 }
 function WritableStreamAbort(stream, reason) {
  var state = stream._state;
  if (state === 'closed' || state === 'errored') {
   return promiseResolvedWith(undefined);
  }
  if (stream._pendingAbortRequest !== undefined) {
   return stream._pendingAbortRequest._promise;
  }
  var wasAlreadyErroring = false;
  if (state === 'erroring') {
   wasAlreadyErroring = true;
   reason = undefined;
  }
  var promise = newPromise(function (resolve, reject) {
   stream._pendingAbortRequest = {
    _promise: undefined,
    _resolve: resolve,
    _reject: reject,
    _reason: reason,
    _wasAlreadyErroring: wasAlreadyErroring
   };
  });
  stream._pendingAbortRequest._promise = promise;
  if (!wasAlreadyErroring) {
   WritableStreamStartErroring(stream, reason);
  }
  return promise;
 }
 function WritableStreamClose(stream) {
  var state = stream._state;
  if (state === 'closed' || state === 'errored') {
   return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
  }
  var promise = newPromise(function (resolve, reject) {
   var closeRequest = {
    _resolve: resolve,
    _reject: reject
   };
   stream._closeRequest = closeRequest;
  });
  var writer = stream._writer;
  if (writer !== undefined && stream._backpressure && state === 'writable') {
   defaultWriterReadyPromiseResolve(writer);
  }
  WritableStreamDefaultControllerClose(stream._writableStreamController);
  return promise;
 }
 function WritableStreamAddWriteRequest(stream) {
  var promise = newPromise(function (resolve, reject) {
   var writeRequest = {
    _resolve: resolve,
    _reject: reject
   };
   stream._writeRequests.push(writeRequest);
  });
  return promise;
 }
 function WritableStreamDealWithRejection(stream, error) {
  var state = stream._state;
  if (state === 'writable') {
   WritableStreamStartErroring(stream, error);
   return;
  }
  WritableStreamFinishErroring(stream);
 }
 function WritableStreamStartErroring(stream, reason) {
  var controller = stream._writableStreamController;
  stream._state = 'erroring';
  stream._storedError = reason;
  var writer = stream._writer;
  if (writer !== undefined) {
   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
  }
  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
   WritableStreamFinishErroring(stream);
  }
 }
 function WritableStreamFinishErroring(stream) {
  stream._state = 'errored';
  stream._writableStreamController[ErrorSteps]();
  var storedError = stream._storedError;
  stream._writeRequests.forEach(function (writeRequest) {
   writeRequest._reject(storedError);
  });
  stream._writeRequests = new SimpleQueue();
  if (stream._pendingAbortRequest === undefined) {
   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
   return;
  }
  var abortRequest = stream._pendingAbortRequest;
  stream._pendingAbortRequest = undefined;
  if (abortRequest._wasAlreadyErroring) {
   abortRequest._reject(storedError);
   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
   return;
  }
  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
  uponPromise(promise, function () {
   abortRequest._resolve();
   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  }, function (reason) {
   abortRequest._reject(reason);
   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  });
 }
 function WritableStreamFinishInFlightWrite(stream) {
  stream._inFlightWriteRequest._resolve(undefined);
  stream._inFlightWriteRequest = undefined;
 }
 function WritableStreamFinishInFlightWriteWithError(stream, error) {
  stream._inFlightWriteRequest._reject(error);
  stream._inFlightWriteRequest = undefined;
  WritableStreamDealWithRejection(stream, error);
 }
 function WritableStreamFinishInFlightClose(stream) {
  stream._inFlightCloseRequest._resolve(undefined);
  stream._inFlightCloseRequest = undefined;
  var state = stream._state;
  if (state === 'erroring') {
   stream._storedError = undefined;
   if (stream._pendingAbortRequest !== undefined) {
    stream._pendingAbortRequest._resolve();
    stream._pendingAbortRequest = undefined;
   }
  }
  stream._state = 'closed';
  var writer = stream._writer;
  if (writer !== undefined) {
   defaultWriterClosedPromiseResolve(writer);
  }
 }
 function WritableStreamFinishInFlightCloseWithError(stream, error) {
  stream._inFlightCloseRequest._reject(error);
  stream._inFlightCloseRequest = undefined;
  if (stream._pendingAbortRequest !== undefined) {
   stream._pendingAbortRequest._reject(error);
   stream._pendingAbortRequest = undefined;
  }
  WritableStreamDealWithRejection(stream, error);
 }
 function WritableStreamCloseQueuedOrInFlight(stream) {
  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
   return false;
  }
  return true;
 }
 function WritableStreamHasOperationMarkedInFlight(stream) {
  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
   return false;
  }
  return true;
 }
 function WritableStreamMarkCloseRequestInFlight(stream) {
  stream._inFlightCloseRequest = stream._closeRequest;
  stream._closeRequest = undefined;
 }
 function WritableStreamMarkFirstWriteRequestInFlight(stream) {
  stream._inFlightWriteRequest = stream._writeRequests.shift();
 }
 function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
  if (stream._closeRequest !== undefined) {
   stream._closeRequest._reject(stream._storedError);
   stream._closeRequest = undefined;
  }
  var writer = stream._writer;
  if (writer !== undefined) {
   defaultWriterClosedPromiseReject(writer, stream._storedError);
  }
 }
 function WritableStreamUpdateBackpressure(stream, backpressure) {
  var writer = stream._writer;
  if (writer !== undefined && backpressure !== stream._backpressure) {
   if (backpressure) {
    defaultWriterReadyPromiseReset(writer);
   } else {
    defaultWriterReadyPromiseResolve(writer);
   }
  }
  stream._backpressure = backpressure;
 }
 var WritableStreamDefaultWriter = function () {
  function WritableStreamDefaultWriter(stream) {
   assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
   assertWritableStream(stream, 'First parameter');
   if (IsWritableStreamLocked(stream)) {
    throw new TypeError('This stream has already been locked for exclusive writing by another writer');
   }
   this._ownerWritableStream = stream;
   stream._writer = this;
   var state = stream._state;
   if (state === 'writable') {
    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
     defaultWriterReadyPromiseInitialize(this);
    } else {
     defaultWriterReadyPromiseInitializeAsResolved(this);
    }
    defaultWriterClosedPromiseInitialize(this);
   } else if (state === 'erroring') {
    defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
    defaultWriterClosedPromiseInitialize(this);
   } else if (state === 'closed') {
    defaultWriterReadyPromiseInitializeAsResolved(this);
    defaultWriterClosedPromiseInitializeAsResolved(this);
   } else {
    var storedError = stream._storedError;
    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
   }
  }
  Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", {
   get: function () {
    if (!IsWritableStreamDefaultWriter(this)) {
     return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
    }
    return this._closedPromise;
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", {
   get: function () {
    if (!IsWritableStreamDefaultWriter(this)) {
     throw defaultWriterBrandCheckException('desiredSize');
    }
    if (this._ownerWritableStream === undefined) {
     throw defaultWriterLockException('desiredSize');
    }
    return WritableStreamDefaultWriterGetDesiredSize(this);
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", {
   get: function () {
    if (!IsWritableStreamDefaultWriter(this)) {
     return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
    }
    return this._readyPromise;
   },
   enumerable: false,
   configurable: true
  });
  WritableStreamDefaultWriter.prototype.abort = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsWritableStreamDefaultWriter(this)) {
    return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
   }
   if (this._ownerWritableStream === undefined) {
    return promiseRejectedWith(defaultWriterLockException('abort'));
   }
   return WritableStreamDefaultWriterAbort(this, reason);
  };
  WritableStreamDefaultWriter.prototype.close = function () {
   if (!IsWritableStreamDefaultWriter(this)) {
    return promiseRejectedWith(defaultWriterBrandCheckException('close'));
   }
   var stream = this._ownerWritableStream;
   if (stream === undefined) {
    return promiseRejectedWith(defaultWriterLockException('close'));
   }
   if (WritableStreamCloseQueuedOrInFlight(stream)) {
    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
   }
   return WritableStreamDefaultWriterClose(this);
  };
  WritableStreamDefaultWriter.prototype.releaseLock = function () {
   if (!IsWritableStreamDefaultWriter(this)) {
    throw defaultWriterBrandCheckException('releaseLock');
   }
   var stream = this._ownerWritableStream;
   if (stream === undefined) {
    return;
   }
   WritableStreamDefaultWriterRelease(this);
  };
  WritableStreamDefaultWriter.prototype.write = function (chunk) {
   if (chunk === void 0) {
    chunk = undefined;
   }
   if (!IsWritableStreamDefaultWriter(this)) {
    return promiseRejectedWith(defaultWriterBrandCheckException('write'));
   }
   if (this._ownerWritableStream === undefined) {
    return promiseRejectedWith(defaultWriterLockException('write to'));
   }
   return WritableStreamDefaultWriterWrite(this, chunk);
  };
  return WritableStreamDefaultWriter;
 }();
 Object.defineProperties(WritableStreamDefaultWriter.prototype, {
  abort: { enumerable: true },
  close: { enumerable: true },
  releaseLock: { enumerable: true },
  write: { enumerable: true },
  closed: { enumerable: true },
  desiredSize: { enumerable: true },
  ready: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
   value: 'WritableStreamDefaultWriter',
   configurable: true
  });
 }
 function IsWritableStreamDefaultWriter(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
   return false;
  }
  return true;
 }
 function WritableStreamDefaultWriterAbort(writer, reason) {
  var stream = writer._ownerWritableStream;
  return WritableStreamAbort(stream, reason);
 }
 function WritableStreamDefaultWriterClose(writer) {
  var stream = writer._ownerWritableStream;
  return WritableStreamClose(stream);
 }
 function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
   return promiseResolvedWith(undefined);
  }
  if (state === 'errored') {
   return promiseRejectedWith(stream._storedError);
  }
  return WritableStreamDefaultWriterClose(writer);
 }
 function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
  if (writer._closedPromiseState === 'pending') {
   defaultWriterClosedPromiseReject(writer, error);
  } else {
   defaultWriterClosedPromiseResetToRejected(writer, error);
  }
 }
 function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
  if (writer._readyPromiseState === 'pending') {
   defaultWriterReadyPromiseReject(writer, error);
  } else {
   defaultWriterReadyPromiseResetToRejected(writer, error);
  }
 }
 function WritableStreamDefaultWriterGetDesiredSize(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (state === 'errored' || state === 'erroring') {
   return null;
  }
  if (state === 'closed') {
   return 0;
  }
  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
 }
 function WritableStreamDefaultWriterRelease(writer) {
  var stream = writer._ownerWritableStream;
  var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
  stream._writer = undefined;
  writer._ownerWritableStream = undefined;
 }
 function WritableStreamDefaultWriterWrite(writer, chunk) {
  var stream = writer._ownerWritableStream;
  var controller = stream._writableStreamController;
  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
  if (stream !== writer._ownerWritableStream) {
   return promiseRejectedWith(defaultWriterLockException('write to'));
  }
  var state = stream._state;
  if (state === 'errored') {
   return promiseRejectedWith(stream._storedError);
  }
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
   return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
  }
  if (state === 'erroring') {
   return promiseRejectedWith(stream._storedError);
  }
  var promise = WritableStreamAddWriteRequest(stream);
  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
  return promise;
 }
 var closeSentinel = {};
 var WritableStreamDefaultController = function () {
  function WritableStreamDefaultController() {
   throw new TypeError('Illegal constructor');
  }
  WritableStreamDefaultController.prototype.error = function (e) {
   if (e === void 0) {
    e = undefined;
   }
   if (!IsWritableStreamDefaultController(this)) {
    throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');
   }
   var state = this._controlledWritableStream._state;
   if (state !== 'writable') {
    return;
   }
   WritableStreamDefaultControllerError(this, e);
  };
  WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {
   var result = this._abortAlgorithm(reason);
   WritableStreamDefaultControllerClearAlgorithms(this);
   return result;
  };
  WritableStreamDefaultController.prototype[ErrorSteps] = function () {
   ResetQueue(this);
  };
  return WritableStreamDefaultController;
 }();
 Object.defineProperties(WritableStreamDefaultController.prototype, { error: { enumerable: true } });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
   value: 'WritableStreamDefaultController',
   configurable: true
  });
 }
 function IsWritableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
   return false;
  }
  return true;
 }
 function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledWritableStream = stream;
  stream._writableStreamController = controller;
  controller._queue = undefined;
  controller._queueTotalSize = undefined;
  ResetQueue(controller);
  controller._started = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._writeAlgorithm = writeAlgorithm;
  controller._closeAlgorithm = closeAlgorithm;
  controller._abortAlgorithm = abortAlgorithm;
  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  WritableStreamUpdateBackpressure(stream, backpressure);
  var startResult = startAlgorithm();
  var startPromise = promiseResolvedWith(startResult);
  uponPromise(startPromise, function () {
   controller._started = true;
   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function (r) {
   controller._started = true;
   WritableStreamDealWithRejection(stream, r);
  });
 }
 function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(WritableStreamDefaultController.prototype);
  var startAlgorithm = function () {
   return undefined;
  };
  var writeAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  var closeAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  var abortAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  if (underlyingSink.start !== undefined) {
   startAlgorithm = function () {
    return underlyingSink.start(controller);
   };
  }
  if (underlyingSink.write !== undefined) {
   writeAlgorithm = function (chunk) {
    return underlyingSink.write(chunk, controller);
   };
  }
  if (underlyingSink.close !== undefined) {
   closeAlgorithm = function () {
    return underlyingSink.close();
   };
  }
  if (underlyingSink.abort !== undefined) {
   abortAlgorithm = function (reason) {
    return underlyingSink.abort(reason);
   };
  }
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
 }
 function WritableStreamDefaultControllerClearAlgorithms(controller) {
  controller._writeAlgorithm = undefined;
  controller._closeAlgorithm = undefined;
  controller._abortAlgorithm = undefined;
  controller._strategySizeAlgorithm = undefined;
 }
 function WritableStreamDefaultControllerClose(controller) {
  EnqueueValueWithSize(controller, closeSentinel, 0);
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
 }
 function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
  try {
   return controller._strategySizeAlgorithm(chunk);
  } catch (chunkSizeE) {
   WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
   return 1;
  }
 }
 function WritableStreamDefaultControllerGetDesiredSize(controller) {
  return controller._strategyHWM - controller._queueTotalSize;
 }
 function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
  try {
   EnqueueValueWithSize(controller, chunk, chunkSize);
  } catch (enqueueE) {
   WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
   return;
  }
  var stream = controller._controlledWritableStream;
  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
   var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
   WritableStreamUpdateBackpressure(stream, backpressure);
  }
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
 }
 function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
  var stream = controller._controlledWritableStream;
  if (!controller._started) {
   return;
  }
  if (stream._inFlightWriteRequest !== undefined) {
   return;
  }
  var state = stream._state;
  if (state === 'erroring') {
   WritableStreamFinishErroring(stream);
   return;
  }
  if (controller._queue.length === 0) {
   return;
  }
  var value = PeekQueueValue(controller);
  if (value === closeSentinel) {
   WritableStreamDefaultControllerProcessClose(controller);
  } else {
   WritableStreamDefaultControllerProcessWrite(controller, value);
  }
 }
 function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
  if (controller._controlledWritableStream._state === 'writable') {
   WritableStreamDefaultControllerError(controller, error);
  }
 }
 function WritableStreamDefaultControllerProcessClose(controller) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkCloseRequestInFlight(stream);
  DequeueValue(controller);
  var sinkClosePromise = controller._closeAlgorithm();
  WritableStreamDefaultControllerClearAlgorithms(controller);
  uponPromise(sinkClosePromise, function () {
   WritableStreamFinishInFlightClose(stream);
  }, function (reason) {
   WritableStreamFinishInFlightCloseWithError(stream, reason);
  });
 }
 function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkFirstWriteRequestInFlight(stream);
  var sinkWritePromise = controller._writeAlgorithm(chunk);
  uponPromise(sinkWritePromise, function () {
   WritableStreamFinishInFlightWrite(stream);
   var state = stream._state;
   DequeueValue(controller);
   if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
   }
   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function (reason) {
   if (stream._state === 'writable') {
    WritableStreamDefaultControllerClearAlgorithms(controller);
   }
   WritableStreamFinishInFlightWriteWithError(stream, reason);
  });
 }
 function WritableStreamDefaultControllerGetBackpressure(controller) {
  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
  return desiredSize <= 0;
 }
 function WritableStreamDefaultControllerError(controller, error) {
  var stream = controller._controlledWritableStream;
  WritableStreamDefaultControllerClearAlgorithms(controller);
  WritableStreamStartErroring(stream, error);
 }
 function streamBrandCheckException(name) {
  return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
 }
 function defaultWriterBrandCheckException(name) {
  return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
 }
 function defaultWriterLockException(name) {
  return new TypeError('Cannot ' + name + ' a stream using a released writer');
 }
 function defaultWriterClosedPromiseInitialize(writer) {
  writer._closedPromise = newPromise(function (resolve, reject) {
   writer._closedPromise_resolve = resolve;
   writer._closedPromise_reject = reject;
   writer._closedPromiseState = 'pending';
  });
 }
 function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseReject(writer, reason);
 }
 function defaultWriterClosedPromiseInitializeAsResolved(writer) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseResolve(writer);
 }
 function defaultWriterClosedPromiseReject(writer, reason) {
  if (writer._closedPromise_reject === undefined) {
   return;
  }
  setPromiseIsHandledToTrue(writer._closedPromise);
  writer._closedPromise_reject(reason);
  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'rejected';
 }
 function defaultWriterClosedPromiseResetToRejected(writer, reason) {
  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
 }
 function defaultWriterClosedPromiseResolve(writer) {
  if (writer._closedPromise_resolve === undefined) {
   return;
  }
  writer._closedPromise_resolve(undefined);
  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'resolved';
 }
 function defaultWriterReadyPromiseInitialize(writer) {
  writer._readyPromise = newPromise(function (resolve, reject) {
   writer._readyPromise_resolve = resolve;
   writer._readyPromise_reject = reject;
  });
  writer._readyPromiseState = 'pending';
 }
 function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseReject(writer, reason);
 }
 function defaultWriterReadyPromiseInitializeAsResolved(writer) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseResolve(writer);
 }
 function defaultWriterReadyPromiseReject(writer, reason) {
  if (writer._readyPromise_reject === undefined) {
   return;
  }
  setPromiseIsHandledToTrue(writer._readyPromise);
  writer._readyPromise_reject(reason);
  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'rejected';
 }
 function defaultWriterReadyPromiseReset(writer) {
  defaultWriterReadyPromiseInitialize(writer);
 }
 function defaultWriterReadyPromiseResetToRejected(writer, reason) {
  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
 }
 function defaultWriterReadyPromiseResolve(writer) {
  if (writer._readyPromise_resolve === undefined) {
   return;
  }
  writer._readyPromise_resolve(undefined);
  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'fulfilled';
 }
 function isAbortSignal(value) {
  if (typeof value !== 'object' || value === null) {
   return false;
  }
  try {
   return typeof value.aborted === 'boolean';
  } catch (_a) {
   return false;
  }
 }
 var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;
 function isDOMExceptionConstructor(ctor) {
  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
   return false;
  }
  try {
   new ctor();
   return true;
  } catch (_a) {
   return false;
  }
 }
 function createDOMExceptionPolyfill() {
  var ctor = function DOMException(message, name) {
   this.message = message || '';
   this.name = name || 'Error';
   if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
   }
  };
  ctor.prototype = Object.create(Error.prototype);
  Object.defineProperty(ctor.prototype, 'constructor', {
   value: ctor,
   writable: true,
   configurable: true
  });
  return ctor;
 }
 var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
 function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
  var reader = AcquireReadableStreamDefaultReader(source);
  var writer = AcquireWritableStreamDefaultWriter(dest);
  source._disturbed = true;
  var shuttingDown = false;
  var currentWrite = promiseResolvedWith(undefined);
  return newPromise(function (resolve, reject) {
   var abortAlgorithm;
   if (signal !== undefined) {
    abortAlgorithm = function () {
     var error = new DOMException$1('Aborted', 'AbortError');
     var actions = [];
     if (!preventAbort) {
      actions.push(function () {
       if (dest._state === 'writable') {
        return WritableStreamAbort(dest, error);
       }
       return promiseResolvedWith(undefined);
      });
     }
     if (!preventCancel) {
      actions.push(function () {
       if (source._state === 'readable') {
        return ReadableStreamCancel(source, error);
       }
       return promiseResolvedWith(undefined);
      });
     }
     shutdownWithAction(function () {
      return Promise.all(actions.map(function (action) {
       return action();
      }));
     }, true, error);
    };
    if (signal.aborted) {
     abortAlgorithm();
     return;
    }
    signal.addEventListener('abort', abortAlgorithm);
   }
   function pipeLoop() {
    return newPromise(function (resolveLoop, rejectLoop) {
     function next(done) {
      if (done) {
       resolveLoop();
      } else {
       PerformPromiseThen(pipeStep(), next, rejectLoop);
      }
     }
     next(false);
    });
   }
   function pipeStep() {
    if (shuttingDown) {
     return promiseResolvedWith(true);
    }
    return PerformPromiseThen(writer._readyPromise, function () {
     return newPromise(function (resolveRead, rejectRead) {
      ReadableStreamDefaultReaderRead(reader, {
       _chunkSteps: function (chunk) {
        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
        resolveRead(false);
       },
       _closeSteps: function () {
        return resolveRead(true);
       },
       _errorSteps: rejectRead
      });
     });
    });
   }
   isOrBecomesErrored(source, reader._closedPromise, function (storedError) {
    if (!preventAbort) {
     shutdownWithAction(function () {
      return WritableStreamAbort(dest, storedError);
     }, true, storedError);
    } else {
     shutdown(true, storedError);
    }
   });
   isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
    if (!preventCancel) {
     shutdownWithAction(function () {
      return ReadableStreamCancel(source, storedError);
     }, true, storedError);
    } else {
     shutdown(true, storedError);
    }
   });
   isOrBecomesClosed(source, reader._closedPromise, function () {
    if (!preventClose) {
     shutdownWithAction(function () {
      return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
     });
    } else {
     shutdown();
    }
   });
   if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
    var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');
    if (!preventCancel) {
     shutdownWithAction(function () {
      return ReadableStreamCancel(source, destClosed_1);
     }, true, destClosed_1);
    } else {
     shutdown(true, destClosed_1);
    }
   }
   setPromiseIsHandledToTrue(pipeLoop());
   function waitForWritesToFinish() {
    var oldCurrentWrite = currentWrite;
    return PerformPromiseThen(currentWrite, function () {
     return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
    });
   }
   function isOrBecomesErrored(stream, promise, action) {
    if (stream._state === 'errored') {
     action(stream._storedError);
    } else {
     uponRejection(promise, action);
    }
   }
   function isOrBecomesClosed(stream, promise, action) {
    if (stream._state === 'closed') {
     action();
    } else {
     uponFulfillment(promise, action);
    }
   }
   function shutdownWithAction(action, originalIsError, originalError) {
    if (shuttingDown) {
     return;
    }
    shuttingDown = true;
    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
     uponFulfillment(waitForWritesToFinish(), doTheRest);
    } else {
     doTheRest();
    }
    function doTheRest() {
     uponPromise(action(), function () {
      return finalize(originalIsError, originalError);
     }, function (newError) {
      return finalize(true, newError);
     });
    }
   }
   function shutdown(isError, error) {
    if (shuttingDown) {
     return;
    }
    shuttingDown = true;
    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
     uponFulfillment(waitForWritesToFinish(), function () {
      return finalize(isError, error);
     });
    } else {
     finalize(isError, error);
    }
   }
   function finalize(isError, error) {
    WritableStreamDefaultWriterRelease(writer);
    ReadableStreamReaderGenericRelease(reader);
    if (signal !== undefined) {
     signal.removeEventListener('abort', abortAlgorithm);
    }
    if (isError) {
     reject(error);
    } else {
     resolve(undefined);
    }
   }
  });
 }
 var ReadableStreamDefaultController = function () {
  function ReadableStreamDefaultController() {
   throw new TypeError('Illegal constructor');
  }
  Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", {
   get: function () {
    if (!IsReadableStreamDefaultController(this)) {
     throw defaultControllerBrandCheckException('desiredSize');
    }
    return ReadableStreamDefaultControllerGetDesiredSize(this);
   },
   enumerable: false,
   configurable: true
  });
  ReadableStreamDefaultController.prototype.close = function () {
   if (!IsReadableStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException('close');
   }
   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
    throw new TypeError('The stream is not in a state that permits close');
   }
   ReadableStreamDefaultControllerClose(this);
  };
  ReadableStreamDefaultController.prototype.enqueue = function (chunk) {
   if (chunk === void 0) {
    chunk = undefined;
   }
   if (!IsReadableStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException('enqueue');
   }
   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
    throw new TypeError('The stream is not in a state that permits enqueue');
   }
   return ReadableStreamDefaultControllerEnqueue(this, chunk);
  };
  ReadableStreamDefaultController.prototype.error = function (e) {
   if (e === void 0) {
    e = undefined;
   }
   if (!IsReadableStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException('error');
   }
   ReadableStreamDefaultControllerError(this, e);
  };
  ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {
   ResetQueue(this);
   var result = this._cancelAlgorithm(reason);
   ReadableStreamDefaultControllerClearAlgorithms(this);
   return result;
  };
  ReadableStreamDefaultController.prototype[PullSteps] = function (readRequest) {
   var stream = this._controlledReadableStream;
   if (this._queue.length > 0) {
    var chunk = DequeueValue(this);
    if (this._closeRequested && this._queue.length === 0) {
     ReadableStreamDefaultControllerClearAlgorithms(this);
     ReadableStreamClose(stream);
    } else {
     ReadableStreamDefaultControllerCallPullIfNeeded(this);
    }
    readRequest._chunkSteps(chunk);
   } else {
    ReadableStreamAddReadRequest(stream, readRequest);
    ReadableStreamDefaultControllerCallPullIfNeeded(this);
   }
  };
  return ReadableStreamDefaultController;
 }();
 Object.defineProperties(ReadableStreamDefaultController.prototype, {
  close: { enumerable: true },
  enqueue: { enumerable: true },
  error: { enumerable: true },
  desiredSize: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableStreamDefaultController',
   configurable: true
  });
 }
 function IsReadableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
   return false;
  }
  return true;
 }
 function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
  if (!shouldPull) {
   return;
  }
  if (controller._pulling) {
   controller._pullAgain = true;
   return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function () {
   controller._pulling = false;
   if (controller._pullAgain) {
    controller._pullAgain = false;
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
   }
  }, function (e) {
   ReadableStreamDefaultControllerError(controller, e);
  });
 }
 function ReadableStreamDefaultControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableStream;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
   return false;
  }
  if (!controller._started) {
   return false;
  }
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
   return true;
  }
  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
   return true;
  }
  return false;
 }
 function ReadableStreamDefaultControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = undefined;
  controller._cancelAlgorithm = undefined;
  controller._strategySizeAlgorithm = undefined;
 }
 function ReadableStreamDefaultControllerClose(controller) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
   return;
  }
  var stream = controller._controlledReadableStream;
  controller._closeRequested = true;
  if (controller._queue.length === 0) {
   ReadableStreamDefaultControllerClearAlgorithms(controller);
   ReadableStreamClose(stream);
  }
 }
 function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
   return;
  }
  var stream = controller._controlledReadableStream;
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
   ReadableStreamFulfillReadRequest(stream, chunk, false);
  } else {
   var chunkSize = void 0;
   try {
    chunkSize = controller._strategySizeAlgorithm(chunk);
   } catch (chunkSizeE) {
    ReadableStreamDefaultControllerError(controller, chunkSizeE);
    throw chunkSizeE;
   }
   try {
    EnqueueValueWithSize(controller, chunk, chunkSize);
   } catch (enqueueE) {
    ReadableStreamDefaultControllerError(controller, enqueueE);
    throw enqueueE;
   }
  }
  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
 }
 function ReadableStreamDefaultControllerError(controller, e) {
  var stream = controller._controlledReadableStream;
  if (stream._state !== 'readable') {
   return;
  }
  ResetQueue(controller);
  ReadableStreamDefaultControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
 }
 function ReadableStreamDefaultControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableStream._state;
  if (state === 'errored') {
   return null;
  }
  if (state === 'closed') {
   return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
 }
 function ReadableStreamDefaultControllerHasBackpressure(controller) {
  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
   return false;
  }
  return true;
 }
 function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
  var state = controller._controlledReadableStream._state;
  if (!controller._closeRequested && state === 'readable') {
   return true;
  }
  return false;
 }
 function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledReadableStream = stream;
  controller._queue = undefined;
  controller._queueTotalSize = undefined;
  ResetQueue(controller);
  controller._started = false;
  controller._closeRequested = false;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function () {
   controller._started = true;
   ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }, function (r) {
   ReadableStreamDefaultControllerError(controller, r);
  });
 }
 function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  var startAlgorithm = function () {
   return undefined;
  };
  var pullAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  var cancelAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  if (underlyingSource.start !== undefined) {
   startAlgorithm = function () {
    return underlyingSource.start(controller);
   };
  }
  if (underlyingSource.pull !== undefined) {
   pullAlgorithm = function () {
    return underlyingSource.pull(controller);
   };
  }
  if (underlyingSource.cancel !== undefined) {
   cancelAlgorithm = function (reason) {
    return underlyingSource.cancel(reason);
   };
  }
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
 }
 function defaultControllerBrandCheckException(name) {
  return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
 }
 function ReadableStreamTee(stream, cloneForBranch2) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var reading = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = newPromise(function (resolve) {
   resolveCancelPromise = resolve;
  });
  function pullAlgorithm() {
   if (reading) {
    return promiseResolvedWith(undefined);
   }
   reading = true;
   var readRequest = {
    _chunkSteps: function (value) {
     queueMicrotask(function () {
      reading = false;
      var value1 = value;
      var value2 = value;
      if (!canceled1) {
       ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);
      }
      if (!canceled2) {
       ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);
      }
      resolveCancelPromise(undefined);
     });
    },
    _closeSteps: function () {
     reading = false;
     if (!canceled1) {
      ReadableStreamDefaultControllerClose(branch1._readableStreamController);
     }
     if (!canceled2) {
      ReadableStreamDefaultControllerClose(branch2._readableStreamController);
     }
    },
    _errorSteps: function () {
     reading = false;
    }
   };
   ReadableStreamDefaultReaderRead(reader, readRequest);
   return promiseResolvedWith(undefined);
  }
  function cancel1Algorithm(reason) {
   canceled1 = true;
   reason1 = reason;
   if (canceled2) {
    var compositeReason = CreateArrayFromList([
     reason1,
     reason2
    ]);
    var cancelResult = ReadableStreamCancel(stream, compositeReason);
    resolveCancelPromise(cancelResult);
   }
   return cancelPromise;
  }
  function cancel2Algorithm(reason) {
   canceled2 = true;
   reason2 = reason;
   if (canceled1) {
    var compositeReason = CreateArrayFromList([
     reason1,
     reason2
    ]);
    var cancelResult = ReadableStreamCancel(stream, compositeReason);
    resolveCancelPromise(cancelResult);
   }
   return cancelPromise;
  }
  function startAlgorithm() {
  }
  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
  uponRejection(reader._closedPromise, function (r) {
   ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
   ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
   resolveCancelPromise(undefined);
  });
  return [
   branch1,
   branch2
  ];
 }
 function convertUnderlyingDefaultOrByteSource(source, context) {
  assertDictionary(source, context);
  var original = source;
  var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
  var cancel = original === null || original === void 0 ? void 0 : original.cancel;
  var pull = original === null || original === void 0 ? void 0 : original.pull;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  return {
   autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
   cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
   pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
   start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
   type: type === undefined ? undefined : convertReadableStreamType(type, context + " has member 'type' that")
  };
 }
 function convertUnderlyingSourceCancelCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (reason) {
   return promiseCall(fn, original, [reason]);
  };
 }
 function convertUnderlyingSourcePullCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (controller) {
   return promiseCall(fn, original, [controller]);
  };
 }
 function convertUnderlyingSourceStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (controller) {
   return reflectCall(fn, original, [controller]);
  };
 }
 function convertReadableStreamType(type, context) {
  type = "" + type;
  if (type !== 'bytes') {
   throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
  }
  return type;
 }
 function convertReaderOptions(options, context) {
  assertDictionary(options, context);
  var mode = options === null || options === void 0 ? void 0 : options.mode;
  return { mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + " has member 'mode' that") };
 }
 function convertReadableStreamReaderMode(mode, context) {
  mode = "" + mode;
  if (mode !== 'byob') {
   throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
  }
  return mode;
 }
 function convertIteratorOptions(options, context) {
  assertDictionary(options, context);
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  return { preventCancel: Boolean(preventCancel) };
 }
 function convertPipeOptions(options, context) {
  assertDictionary(options, context);
  var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
  var signal = options === null || options === void 0 ? void 0 : options.signal;
  if (signal !== undefined) {
   assertAbortSignal(signal, context + " has member 'signal' that");
  }
  return {
   preventAbort: Boolean(preventAbort),
   preventCancel: Boolean(preventCancel),
   preventClose: Boolean(preventClose),
   signal: signal
  };
 }
 function assertAbortSignal(signal, context) {
  if (!isAbortSignal(signal)) {
   throw new TypeError(context + " is not an AbortSignal.");
  }
 }
 function convertReadableWritablePair(pair, context) {
  assertDictionary(pair, context);
  var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
  assertRequiredField(readable, 'readable', 'ReadableWritablePair');
  assertReadableStream(readable, context + " has member 'readable' that");
  var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
  assertRequiredField(writable, 'writable', 'ReadableWritablePair');
  assertWritableStream(writable, context + " has member 'writable' that");
  return {
   readable: readable,
   writable: writable
  };
 }
 var ReadableStream = function () {
  function ReadableStream(rawUnderlyingSource, rawStrategy) {
   if (rawUnderlyingSource === void 0) {
    rawUnderlyingSource = {};
   }
   if (rawStrategy === void 0) {
    rawStrategy = {};
   }
   if (rawUnderlyingSource === undefined) {
    rawUnderlyingSource = null;
   } else {
    assertObject(rawUnderlyingSource, 'First parameter');
   }
   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
   var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
   InitializeReadableStream(this);
   if (underlyingSource.type === 'bytes') {
    if (strategy.size !== undefined) {
     throw new RangeError('The strategy for a byte stream cannot have a size function');
    }
    var highWaterMark = ExtractHighWaterMark(strategy, 0);
    SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
   } else {
    var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
    var highWaterMark = ExtractHighWaterMark(strategy, 1);
    SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
   }
  }
  Object.defineProperty(ReadableStream.prototype, "locked", {
   get: function () {
    if (!IsReadableStream(this)) {
     throw streamBrandCheckException$1('locked');
    }
    return IsReadableStreamLocked(this);
   },
   enumerable: false,
   configurable: true
  });
  ReadableStream.prototype.cancel = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsReadableStream(this)) {
    return promiseRejectedWith(streamBrandCheckException$1('cancel'));
   }
   if (IsReadableStreamLocked(this)) {
    return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
   }
   return ReadableStreamCancel(this, reason);
  };
  ReadableStream.prototype.getReader = function (rawOptions) {
   if (rawOptions === void 0) {
    rawOptions = undefined;
   }
   if (!IsReadableStream(this)) {
    throw streamBrandCheckException$1('getReader');
   }
   var options = convertReaderOptions(rawOptions, 'First parameter');
   if (options.mode === undefined) {
    return AcquireReadableStreamDefaultReader(this);
   }
   return AcquireReadableStreamBYOBReader(this);
  };
  ReadableStream.prototype.pipeThrough = function (rawTransform, rawOptions) {
   if (rawOptions === void 0) {
    rawOptions = {};
   }
   if (!IsReadableStream(this)) {
    throw streamBrandCheckException$1('pipeThrough');
   }
   assertRequiredArgument(rawTransform, 1, 'pipeThrough');
   var transform = convertReadableWritablePair(rawTransform, 'First parameter');
   var options = convertPipeOptions(rawOptions, 'Second parameter');
   if (IsReadableStreamLocked(this)) {
    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
   }
   if (IsWritableStreamLocked(transform.writable)) {
    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
   }
   var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
   setPromiseIsHandledToTrue(promise);
   return transform.readable;
  };
  ReadableStream.prototype.pipeTo = function (destination, rawOptions) {
   if (rawOptions === void 0) {
    rawOptions = {};
   }
   if (!IsReadableStream(this)) {
    return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
   }
   if (destination === undefined) {
    return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
   }
   if (!IsWritableStream(destination)) {
    return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
   }
   var options;
   try {
    options = convertPipeOptions(rawOptions, 'Second parameter');
   } catch (e) {
    return promiseRejectedWith(e);
   }
   if (IsReadableStreamLocked(this)) {
    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
   }
   if (IsWritableStreamLocked(destination)) {
    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
   }
   return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
  };
  ReadableStream.prototype.tee = function () {
   if (!IsReadableStream(this)) {
    throw streamBrandCheckException$1('tee');
   }
   var branches = ReadableStreamTee(this);
   return CreateArrayFromList(branches);
  };
  ReadableStream.prototype.values = function (rawOptions) {
   if (rawOptions === void 0) {
    rawOptions = undefined;
   }
   if (!IsReadableStream(this)) {
    throw streamBrandCheckException$1('values');
   }
   var options = convertIteratorOptions(rawOptions, 'First parameter');
   return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
  };
  return ReadableStream;
 }();
 Object.defineProperties(ReadableStream.prototype, {
  cancel: { enumerable: true },
  getReader: { enumerable: true },
  pipeThrough: { enumerable: true },
  pipeTo: { enumerable: true },
  tee: { enumerable: true },
  values: { enumerable: true },
  locked: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
   value: 'ReadableStream',
   configurable: true
  });
 }
 if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
   value: ReadableStream.prototype.values,
   writable: true,
   configurable: true
  });
 }
 function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
   highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
   sizeAlgorithm = function () {
    return 1;
   };
  }
  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
 }
 function InitializeReadableStream(stream) {
  stream._state = 'readable';
  stream._reader = undefined;
  stream._storedError = undefined;
  stream._disturbed = false;
 }
 function IsReadableStream(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
   return false;
  }
  return true;
 }
 function IsReadableStreamLocked(stream) {
  if (stream._reader === undefined) {
   return false;
  }
  return true;
 }
 function ReadableStreamCancel(stream, reason) {
  stream._disturbed = true;
  if (stream._state === 'closed') {
   return promiseResolvedWith(undefined);
  }
  if (stream._state === 'errored') {
   return promiseRejectedWith(stream._storedError);
  }
  ReadableStreamClose(stream);
  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
  return transformPromiseWith(sourceCancelPromise, noop);
 }
 function ReadableStreamClose(stream) {
  stream._state = 'closed';
  var reader = stream._reader;
  if (reader === undefined) {
   return;
  }
  if (IsReadableStreamDefaultReader(reader)) {
   reader._readRequests.forEach(function (readRequest) {
    readRequest._closeSteps();
   });
   reader._readRequests = new SimpleQueue();
  }
  defaultReaderClosedPromiseResolve(reader);
 }
 function ReadableStreamError(stream, e) {
  stream._state = 'errored';
  stream._storedError = e;
  var reader = stream._reader;
  if (reader === undefined) {
   return;
  }
  if (IsReadableStreamDefaultReader(reader)) {
   reader._readRequests.forEach(function (readRequest) {
    readRequest._errorSteps(e);
   });
   reader._readRequests = new SimpleQueue();
  } else {
   reader._readIntoRequests.forEach(function (readIntoRequest) {
    readIntoRequest._errorSteps(e);
   });
   reader._readIntoRequests = new SimpleQueue();
  }
  defaultReaderClosedPromiseReject(reader, e);
 }
 function streamBrandCheckException$1(name) {
  return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
 }
 function convertQueuingStrategyInit(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
  return { highWaterMark: convertUnrestrictedDouble(highWaterMark) };
 }
 var byteLengthSizeFunction = function size(chunk) {
  return chunk.byteLength;
 };
 var ByteLengthQueuingStrategy = function () {
  function ByteLengthQueuingStrategy(options) {
   assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
   options = convertQueuingStrategyInit(options, 'First parameter');
   this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
  }
  Object.defineProperty(ByteLengthQueuingStrategy.prototype, "highWaterMark", {
   get: function () {
    if (!IsByteLengthQueuingStrategy(this)) {
     throw byteLengthBrandCheckException('highWaterMark');
    }
    return this._byteLengthQueuingStrategyHighWaterMark;
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(ByteLengthQueuingStrategy.prototype, "size", {
   get: function () {
    if (!IsByteLengthQueuingStrategy(this)) {
     throw byteLengthBrandCheckException('size');
    }
    return byteLengthSizeFunction;
   },
   enumerable: false,
   configurable: true
  });
  return ByteLengthQueuingStrategy;
 }();
 Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
  highWaterMark: { enumerable: true },
  size: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
   value: 'ByteLengthQueuingStrategy',
   configurable: true
  });
 }
 function byteLengthBrandCheckException(name) {
  return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
 }
 function IsByteLengthQueuingStrategy(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
   return false;
  }
  return true;
 }
 var countSizeFunction = function size() {
  return 1;
 };
 var CountQueuingStrategy = function () {
  function CountQueuingStrategy(options) {
   assertRequiredArgument(options, 1, 'CountQueuingStrategy');
   options = convertQueuingStrategyInit(options, 'First parameter');
   this._countQueuingStrategyHighWaterMark = options.highWaterMark;
  }
  Object.defineProperty(CountQueuingStrategy.prototype, "highWaterMark", {
   get: function () {
    if (!IsCountQueuingStrategy(this)) {
     throw countBrandCheckException('highWaterMark');
    }
    return this._countQueuingStrategyHighWaterMark;
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(CountQueuingStrategy.prototype, "size", {
   get: function () {
    if (!IsCountQueuingStrategy(this)) {
     throw countBrandCheckException('size');
    }
    return countSizeFunction;
   },
   enumerable: false,
   configurable: true
  });
  return CountQueuingStrategy;
 }();
 Object.defineProperties(CountQueuingStrategy.prototype, {
  highWaterMark: { enumerable: true },
  size: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
   value: 'CountQueuingStrategy',
   configurable: true
  });
 }
 function countBrandCheckException(name) {
  return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
 }
 function IsCountQueuingStrategy(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
   return false;
  }
  return true;
 }
 function convertTransformer(original, context) {
  assertDictionary(original, context);
  var flush = original === null || original === void 0 ? void 0 : original.flush;
  var readableType = original === null || original === void 0 ? void 0 : original.readableType;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var transform = original === null || original === void 0 ? void 0 : original.transform;
  var writableType = original === null || original === void 0 ? void 0 : original.writableType;
  return {
   flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
   readableType: readableType,
   start: start === undefined ? undefined : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
   transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
   writableType: writableType
  };
 }
 function convertTransformerFlushCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (controller) {
   return promiseCall(fn, original, [controller]);
  };
 }
 function convertTransformerStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (controller) {
   return reflectCall(fn, original, [controller]);
  };
 }
 function convertTransformerTransformCallback(fn, original, context) {
  assertFunction(fn, context);
  return function (chunk, controller) {
   return promiseCall(fn, original, [
    chunk,
    controller
   ]);
  };
 }
 var TransformStream = function () {
  function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
   if (rawTransformer === void 0) {
    rawTransformer = {};
   }
   if (rawWritableStrategy === void 0) {
    rawWritableStrategy = {};
   }
   if (rawReadableStrategy === void 0) {
    rawReadableStrategy = {};
   }
   if (rawTransformer === undefined) {
    rawTransformer = null;
   }
   var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
   var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
   var transformer = convertTransformer(rawTransformer, 'First parameter');
   if (transformer.readableType !== undefined) {
    throw new RangeError('Invalid readableType specified');
   }
   if (transformer.writableType !== undefined) {
    throw new RangeError('Invalid writableType specified');
   }
   var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
   var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
   var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
   var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
   var startPromise_resolve;
   var startPromise = newPromise(function (resolve) {
    startPromise_resolve = resolve;
   });
   InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
   SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
   if (transformer.start !== undefined) {
    startPromise_resolve(transformer.start(this._transformStreamController));
   } else {
    startPromise_resolve(undefined);
   }
  }
  Object.defineProperty(TransformStream.prototype, "readable", {
   get: function () {
    if (!IsTransformStream(this)) {
     throw streamBrandCheckException$2('readable');
    }
    return this._readable;
   },
   enumerable: false,
   configurable: true
  });
  Object.defineProperty(TransformStream.prototype, "writable", {
   get: function () {
    if (!IsTransformStream(this)) {
     throw streamBrandCheckException$2('writable');
    }
    return this._writable;
   },
   enumerable: false,
   configurable: true
  });
  return TransformStream;
 }();
 Object.defineProperties(TransformStream.prototype, {
  readable: { enumerable: true },
  writable: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
   value: 'TransformStream',
   configurable: true
  });
 }
 function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
  function startAlgorithm() {
   return startPromise;
  }
  function writeAlgorithm(chunk) {
   return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
  }
  function abortAlgorithm(reason) {
   return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
  }
  function closeAlgorithm() {
   return TransformStreamDefaultSinkCloseAlgorithm(stream);
  }
  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
  function pullAlgorithm() {
   return TransformStreamDefaultSourcePullAlgorithm(stream);
  }
  function cancelAlgorithm(reason) {
   TransformStreamErrorWritableAndUnblockWrite(stream, reason);
   return promiseResolvedWith(undefined);
  }
  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
  stream._backpressure = undefined;
  stream._backpressureChangePromise = undefined;
  stream._backpressureChangePromise_resolve = undefined;
  TransformStreamSetBackpressure(stream, true);
  stream._transformStreamController = undefined;
 }
 function IsTransformStream(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
   return false;
  }
  return true;
 }
 function TransformStreamError(stream, e) {
  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
  TransformStreamErrorWritableAndUnblockWrite(stream, e);
 }
 function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
  if (stream._backpressure) {
   TransformStreamSetBackpressure(stream, false);
  }
 }
 function TransformStreamSetBackpressure(stream, backpressure) {
  if (stream._backpressureChangePromise !== undefined) {
   stream._backpressureChangePromise_resolve();
  }
  stream._backpressureChangePromise = newPromise(function (resolve) {
   stream._backpressureChangePromise_resolve = resolve;
  });
  stream._backpressure = backpressure;
 }
 var TransformStreamDefaultController = function () {
  function TransformStreamDefaultController() {
   throw new TypeError('Illegal constructor');
  }
  Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", {
   get: function () {
    if (!IsTransformStreamDefaultController(this)) {
     throw defaultControllerBrandCheckException$1('desiredSize');
    }
    var readableController = this._controlledTransformStream._readable._readableStreamController;
    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
   },
   enumerable: false,
   configurable: true
  });
  TransformStreamDefaultController.prototype.enqueue = function (chunk) {
   if (chunk === void 0) {
    chunk = undefined;
   }
   if (!IsTransformStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException$1('enqueue');
   }
   TransformStreamDefaultControllerEnqueue(this, chunk);
  };
  TransformStreamDefaultController.prototype.error = function (reason) {
   if (reason === void 0) {
    reason = undefined;
   }
   if (!IsTransformStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException$1('error');
   }
   TransformStreamDefaultControllerError(this, reason);
  };
  TransformStreamDefaultController.prototype.terminate = function () {
   if (!IsTransformStreamDefaultController(this)) {
    throw defaultControllerBrandCheckException$1('terminate');
   }
   TransformStreamDefaultControllerTerminate(this);
  };
  return TransformStreamDefaultController;
 }();
 Object.defineProperties(TransformStreamDefaultController.prototype, {
  enqueue: { enumerable: true },
  error: { enumerable: true },
  terminate: { enumerable: true },
  desiredSize: { enumerable: true }
 });
 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
   value: 'TransformStreamDefaultController',
   configurable: true
  });
 }
 function IsTransformStreamDefaultController(x) {
  if (!typeIsObject(x)) {
   return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
   return false;
  }
  return true;
 }
 function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
  controller._controlledTransformStream = stream;
  stream._transformStreamController = controller;
  controller._transformAlgorithm = transformAlgorithm;
  controller._flushAlgorithm = flushAlgorithm;
 }
 function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
  var controller = Object.create(TransformStreamDefaultController.prototype);
  var transformAlgorithm = function (chunk) {
   try {
    TransformStreamDefaultControllerEnqueue(controller, chunk);
    return promiseResolvedWith(undefined);
   } catch (transformResultE) {
    return promiseRejectedWith(transformResultE);
   }
  };
  var flushAlgorithm = function () {
   return promiseResolvedWith(undefined);
  };
  if (transformer.transform !== undefined) {
   transformAlgorithm = function (chunk) {
    return transformer.transform(chunk, controller);
   };
  }
  if (transformer.flush !== undefined) {
   flushAlgorithm = function () {
    return transformer.flush(controller);
   };
  }
  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
 }
 function TransformStreamDefaultControllerClearAlgorithms(controller) {
  controller._transformAlgorithm = undefined;
  controller._flushAlgorithm = undefined;
 }
 function TransformStreamDefaultControllerEnqueue(controller, chunk) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
   throw new TypeError('Readable side is not in a state that permits enqueue');
  }
  try {
   ReadableStreamDefaultControllerEnqueue(readableController, chunk);
  } catch (e) {
   TransformStreamErrorWritableAndUnblockWrite(stream, e);
   throw stream._readable._storedError;
  }
  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
  if (backpressure !== stream._backpressure) {
   TransformStreamSetBackpressure(stream, true);
  }
 }
 function TransformStreamDefaultControllerError(controller, e) {
  TransformStreamError(controller._controlledTransformStream, e);
 }
 function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
  var transformPromise = controller._transformAlgorithm(chunk);
  return transformPromiseWith(transformPromise, undefined, function (r) {
   TransformStreamError(controller._controlledTransformStream, r);
   throw r;
  });
 }
 function TransformStreamDefaultControllerTerminate(controller) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  ReadableStreamDefaultControllerClose(readableController);
  var error = new TypeError('TransformStream terminated');
  TransformStreamErrorWritableAndUnblockWrite(stream, error);
 }
 function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
  var controller = stream._transformStreamController;
  if (stream._backpressure) {
   var backpressureChangePromise = stream._backpressureChangePromise;
   return transformPromiseWith(backpressureChangePromise, function () {
    var writable = stream._writable;
    var state = writable._state;
    if (state === 'erroring') {
     throw writable._storedError;
    }
    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
   });
  }
  return TransformStreamDefaultControllerPerformTransform(controller, chunk);
 }
 function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
  TransformStreamError(stream, reason);
  return promiseResolvedWith(undefined);
 }
 function TransformStreamDefaultSinkCloseAlgorithm(stream) {
  var readable = stream._readable;
  var controller = stream._transformStreamController;
  var flushPromise = controller._flushAlgorithm();
  TransformStreamDefaultControllerClearAlgorithms(controller);
  return transformPromiseWith(flushPromise, function () {
   if (readable._state === 'errored') {
    throw readable._storedError;
   }
   ReadableStreamDefaultControllerClose(readable._readableStreamController);
  }, function (r) {
   TransformStreamError(stream, r);
   throw readable._storedError;
  });
 }
 function TransformStreamDefaultSourcePullAlgorithm(stream) {
  TransformStreamSetBackpressure(stream, false);
  return stream._backpressureChangePromise;
 }
 function defaultControllerBrandCheckException$1(name) {
  return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
 }
 function streamBrandCheckException$2(name) {
  return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
 }
 exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
 exports.CountQueuingStrategy = CountQueuingStrategy;
 exports.ReadableByteStreamController = ReadableByteStreamController;
 exports.ReadableStream = ReadableStream;
 exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
 exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
 exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
 exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
 exports.TransformStream = TransformStream;
 exports.TransformStreamDefaultController = TransformStreamDefaultController;
 exports.WritableStream = WritableStream;
 exports.WritableStreamDefaultController = WritableStreamDefaultController;
 exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
 Object.defineProperty(exports, '__esModule', { value: true });
}));

/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(123);
var entryUnbind = __w_pdfjs_require__(127);
module.exports = entryUnbind('String', 'padStart');

/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var $padStart = __w_pdfjs_require__(124).start;
var WEBKIT_BUG = __w_pdfjs_require__(126);
$({
 target: 'String',
 proto: true,
 forced: WEBKIT_BUG
}, {
 padStart: function padStart(maxLength) {
  return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
 }
});

/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toLength = __w_pdfjs_require__(46);
var repeat = __w_pdfjs_require__(125);
var requireObjectCoercible = __w_pdfjs_require__(19);
var ceil = Math.ceil;
var createMethod = function (IS_END) {
 return function ($this, maxLength, fillString) {
  var S = String(requireObjectCoercible($this));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  var fillLen, stringFiller;
  if (intMaxLength <= stringLength || fillStr == '')
   return S;
  fillLen = intMaxLength - stringLength;
  stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen)
   stringFiller = stringFiller.slice(0, fillLen);
  return IS_END ? S + stringFiller : stringFiller + S;
 };
};
module.exports = {
 start: createMethod(false),
 end: createMethod(true)
};

/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var toInteger = __w_pdfjs_require__(47);
var requireObjectCoercible = __w_pdfjs_require__(19);
module.exports = ''.repeat || function repeat(count) {
 var str = String(requireObjectCoercible(this));
 var result = '';
 var n = toInteger(count);
 if (n < 0 || n == Infinity)
  throw RangeError('Wrong number of repetitions');
 for (; n > 0; (n >>>= 1) && (str += str))
  if (n & 1)
   result += str;
 return result;
};

/***/ }),
/* 126 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var userAgent = __w_pdfjs_require__(95);
module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

/***/ }),
/* 127 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(10);
var bind = __w_pdfjs_require__(75);
var call = Function.call;
module.exports = function (CONSTRUCTOR, METHOD, length) {
 return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};

/***/ }),
/* 128 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(129);
var entryUnbind = __w_pdfjs_require__(127);
module.exports = entryUnbind('String', 'padEnd');

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

"use strict";

var $ = __w_pdfjs_require__(9);
var $padEnd = __w_pdfjs_require__(124).end;
var WEBKIT_BUG = __w_pdfjs_require__(126);
$({
 target: 'String',
 proto: true,
 forced: WEBKIT_BUG
}, {
 padEnd: function padEnd(maxLength) {
  return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
 }
});

/***/ }),
/* 130 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(131);
var path = __w_pdfjs_require__(42);
module.exports = path.Object.values;

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(9);
var $values = __w_pdfjs_require__(132).values;
$({
 target: 'Object',
 stat: true
}, {
 values: function values(O) {
  return $values(O);
 }
});

/***/ }),
/* 132 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(12);
var objectKeys = __w_pdfjs_require__(60);
var toIndexedObject = __w_pdfjs_require__(16);
var propertyIsEnumerable = __w_pdfjs_require__(14).f;
var createMethod = function (TO_ENTRIES) {
 return function (it) {
  var O = toIndexedObject(it);
  var keys = objectKeys(O);
  var length = keys.length;
  var i = 0;
  var result = [];
  var key;
  while (length > i) {
   key = keys[i++];
   if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
    result.push(TO_ENTRIES ? [
     key,
     O[key]
    ] : O[key]);
   }
  }
  return result;
 };
};
module.exports = {
 entries: createMethod(true),
 values: createMethod(false)
};

/***/ }),
/* 133 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(134);
var path = __w_pdfjs_require__(42);
module.exports = path.Object.entries;

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(9);
var $entries = __w_pdfjs_require__(132).entries;
$({
 target: 'Object',
 stat: true
}, {
 entries: function entries(O) {
  return $entries(O);
 }
});

/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearPrimitiveCaches = clearPrimitiveCaches;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isEOF = isEOF;
exports.isName = isName;
exports.isRef = isRef;
exports.isRefsEqual = isRefsEqual;
exports.isStream = isStream;
exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var EOF = {};
exports.EOF = EOF;

var Name = function NameClosure() {
  var nameCache = Object.create(null);

  function Name(name) {
    this.name = name;
  }

  Name.prototype = {};

  Name.get = function Name_get(name) {
    var nameValue = nameCache[name];
    return nameValue ? nameValue : nameCache[name] = new Name(name);
  };

  Name._clearCache = function () {
    nameCache = Object.create(null);
  };

  return Name;
}();

exports.Name = Name;

var Cmd = function CmdClosure() {
  var cmdCache = Object.create(null);

  function Cmd(cmd) {
    this.cmd = cmd;
  }

  Cmd.prototype = {};

  Cmd.get = function Cmd_get(cmd) {
    var cmdValue = cmdCache[cmd];
    return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd(cmd);
  };

  Cmd._clearCache = function () {
    cmdCache = Object.create(null);
  };

  return Cmd;
}();

exports.Cmd = Cmd;

var Dict = function DictClosure() {
  var nonSerializable = function nonSerializableClosure() {
    return nonSerializable;
  };

  function Dict(xref) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }

  Dict.prototype = {
    assignXref: function Dict_assignXref(newXref) {
      this.xref = newXref;
    },

    get size() {
      return Object.keys(this._map).length;
    },

    get: function get(key1, key2, key3) {
      var value = this._map[key1];

      if (value === undefined && key2 !== undefined) {
        value = this._map[key2];

        if (value === undefined && key3 !== undefined) {
          value = this._map[key3];
        }
      }

      if (value instanceof Ref && this.xref) {
        return this.xref.fetch(value, this.suppressEncryption);
      }

      return value;
    },
    getAsync: function getAsync(key1, key2, key3) {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var value;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                value = _this._map[key1];

                if (value === undefined && key2 !== undefined) {
                  value = _this._map[key2];

                  if (value === undefined && key3 !== undefined) {
                    value = _this._map[key3];
                  }
                }

                if (!(value instanceof Ref && _this.xref)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", _this.xref.fetchAsync(value, _this.suppressEncryption));

              case 4:
                return _context.abrupt("return", value);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    getArray: function getArray(key1, key2, key3) {
      var value = this.get(key1, key2, key3);

      if (!Array.isArray(value) || !this.xref) {
        return value;
      }

      value = value.slice();

      for (var i = 0, ii = value.length; i < ii; i++) {
        if (!(value[i] instanceof Ref)) {
          continue;
        }

        value[i] = this.xref.fetch(value[i], this.suppressEncryption);
      }

      return value;
    },
    getRaw: function Dict_getRaw(key) {
      return this._map[key];
    },
    getKeys: function Dict_getKeys() {
      return Object.keys(this._map);
    },
    getRawValues: function Dict_getRawValues() {
      return Object.values(this._map);
    },
    set: function Dict_set(key, value) {
      this._map[key] = value;
    },
    has: function Dict_has(key) {
      return this._map[key] !== undefined;
    },
    forEach: function Dict_forEach(callback) {
      for (var key in this._map) {
        callback(key, this.get(key));
      }
    }
  };

  Dict.empty = function () {
    var emptyDict = new Dict(null);

    emptyDict.set = function (key, value) {
      (0, _util.unreachable)("Should not call `set` on the empty dictionary.");
    };

    return emptyDict;
  }();

  Dict.merge = function (_ref) {
    var xref = _ref.xref,
        dictArray = _ref.dictArray,
        _ref$mergeSubDicts = _ref.mergeSubDicts,
        mergeSubDicts = _ref$mergeSubDicts === void 0 ? false : _ref$mergeSubDicts;
    var mergedDict = new Dict(xref);

    if (!mergeSubDicts) {
      var _iterator = _createForOfIteratorHelper(dictArray),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dict = _step.value;

          if (!(dict instanceof Dict)) {
            continue;
          }

          for (var _i = 0, _Object$entries = Object.entries(dict._map); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (mergedDict._map[key] === undefined) {
              mergedDict._map[key] = value;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return mergedDict.size > 0 ? mergedDict : Dict.empty;
    }

    var properties = new Map();

    var _iterator2 = _createForOfIteratorHelper(dictArray),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _dict = _step2.value;

        if (!(_dict instanceof Dict)) {
          continue;
        }

        for (var _i2 = 0, _Object$entries2 = Object.entries(_dict._map); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
              _key = _Object$entries2$_i[0],
              _value = _Object$entries2$_i[1];

          var property = properties.get(_key);

          if (property === undefined) {
            property = [];
            properties.set(_key, property);
          }

          property.push(_value);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    var _iterator3 = _createForOfIteratorHelper(properties),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _step3$value = _slicedToArray(_step3.value, 2),
            name = _step3$value[0],
            values = _step3$value[1];

        if (values.length === 1 || !(values[0] instanceof Dict)) {
          mergedDict._map[name] = values[0];
          continue;
        }

        var subDict = new Dict(xref);

        var _iterator4 = _createForOfIteratorHelper(values),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _dict2 = _step4.value;

            if (!(_dict2 instanceof Dict)) {
              continue;
            }

            for (var _i3 = 0, _Object$entries3 = Object.entries(_dict2._map); _i3 < _Object$entries3.length; _i3++) {
              var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
                  _key2 = _Object$entries3$_i[0],
                  _value2 = _Object$entries3$_i[1];

              if (subDict._map[_key2] === undefined) {
                subDict._map[_key2] = _value2;
              }
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (subDict.size > 0) {
          mergedDict._map[name] = subDict;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    properties.clear();
    return mergedDict.size > 0 ? mergedDict : Dict.empty;
  };

  return Dict;
}();

exports.Dict = Dict;

var Ref = function RefClosure() {
  var refCache = Object.create(null);

  function Ref(num, gen) {
    this.num = num;
    this.gen = gen;
  }

  Ref.prototype = {
    toString: function Ref_toString() {
      if (this.gen === 0) {
        return "".concat(this.num, "R");
      }

      return "".concat(this.num, "R").concat(this.gen);
    }
  };

  Ref.get = function (num, gen) {
    var key = gen === 0 ? "".concat(num, "R") : "".concat(num, "R").concat(gen);
    var refValue = refCache[key];
    return refValue ? refValue : refCache[key] = new Ref(num, gen);
  };

  Ref._clearCache = function () {
    refCache = Object.create(null);
  };

  return Ref;
}();

exports.Ref = Ref;

var RefSet = /*#__PURE__*/function () {
  function RefSet() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, RefSet);

    this._set = new Set(parent && parent._set);
  }

  _createClass(RefSet, [{
    key: "has",
    value: function has(ref) {
      return this._set.has(ref.toString());
    }
  }, {
    key: "put",
    value: function put(ref) {
      this._set.add(ref.toString());
    }
  }, {
    key: "remove",
    value: function remove(ref) {
      this._set["delete"](ref.toString());
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _iterator5 = _createForOfIteratorHelper(this._set.values()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ref = _step5.value;
          callback(ref);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._set.clear();
    }
  }]);

  return RefSet;
}();

exports.RefSet = RefSet;

var RefSetCache = /*#__PURE__*/function () {
  function RefSetCache() {
    _classCallCheck(this, RefSetCache);

    this._map = new Map();
  }

  _createClass(RefSetCache, [{
    key: "size",
    get: function get() {
      return this._map.size;
    }
  }, {
    key: "get",
    value: function get(ref) {
      return this._map.get(ref.toString());
    }
  }, {
    key: "has",
    value: function has(ref) {
      return this._map.has(ref.toString());
    }
  }, {
    key: "put",
    value: function put(ref, obj) {
      this._map.set(ref.toString(), obj);
    }
  }, {
    key: "putAlias",
    value: function putAlias(ref, aliasRef) {
      this._map.set(ref.toString(), this.get(aliasRef));
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _iterator6 = _createForOfIteratorHelper(this._map.values()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var value = _step6.value;
          callback(value);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._map.clear();
    }
  }]);

  return RefSetCache;
}();

exports.RefSetCache = RefSetCache;

function isEOF(v) {
  return v === EOF;
}

function isName(v, name) {
  return v instanceof Name && (name === undefined || v.name === name);
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get("Type"), type));
}

function isRef(v) {
  return v instanceof Ref;
}

function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}

function isStream(v) {
  return _typeof(v) === "object" && v !== null && v.getBytes !== undefined;
}

function clearPrimitiveCaches() {
  Cmd._clearCache();

  Name._clearCache();

  Ref._clearCache();
}

/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NetworkPdfManager = exports.LocalPdfManager = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _chunked_stream = __w_pdfjs_require__(137);

var _core_utils = __w_pdfjs_require__(138);

var _document = __w_pdfjs_require__(139);

var _stream = __w_pdfjs_require__(142);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BasePdfManager = /*#__PURE__*/function () {
  function BasePdfManager() {
    _classCallCheck(this, BasePdfManager);

    if (this.constructor === BasePdfManager) {
      (0, _util.unreachable)("Cannot initialize BasePdfManager.");
    }
  }

  _createClass(BasePdfManager, [{
    key: "docId",
    get: function get() {
      return this._docId;
    }
  }, {
    key: "password",
    get: function get() {
      return this._password;
    }
  }, {
    key: "docBaseUrl",
    get: function get() {
      var docBaseUrl = null;

      if (this._docBaseUrl) {
        var absoluteUrl = (0, _util.createValidAbsoluteUrl)(this._docBaseUrl);

        if (absoluteUrl) {
          docBaseUrl = absoluteUrl.href;
        } else {
          (0, _util.warn)("Invalid absolute docBaseUrl: \"".concat(this._docBaseUrl, "\"."));
        }
      }

      return (0, _util.shadow)(this, "docBaseUrl", docBaseUrl);
    }
  }, {
    key: "onLoadedStream",
    value: function onLoadedStream() {
      (0, _util.unreachable)("Abstract method `onLoadedStream` called");
    }
  }, {
    key: "ensureDoc",
    value: function ensureDoc(prop, args) {
      return this.ensure(this.pdfDocument, prop, args);
    }
  }, {
    key: "ensureXRef",
    value: function ensureXRef(prop, args) {
      return this.ensure(this.pdfDocument.xref, prop, args);
    }
  }, {
    key: "ensureCatalog",
    value: function ensureCatalog(prop, args) {
      return this.ensure(this.pdfDocument.catalog, prop, args);
    }
  }, {
    key: "getPage",
    value: function getPage(pageIndex) {
      return this.pdfDocument.getPage(pageIndex);
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(id, handler) {
      return this.pdfDocument.fontFallback(id, handler);
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var manuallyTriggered = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.pdfDocument.cleanup(manuallyTriggered);
    }
  }, {
    key: "ensure",
    value: function () {
      var _ensure = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(obj, prop, args) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (0, _util.unreachable)("Abstract method `ensure` called");

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function ensure(_x, _x2, _x3) {
        return _ensure.apply(this, arguments);
      }

      return ensure;
    }()
  }, {
    key: "requestRange",
    value: function requestRange(begin, end) {
      (0, _util.unreachable)("Abstract method `requestRange` called");
    }
  }, {
    key: "requestLoadedStream",
    value: function requestLoadedStream() {
      (0, _util.unreachable)("Abstract method `requestLoadedStream` called");
    }
  }, {
    key: "sendProgressiveData",
    value: function sendProgressiveData(chunk) {
      (0, _util.unreachable)("Abstract method `sendProgressiveData` called");
    }
  }, {
    key: "updatePassword",
    value: function updatePassword(password) {
      this._password = password;
    }
  }, {
    key: "terminate",
    value: function terminate(reason) {
      (0, _util.unreachable)("Abstract method `terminate` called");
    }
  }]);

  return BasePdfManager;
}();

var LocalPdfManager = /*#__PURE__*/function (_BasePdfManager) {
  _inherits(LocalPdfManager, _BasePdfManager);

  var _super = _createSuper(LocalPdfManager);

  function LocalPdfManager(docId, data, password, evaluatorOptions, docBaseUrl) {
    var _this;

    _classCallCheck(this, LocalPdfManager);

    _this = _super.call(this);
    _this._docId = docId;
    _this._password = password;
    _this._docBaseUrl = docBaseUrl;
    _this.evaluatorOptions = evaluatorOptions;
    var stream = new _stream.Stream(data);
    _this.pdfDocument = new _document.PDFDocument(_assertThisInitialized(_this), stream);
    _this._loadedStreamPromise = Promise.resolve(stream);
    return _this;
  }

  _createClass(LocalPdfManager, [{
    key: "ensure",
    value: function () {
      var _ensure2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(obj, prop, args) {
        var value;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                value = obj[prop];

                if (!(typeof value === "function")) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", value.apply(obj, args));

              case 3:
                return _context2.abrupt("return", value);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function ensure(_x4, _x5, _x6) {
        return _ensure2.apply(this, arguments);
      }

      return ensure;
    }()
  }, {
    key: "requestRange",
    value: function requestRange(begin, end) {
      return Promise.resolve();
    }
  }, {
    key: "requestLoadedStream",
    value: function requestLoadedStream() {}
  }, {
    key: "onLoadedStream",
    value: function onLoadedStream() {
      return this._loadedStreamPromise;
    }
  }, {
    key: "terminate",
    value: function terminate(reason) {}
  }]);

  return LocalPdfManager;
}(BasePdfManager);

exports.LocalPdfManager = LocalPdfManager;

var NetworkPdfManager = /*#__PURE__*/function (_BasePdfManager2) {
  _inherits(NetworkPdfManager, _BasePdfManager2);

  var _super2 = _createSuper(NetworkPdfManager);

  function NetworkPdfManager(docId, pdfNetworkStream, args, evaluatorOptions, docBaseUrl) {
    var _this2;

    _classCallCheck(this, NetworkPdfManager);

    _this2 = _super2.call(this);
    _this2._docId = docId;
    _this2._password = args.password;
    _this2._docBaseUrl = docBaseUrl;
    _this2.msgHandler = args.msgHandler;
    _this2.evaluatorOptions = evaluatorOptions;
    _this2.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, {
      msgHandler: args.msgHandler,
      length: args.length,
      disableAutoFetch: args.disableAutoFetch,
      rangeChunkSize: args.rangeChunkSize
    });
    _this2.pdfDocument = new _document.PDFDocument(_assertThisInitialized(_this2), _this2.streamManager.getStream());
    return _this2;
  }

  _createClass(NetworkPdfManager, [{
    key: "ensure",
    value: function () {
      var _ensure3 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(obj, prop, args) {
        var value;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                value = obj[prop];

                if (!(typeof value === "function")) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", value.apply(obj, args));

              case 4:
                return _context3.abrupt("return", value);

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](0);

                if (_context3.t0 instanceof _core_utils.MissingDataException) {
                  _context3.next = 11;
                  break;
                }

                throw _context3.t0;

              case 11:
                _context3.next = 13;
                return this.requestRange(_context3.t0.begin, _context3.t0.end);

              case 13:
                return _context3.abrupt("return", this.ensure(obj, prop, args));

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 7]]);
      }));

      function ensure(_x7, _x8, _x9) {
        return _ensure3.apply(this, arguments);
      }

      return ensure;
    }()
  }, {
    key: "requestRange",
    value: function requestRange(begin, end) {
      return this.streamManager.requestRange(begin, end);
    }
  }, {
    key: "requestLoadedStream",
    value: function requestLoadedStream() {
      this.streamManager.requestAllChunks();
    }
  }, {
    key: "sendProgressiveData",
    value: function sendProgressiveData(chunk) {
      this.streamManager.onReceiveData({
        chunk: chunk
      });
    }
  }, {
    key: "onLoadedStream",
    value: function onLoadedStream() {
      return this.streamManager.onLoadedStream();
    }
  }, {
    key: "terminate",
    value: function terminate(reason) {
      this.streamManager.abort(reason);
    }
  }]);

  return NetworkPdfManager;
}(BasePdfManager);

exports.NetworkPdfManager = NetworkPdfManager;

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChunkedStreamManager = exports.ChunkedStream = void 0;

var _util = __w_pdfjs_require__(4);

var _core_utils = __w_pdfjs_require__(138);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ChunkedStream = /*#__PURE__*/function () {
  function ChunkedStream(length, chunkSize, manager) {
    _classCallCheck(this, ChunkedStream);

    this.bytes = new Uint8Array(length);
    this.start = 0;
    this.pos = 0;
    this.end = length;
    this.chunkSize = chunkSize;
    this._loadedChunks = new Set();
    this.numChunks = Math.ceil(length / chunkSize);
    this.manager = manager;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }

  _createClass(ChunkedStream, [{
    key: "getMissingChunks",
    value: function getMissingChunks() {
      var chunks = [];

      for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
        if (!this._loadedChunks.has(chunk)) {
          chunks.push(chunk);
        }
      }

      return chunks;
    }
  }, {
    key: "getBaseStreams",
    value: function getBaseStreams() {
      return [this];
    }
  }, {
    key: "numChunksLoaded",
    get: function get() {
      return this._loadedChunks.size;
    }
  }, {
    key: "allChunksLoaded",
    value: function allChunksLoaded() {
      return this.numChunksLoaded === this.numChunks;
    }
  }, {
    key: "onReceiveData",
    value: function onReceiveData(begin, chunk) {
      var chunkSize = this.chunkSize;

      if (begin % chunkSize !== 0) {
        throw new Error("Bad begin offset: ".concat(begin));
      }

      var end = begin + chunk.byteLength;

      if (end % chunkSize !== 0 && end !== this.bytes.length) {
        throw new Error("Bad end offset: ".concat(end));
      }

      this.bytes.set(new Uint8Array(chunk), begin);
      var beginChunk = Math.floor(begin / chunkSize);
      var endChunk = Math.floor((end - 1) / chunkSize) + 1;

      for (var curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
        this._loadedChunks.add(curChunk);
      }
    }
  }, {
    key: "onReceiveProgressiveData",
    value: function onReceiveProgressiveData(data) {
      var position = this.progressiveDataLength;
      var beginChunk = Math.floor(position / this.chunkSize);
      this.bytes.set(new Uint8Array(data), position);
      position += data.byteLength;
      this.progressiveDataLength = position;
      var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);

      for (var curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
        this._loadedChunks.add(curChunk);
      }
    }
  }, {
    key: "ensureByte",
    value: function ensureByte(pos) {
      if (pos < this.progressiveDataLength) {
        return;
      }

      var chunk = Math.floor(pos / this.chunkSize);

      if (chunk === this.lastSuccessfulEnsureByteChunk) {
        return;
      }

      if (!this._loadedChunks.has(chunk)) {
        throw new _core_utils.MissingDataException(pos, pos + 1);
      }

      this.lastSuccessfulEnsureByteChunk = chunk;
    }
  }, {
    key: "ensureRange",
    value: function ensureRange(begin, end) {
      if (begin >= end) {
        return;
      }

      if (end <= this.progressiveDataLength) {
        return;
      }

      var chunkSize = this.chunkSize;
      var beginChunk = Math.floor(begin / chunkSize);
      var endChunk = Math.floor((end - 1) / chunkSize) + 1;

      for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!this._loadedChunks.has(chunk)) {
          throw new _core_utils.MissingDataException(begin, end);
        }
      }
    }
  }, {
    key: "nextEmptyChunk",
    value: function nextEmptyChunk(beginChunk) {
      var numChunks = this.numChunks;

      for (var i = 0; i < numChunks; ++i) {
        var chunk = (beginChunk + i) % numChunks;

        if (!this._loadedChunks.has(chunk)) {
          return chunk;
        }
      }

      return null;
    }
  }, {
    key: "hasChunk",
    value: function hasChunk(chunk) {
      return this._loadedChunks.has(chunk);
    }
  }, {
    key: "length",
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.length === 0;
    }
  }, {
    key: "getByte",
    value: function getByte() {
      var pos = this.pos;

      if (pos >= this.end) {
        return -1;
      }

      if (pos >= this.progressiveDataLength) {
        this.ensureByte(pos);
      }

      return this.bytes[this.pos++];
    }
  }, {
    key: "getUint16",
    value: function getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();

      if (b0 === -1 || b1 === -1) {
        return -1;
      }

      return (b0 << 8) + b1;
    }
  }, {
    key: "getInt32",
    value: function getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    }
  }, {
    key: "getBytes",
    value: function getBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;

      if (!length) {
        if (strEnd > this.progressiveDataLength) {
          this.ensureRange(pos, strEnd);
        }

        var _subarray = bytes.subarray(pos, strEnd);

        return forceClamped ? new Uint8ClampedArray(_subarray) : _subarray;
      }

      var end = pos + length;

      if (end > strEnd) {
        end = strEnd;
      }

      if (end > this.progressiveDataLength) {
        this.ensureRange(pos, end);
      }

      this.pos = end;
      var subarray = bytes.subarray(pos, end);
      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
    }
  }, {
    key: "peekByte",
    value: function peekByte() {
      var peekedByte = this.getByte();

      if (peekedByte !== -1) {
        this.pos--;
      }

      return peekedByte;
    }
  }, {
    key: "peekBytes",
    value: function peekBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bytes = this.getBytes(length, forceClamped);
      this.pos -= bytes.length;
      return bytes;
    }
  }, {
    key: "getByteRange",
    value: function getByteRange(begin, end) {
      if (begin < 0) {
        begin = 0;
      }

      if (end > this.end) {
        end = this.end;
      }

      if (end > this.progressiveDataLength) {
        this.ensureRange(begin, end);
      }

      return this.bytes.subarray(begin, end);
    }
  }, {
    key: "skip",
    value: function skip(n) {
      if (!n) {
        n = 1;
      }

      this.pos += n;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.pos = this.start;
    }
  }, {
    key: "moveStart",
    value: function moveStart() {
      this.start = this.pos;
    }
  }, {
    key: "makeSubStream",
    value: function makeSubStream(start, length, dict) {
      if (length) {
        if (start + length > this.progressiveDataLength) {
          this.ensureRange(start, start + length);
        }
      } else {
        if (start >= this.progressiveDataLength) {
          this.ensureByte(start);
        }
      }

      function ChunkedStreamSubstream() {}

      ChunkedStreamSubstream.prototype = Object.create(this);

      ChunkedStreamSubstream.prototype.getMissingChunks = function () {
        var chunkSize = this.chunkSize;
        var beginChunk = Math.floor(this.start / chunkSize);
        var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
        var missingChunks = [];

        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
          if (!this._loadedChunks.has(chunk)) {
            missingChunks.push(chunk);
          }
        }

        return missingChunks;
      };

      ChunkedStreamSubstream.prototype.allChunksLoaded = function () {
        if (this.numChunksLoaded === this.numChunks) {
          return true;
        }

        return this.getMissingChunks().length === 0;
      };

      var subStream = new ChunkedStreamSubstream();
      subStream.pos = subStream.start = start;
      subStream.end = start + length || this.end;
      subStream.dict = dict;
      return subStream;
    }
  }]);

  return ChunkedStream;
}();

exports.ChunkedStream = ChunkedStream;

var ChunkedStreamManager = /*#__PURE__*/function () {
  function ChunkedStreamManager(pdfNetworkStream, args) {
    _classCallCheck(this, ChunkedStreamManager);

    this.length = args.length;
    this.chunkSize = args.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = pdfNetworkStream;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = new Map();
    this._requestsByChunk = new Map();
    this._promisesByRequest = new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = (0, _util.createPromiseCapability)();
  }

  _createClass(ChunkedStreamManager, [{
    key: "onLoadedStream",
    value: function onLoadedStream() {
      return this._loadedStreamCapability.promise;
    }
  }, {
    key: "sendRequest",
    value: function sendRequest(begin, end) {
      var _this = this;

      var rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);

      if (!rangeReader.isStreamingSupported) {
        rangeReader.onProgress = this.onProgress.bind(this);
      }

      var chunks = [],
          loaded = 0;
      var promise = new Promise(function (resolve, reject) {
        var readChunk = function readChunk(chunk) {
          try {
            if (!chunk.done) {
              var data = chunk.value;
              chunks.push(data);
              loaded += (0, _util.arrayByteLength)(data);

              if (rangeReader.isStreamingSupported) {
                _this.onProgress({
                  loaded: loaded
                });
              }

              rangeReader.read().then(readChunk, reject);
              return;
            }

            var chunkData = (0, _util.arraysToBytes)(chunks);
            chunks = null;
            resolve(chunkData);
          } catch (e) {
            reject(e);
          }
        };

        rangeReader.read().then(readChunk, reject);
      });
      promise.then(function (data) {
        if (_this.aborted) {
          return;
        }

        _this.onReceiveData({
          chunk: data,
          begin: begin
        });
      });
    }
  }, {
    key: "requestAllChunks",
    value: function requestAllChunks() {
      var missingChunks = this.stream.getMissingChunks();

      this._requestChunks(missingChunks);

      return this._loadedStreamCapability.promise;
    }
  }, {
    key: "_requestChunks",
    value: function _requestChunks(chunks) {
      var _this2 = this;

      var requestId = this.currRequestId++;
      var chunksNeeded = new Set();

      this._chunksNeededByRequest.set(requestId, chunksNeeded);

      var _iterator = _createForOfIteratorHelper(chunks),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var chunk = _step.value;

          if (!this.stream.hasChunk(chunk)) {
            chunksNeeded.add(chunk);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (chunksNeeded.size === 0) {
        return Promise.resolve();
      }

      var capability = (0, _util.createPromiseCapability)();

      this._promisesByRequest.set(requestId, capability);

      var chunksToRequest = [];

      var _iterator2 = _createForOfIteratorHelper(chunksNeeded),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _chunk = _step2.value;

          var requestIds = this._requestsByChunk.get(_chunk);

          if (!requestIds) {
            requestIds = [];

            this._requestsByChunk.set(_chunk, requestIds);

            chunksToRequest.push(_chunk);
          }

          requestIds.push(requestId);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (chunksToRequest.length > 0) {
        var groupedChunksToRequest = this.groupChunks(chunksToRequest);

        var _iterator3 = _createForOfIteratorHelper(groupedChunksToRequest),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var groupedChunk = _step3.value;
            var begin = groupedChunk.beginChunk * this.chunkSize;
            var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
            this.sendRequest(begin, end);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      return capability.promise["catch"](function (reason) {
        if (_this2.aborted) {
          return;
        }

        throw reason;
      });
    }
  }, {
    key: "getStream",
    value: function getStream() {
      return this.stream;
    }
  }, {
    key: "requestRange",
    value: function requestRange(begin, end) {
      end = Math.min(end, this.length);
      var beginChunk = this.getBeginChunk(begin);
      var endChunk = this.getEndChunk(end);
      var chunks = [];

      for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
        chunks.push(chunk);
      }

      return this._requestChunks(chunks);
    }
  }, {
    key: "requestRanges",
    value: function requestRanges() {
      var ranges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var chunksToRequest = [];

      var _iterator4 = _createForOfIteratorHelper(ranges),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var range = _step4.value;
          var beginChunk = this.getBeginChunk(range.begin);
          var endChunk = this.getEndChunk(range.end);

          for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
            if (!chunksToRequest.includes(chunk)) {
              chunksToRequest.push(chunk);
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      chunksToRequest.sort(function (a, b) {
        return a - b;
      });
      return this._requestChunks(chunksToRequest);
    }
  }, {
    key: "groupChunks",
    value: function groupChunks(chunks) {
      var groupedChunks = [];
      var beginChunk = -1;
      var prevChunk = -1;

      for (var i = 0, ii = chunks.length; i < ii; ++i) {
        var chunk = chunks[i];

        if (beginChunk < 0) {
          beginChunk = chunk;
        }

        if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
          groupedChunks.push({
            beginChunk: beginChunk,
            endChunk: prevChunk + 1
          });
          beginChunk = chunk;
        }

        if (i + 1 === chunks.length) {
          groupedChunks.push({
            beginChunk: beginChunk,
            endChunk: chunk + 1
          });
        }

        prevChunk = chunk;
      }

      return groupedChunks;
    }
  }, {
    key: "onProgress",
    value: function onProgress(args) {
      this.msgHandler.send("DocProgress", {
        loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
        total: this.length
      });
    }
  }, {
    key: "onReceiveData",
    value: function onReceiveData(args) {
      var chunk = args.chunk;
      var isProgressive = args.begin === undefined;
      var begin = isProgressive ? this.progressiveDataLength : args.begin;
      var end = begin + chunk.byteLength;
      var beginChunk = Math.floor(begin / this.chunkSize);
      var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);

      if (isProgressive) {
        this.stream.onReceiveProgressiveData(chunk);
        this.progressiveDataLength = end;
      } else {
        this.stream.onReceiveData(begin, chunk);
      }

      if (this.stream.allChunksLoaded()) {
        this._loadedStreamCapability.resolve(this.stream);
      }

      var loadedRequests = [];

      for (var curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
        var requestIds = this._requestsByChunk.get(curChunk);

        if (!requestIds) {
          continue;
        }

        this._requestsByChunk["delete"](curChunk);

        var _iterator5 = _createForOfIteratorHelper(requestIds),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var requestId = _step5.value;

            var chunksNeeded = this._chunksNeededByRequest.get(requestId);

            if (chunksNeeded.has(curChunk)) {
              chunksNeeded["delete"](curChunk);
            }

            if (chunksNeeded.size > 0) {
              continue;
            }

            loadedRequests.push(requestId);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }

      if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
        var nextEmptyChunk;

        if (this.stream.numChunksLoaded === 1) {
          var lastChunk = this.stream.numChunks - 1;

          if (!this.stream.hasChunk(lastChunk)) {
            nextEmptyChunk = lastChunk;
          }
        } else {
          nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
        }

        if (Number.isInteger(nextEmptyChunk)) {
          this._requestChunks([nextEmptyChunk]);
        }
      }

      for (var _i = 0, _loadedRequests = loadedRequests; _i < _loadedRequests.length; _i++) {
        var _requestId = _loadedRequests[_i];

        var capability = this._promisesByRequest.get(_requestId);

        this._promisesByRequest["delete"](_requestId);

        capability.resolve();
      }

      this.msgHandler.send("DocProgress", {
        loaded: this.stream.numChunksLoaded * this.chunkSize,
        total: this.length
      });
    }
  }, {
    key: "onError",
    value: function onError(err) {
      this._loadedStreamCapability.reject(err);
    }
  }, {
    key: "getBeginChunk",
    value: function getBeginChunk(begin) {
      return Math.floor(begin / this.chunkSize);
    }
  }, {
    key: "getEndChunk",
    value: function getEndChunk(end) {
      return Math.floor((end - 1) / this.chunkSize) + 1;
    }
  }, {
    key: "abort",
    value: function abort(reason) {
      this.aborted = true;

      if (this.pdfNetworkStream) {
        this.pdfNetworkStream.cancelAllRequests(reason);
      }

      var _iterator6 = _createForOfIteratorHelper(this._promisesByRequest.values()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var capability = _step6.value;
          capability.reject(reason);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }]);

  return ChunkedStreamManager;
}();

exports.ChunkedStreamManager = ChunkedStreamManager;

/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.collectActions = collectActions;
exports.escapePDFName = escapePDFName;
exports.getArrayLookupTableFactory = getArrayLookupTableFactory;
exports.getInheritableProperty = getInheritableProperty;
exports.getLookupTableFactory = getLookupTableFactory;
exports.isWhiteSpace = isWhiteSpace;
exports.log2 = log2;
exports.parseXFAPath = parseXFAPath;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.toRomanNumerals = toRomanNumerals;
exports.XRefParseException = exports.XRefEntryException = exports.MissingDataException = void 0;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function getLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }

    return lookup;
  };
}

function getArrayLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      var arr = initializer();
      initializer = null;
      lookup = Object.create(null);

      for (var i = 0, ii = arr.length; i < ii; i += 2) {
        lookup[arr[i]] = arr[i + 1];
      }

      arr = null;
    }

    return lookup;
  };
}

var MissingDataException = /*#__PURE__*/function (_BaseException) {
  _inherits(MissingDataException, _BaseException);

  var _super = _createSuper(MissingDataException);

  function MissingDataException(begin, end) {
    var _this;

    _classCallCheck(this, MissingDataException);

    _this = _super.call(this, "Missing data [".concat(begin, ", ").concat(end, ")"));
    _this.begin = begin;
    _this.end = end;
    return _this;
  }

  return MissingDataException;
}(_util.BaseException);

exports.MissingDataException = MissingDataException;

var XRefEntryException = /*#__PURE__*/function (_BaseException2) {
  _inherits(XRefEntryException, _BaseException2);

  var _super2 = _createSuper(XRefEntryException);

  function XRefEntryException() {
    _classCallCheck(this, XRefEntryException);

    return _super2.apply(this, arguments);
  }

  return XRefEntryException;
}(_util.BaseException);

exports.XRefEntryException = XRefEntryException;

var XRefParseException = /*#__PURE__*/function (_BaseException3) {
  _inherits(XRefParseException, _BaseException3);

  var _super3 = _createSuper(XRefParseException);

  function XRefParseException() {
    _classCallCheck(this, XRefParseException);

    return _super3.apply(this, arguments);
  }

  return XRefParseException;
}(_util.BaseException);

exports.XRefParseException = XRefParseException;

function getInheritableProperty(_ref) {
  var dict = _ref.dict,
      key = _ref.key,
      _ref$getArray = _ref.getArray,
      getArray = _ref$getArray === void 0 ? false : _ref$getArray,
      _ref$stopWhenFound = _ref.stopWhenFound,
      stopWhenFound = _ref$stopWhenFound === void 0 ? true : _ref$stopWhenFound;
  var LOOP_LIMIT = 100;
  var loopCount = 0;
  var values;

  while (dict) {
    var value = getArray ? dict.getArray(key) : dict.get(key);

    if (value !== undefined) {
      if (stopWhenFound) {
        return value;
      }

      if (!values) {
        values = [];
      }

      values.push(value);
    }

    if (++loopCount > LOOP_LIMIT) {
      (0, _util.warn)("getInheritableProperty: maximum loop count exceeded for \"".concat(key, "\""));
      break;
    }

    dict = dict.get("Parent");
  }

  return values;
}

var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

function toRomanNumerals(number) {
  var lowerCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  (0, _util.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
  var romanBuf = [];
  var pos;

  while (number >= 1000) {
    number -= 1000;
    romanBuf.push("M");
  }

  pos = number / 100 | 0;
  number %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = number / 10 | 0;
  number %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
  var romanStr = romanBuf.join("");
  return lowerCase ? romanStr.toLowerCase() : romanStr;
}

function log2(x) {
  if (x <= 0) {
    return 0;
  }

  return Math.ceil(Math.log2(x));
}

function readInt8(data, offset) {
  return data[offset] << 24 >> 24;
}

function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}

function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}

function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}

function parseXFAPath(path) {
  var positionPattern = /(.+)\[([0-9]+)\]$/;
  return path.split(".").map(function (component) {
    var m = component.match(positionPattern);

    if (m) {
      return {
        name: m[1],
        pos: parseInt(m[2], 10)
      };
    }

    return {
      name: component,
      pos: 0
    };
  });
}

function escapePDFName(str) {
  var buffer = [];
  var start = 0;

  for (var i = 0, ii = str.length; i < ii; i++) {
    var _char = str.charCodeAt(i);

    if (_char < 0x21 || _char > 0x7e || _char === 0x23 || _char === 0x28 || _char === 0x29 || _char === 0x3c || _char === 0x3e || _char === 0x5b || _char === 0x5d || _char === 0x7b || _char === 0x7d || _char === 0x2f || _char === 0x25) {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }

      buffer.push("#".concat(_char.toString(16)));
      start = i + 1;
    }
  }

  if (buffer.length === 0) {
    return str;
  }

  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }

  return buffer.join("");
}

function _collectJS(entry, xref, list, parents) {
  if (!entry) {
    return;
  }

  var parent = null;

  if ((0, _primitives.isRef)(entry)) {
    if (parents.has(entry)) {
      return;
    }

    parent = entry;
    parents.put(parent);
    entry = xref.fetch(entry);
  }

  if (Array.isArray(entry)) {
    var _iterator = _createForOfIteratorHelper(entry),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;

        _collectJS(element, xref, list, parents);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (entry instanceof _primitives.Dict) {
    if ((0, _primitives.isName)(entry.get("S"), "JavaScript") && entry.has("JS")) {
      var js = entry.get("JS");
      var code;

      if ((0, _primitives.isStream)(js)) {
        code = (0, _util.bytesToString)(js.getBytes());
      } else {
        code = js;
      }

      code = (0, _util.stringToPDFString)(code);

      if (code) {
        list.push(code);
      }
    }

    _collectJS(entry.getRaw("Next"), xref, list, parents);
  }

  if (parent) {
    parents.remove(parent);
  }
}

function collectActions(xref, dict, eventType) {
  var actions = Object.create(null);

  if (dict.has("AA")) {
    var additionalActions = dict.get("AA");

    var _iterator2 = _createForOfIteratorHelper(additionalActions.getKeys()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var key = _step2.value;
        var action = eventType[key];

        if (!action) {
          continue;
        }

        var actionDict = additionalActions.getRaw(key);
        var parents = new _primitives.RefSet();
        var list = [];

        _collectJS(actionDict, xref, list, parents);

        if (list.length > 0) {
          actions[action] = list;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  if (dict.has("A")) {
    var _actionDict = dict.get("A");

    var _parents = new _primitives.RefSet();

    var _list = [];

    _collectJS(_actionDict, xref, _list, _parents);

    if (_list.length > 0) {
      actions.Action = _list;
    }
  }

  return (0, _util.objectSize)(actions) > 0 ? actions : null;
}

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDocument = exports.Page = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _obj = __w_pdfjs_require__(140);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

var _stream = __w_pdfjs_require__(142);

var _annotation = __w_pdfjs_require__(155);

var _crypto = __w_pdfjs_require__(152);

var _parser = __w_pdfjs_require__(141);

var _operator_list = __w_pdfjs_require__(174);

var _evaluator = __w_pdfjs_require__(157);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULT_USER_UNIT = 1.0;
var LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];

function isAnnotationRenderable(annotation, intent) {
  return intent === "display" && annotation.viewable || intent === "print" && annotation.printable;
}

var Page = /*#__PURE__*/function () {
  function Page(_ref) {
    var pdfManager = _ref.pdfManager,
        xref = _ref.xref,
        pageIndex = _ref.pageIndex,
        pageDict = _ref.pageDict,
        ref = _ref.ref,
        globalIdFactory = _ref.globalIdFactory,
        fontCache = _ref.fontCache,
        builtInCMapCache = _ref.builtInCMapCache,
        globalImageCache = _ref.globalImageCache,
        nonBlendModesSet = _ref.nonBlendModesSet;

    _classCallCheck(this, Page);

    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.globalImageCache = globalImageCache;
    this.nonBlendModesSet = nonBlendModesSet;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    var idCounters = {
      obj: 0
    };

    this._localIdFactory = /*#__PURE__*/function (_globalIdFactory) {
      _inherits(_class, _globalIdFactory);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, null, [{
        key: "createObjId",
        value: function createObjId() {
          return "p".concat(pageIndex, "_").concat(++idCounters.obj);
        }
      }]);

      return _class;
    }(globalIdFactory);
  }

  _createClass(Page, [{
    key: "_getInheritableProperty",
    value: function _getInheritableProperty(key) {
      var getArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var value = (0, _core_utils.getInheritableProperty)({
        dict: this.pageDict,
        key: key,
        getArray: getArray,
        stopWhenFound: false
      });

      if (!Array.isArray(value)) {
        return value;
      }

      if (value.length === 1 || !(0, _primitives.isDict)(value[0])) {
        return value[0];
      }

      return _primitives.Dict.merge({
        xref: this.xref,
        dictArray: value
      });
    }
  }, {
    key: "content",
    get: function get() {
      return this.pageDict.get("Contents");
    }
  }, {
    key: "resources",
    get: function get() {
      return (0, _util.shadow)(this, "resources", this._getInheritableProperty("Resources") || _primitives.Dict.empty);
    }
  }, {
    key: "_getBoundingBox",
    value: function _getBoundingBox(name) {
      var box = this._getInheritableProperty(name, true);

      if (Array.isArray(box) && box.length === 4) {
        if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
          return box;
        }

        (0, _util.warn)("Empty /".concat(name, " entry."));
      }

      return null;
    }
  }, {
    key: "mediaBox",
    get: function get() {
      return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
    }
  }, {
    key: "cropBox",
    get: function get() {
      return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
    }
  }, {
    key: "userUnit",
    get: function get() {
      var obj = this.pageDict.get("UserUnit");

      if (!(0, _util.isNum)(obj) || obj <= 0) {
        obj = DEFAULT_USER_UNIT;
      }

      return (0, _util.shadow)(this, "userUnit", obj);
    }
  }, {
    key: "view",
    get: function get() {
      var cropBox = this.cropBox,
          mediaBox = this.mediaBox;
      var view;

      if (cropBox === mediaBox || (0, _util.isArrayEqual)(cropBox, mediaBox)) {
        view = mediaBox;
      } else {
        var box = _util.Util.intersect(cropBox, mediaBox);

        if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
          view = box;
        } else {
          (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
        }
      }

      return (0, _util.shadow)(this, "view", view || mediaBox);
    }
  }, {
    key: "rotate",
    get: function get() {
      var rotate = this._getInheritableProperty("Rotate") || 0;

      if (rotate % 90 !== 0) {
        rotate = 0;
      } else if (rotate >= 360) {
        rotate = rotate % 360;
      } else if (rotate < 0) {
        rotate = (rotate % 360 + 360) % 360;
      }

      return (0, _util.shadow)(this, "rotate", rotate);
    }
  }, {
    key: "getContentStream",
    value: function getContentStream() {
      var content = this.content;
      var stream;

      if (Array.isArray(content)) {
        var xref = this.xref;
        var streams = [];

        var _iterator = _createForOfIteratorHelper(content),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var subStream = _step.value;
            streams.push(xref.fetchIfRef(subStream));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        stream = new _stream.StreamsSequenceStream(streams);
      } else if ((0, _primitives.isStream)(content)) {
        stream = content;
      } else {
        stream = new _stream.NullStream();
      }

      return stream;
    }
  }, {
    key: "save",
    value: function save(handler, task, annotationStorage) {
      var partialEvaluator = new _evaluator.PartialEvaluator({
        xref: this.xref,
        handler: handler,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        globalImageCache: this.globalImageCache,
        options: this.evaluatorOptions
      });
      return this._parsedAnnotations.then(function (annotations) {
        var newRefsPromises = [];

        var _iterator2 = _createForOfIteratorHelper(annotations),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var annotation = _step2.value;

            if (!isAnnotationRenderable(annotation, "print")) {
              continue;
            }

            newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage)["catch"](function (reason) {
              (0, _util.warn)("save - ignoring annotation data during " + "\"".concat(task.name, "\" task: \"").concat(reason, "\"."));
              return null;
            }));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return Promise.all(newRefsPromises);
      });
    }
  }, {
    key: "loadResources",
    value: function loadResources(keys) {
      var _this = this;

      if (!this.resourcesPromise) {
        this.resourcesPromise = this.pdfManager.ensure(this, "resources");
      }

      return this.resourcesPromise.then(function () {
        var objectLoader = new _obj.ObjectLoader(_this.resources, keys, _this.xref);
        return objectLoader.load();
      });
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList(_ref2) {
      var _this2 = this;

      var handler = _ref2.handler,
          sink = _ref2.sink,
          task = _ref2.task,
          intent = _ref2.intent,
          renderInteractiveForms = _ref2.renderInteractiveForms,
          annotationStorage = _ref2.annotationStorage;
      var contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
      var resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
      var partialEvaluator = new _evaluator.PartialEvaluator({
        xref: this.xref,
        handler: handler,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        globalImageCache: this.globalImageCache,
        options: this.evaluatorOptions
      });
      var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
      var pageListPromise = dataPromises.then(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
            contentStream = _ref4[0];

        var opList = new _operator_list.OperatorList(intent, sink);
        handler.send("StartRenderPage", {
          transparency: partialEvaluator.hasBlendModes(_this2.resources, _this2.nonBlendModesSet),
          pageIndex: _this2.pageIndex,
          intent: intent
        });
        return partialEvaluator.getOperatorList({
          stream: contentStream,
          task: task,
          resources: _this2.resources,
          operatorList: opList
        }).then(function () {
          return opList;
        });
      });
      return Promise.all([pageListPromise, this._parsedAnnotations]).then(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            pageOpList = _ref6[0],
            annotations = _ref6[1];

        if (annotations.length === 0) {
          pageOpList.flush(true);
          return {
            length: pageOpList.totalLength
          };
        }

        var opListPromises = [];

        var _iterator3 = _createForOfIteratorHelper(annotations),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var annotation = _step3.value;

            if (isAnnotationRenderable(annotation, intent) && !annotation.isHidden(annotationStorage)) {
              opListPromises.push(annotation.getOperatorList(partialEvaluator, task, renderInteractiveForms, annotationStorage)["catch"](function (reason) {
                (0, _util.warn)("getOperatorList - ignoring annotation data during " + "\"".concat(task.name, "\" task: \"").concat(reason, "\"."));
                return null;
              }));
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return Promise.all(opListPromises).then(function (opLists) {
          pageOpList.addOp(_util.OPS.beginAnnotations, []);

          var _iterator4 = _createForOfIteratorHelper(opLists),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var opList = _step4.value;
              pageOpList.addOpList(opList);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          pageOpList.addOp(_util.OPS.endAnnotations, []);
          pageOpList.flush(true);
          return {
            length: pageOpList.totalLength
          };
        });
      });
    }
  }, {
    key: "extractTextContent",
    value: function extractTextContent(_ref7) {
      var _this3 = this;

      var handler = _ref7.handler,
          task = _ref7.task,
          normalizeWhitespace = _ref7.normalizeWhitespace,
          sink = _ref7.sink,
          combineTextItems = _ref7.combineTextItems;
      var contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
      var resourcesPromise = this.loadResources(["ExtGState", "XObject", "Font"]);
      var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
      return dataPromises.then(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 1),
            contentStream = _ref9[0];

        var partialEvaluator = new _evaluator.PartialEvaluator({
          xref: _this3.xref,
          handler: handler,
          pageIndex: _this3.pageIndex,
          idFactory: _this3._localIdFactory,
          fontCache: _this3.fontCache,
          builtInCMapCache: _this3.builtInCMapCache,
          globalImageCache: _this3.globalImageCache,
          options: _this3.evaluatorOptions
        });
        return partialEvaluator.getTextContent({
          stream: contentStream,
          task: task,
          resources: _this3.resources,
          normalizeWhitespace: normalizeWhitespace,
          combineTextItems: combineTextItems,
          sink: sink
        });
      });
    }
  }, {
    key: "getAnnotationsData",
    value: function getAnnotationsData(intent) {
      return this._parsedAnnotations.then(function (annotations) {
        var annotationsData = [];

        for (var i = 0, ii = annotations.length; i < ii; i++) {
          if (!intent || isAnnotationRenderable(annotations[i], intent)) {
            annotationsData.push(annotations[i].data);
          }
        }

        return annotationsData;
      });
    }
  }, {
    key: "annotations",
    get: function get() {
      var annots = this._getInheritableProperty("Annots");

      return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
    }
  }, {
    key: "_parsedAnnotations",
    get: function get() {
      var _this4 = this;

      var parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(function () {
        var annotationPromises = [];

        var _iterator5 = _createForOfIteratorHelper(_this4.annotations),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var annotationRef = _step5.value;
            annotationPromises.push(_annotation.AnnotationFactory.create(_this4.xref, annotationRef, _this4.pdfManager, _this4._localIdFactory)["catch"](function (reason) {
              (0, _util.warn)("_parsedAnnotations: \"".concat(reason, "\"."));
              return null;
            }));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return Promise.all(annotationPromises).then(function (annotations) {
          return annotations.filter(function (annotation) {
            return !!annotation;
          });
        });
      });
      return (0, _util.shadow)(this, "_parsedAnnotations", parsedAnnotations);
    }
  }, {
    key: "jsActions",
    get: function get() {
      var actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
      return (0, _util.shadow)(this, "jsActions", actions);
    }
  }]);

  return Page;
}();

exports.Page = Page;
var PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
var STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
var ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
var FINGERPRINT_FIRST_BYTES = 1024;
var EMPTY_FINGERPRINT = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
var PDF_HEADER_VERSION_REGEXP = /^[1-9]\.[0-9]$/;

function find(stream, signature) {
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;
  var backwards = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var signatureLength = signature.length;
  var scanBytes = stream.peekBytes(limit);
  var scanLength = scanBytes.length - signatureLength;

  if (scanLength <= 0) {
    return false;
  }

  if (backwards) {
    var signatureEnd = signatureLength - 1;
    var pos = scanBytes.length - 1;

    while (pos >= signatureEnd) {
      var j = 0;

      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
        j++;
      }

      if (j >= signatureLength) {
        stream.pos += pos - signatureEnd;
        return true;
      }

      pos--;
    }
  } else {
    var _pos = 0;

    while (_pos <= scanLength) {
      var _j = 0;

      while (_j < signatureLength && scanBytes[_pos + _j] === signature[_j]) {
        _j++;
      }

      if (_j >= signatureLength) {
        stream.pos += _pos;
        return true;
      }

      _pos++;
    }
  }

  return false;
}

var PDFDocument = /*#__PURE__*/function () {
  function PDFDocument(pdfManager, arg) {
    _classCallCheck(this, PDFDocument);

    var stream;

    if ((0, _primitives.isStream)(arg)) {
      stream = arg;
    } else if ((0, _util.isArrayBuffer)(arg)) {
      stream = new _stream.Stream(arg);
    } else {
      throw new Error("PDFDocument: Unknown argument type");
    }

    if (stream.length <= 0) {
      throw new _util.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    }

    this.pdfManager = pdfManager;
    this.stream = stream;
    this.xref = new _obj.XRef(stream, pdfManager);
    this._pagePromises = [];
    this._version = null;
    var idCounters = {
      font: 0
    };

    this._globalIdFactory = /*#__PURE__*/function () {
      function _class2() {
        _classCallCheck(this, _class2);
      }

      _createClass(_class2, null, [{
        key: "getDocId",
        value: function getDocId() {
          return "g_".concat(pdfManager.docId);
        }
      }, {
        key: "createFontId",
        value: function createFontId() {
          return "f".concat(++idCounters.font);
        }
      }, {
        key: "createObjId",
        value: function createObjId() {
          (0, _util.unreachable)("Abstract method `createObjId` called.");
        }
      }]);

      return _class2;
    }();
  }

  _createClass(PDFDocument, [{
    key: "parse",
    value: function parse(recoveryMode) {
      this.xref.parse(recoveryMode);
      this.catalog = new _obj.Catalog(this.pdfManager, this.xref);

      if (this.catalog.version) {
        this._version = this.catalog.version;
      }
    }
  }, {
    key: "linearization",
    get: function get() {
      var linearization = null;

      try {
        linearization = _parser.Linearization.create(this.stream);
      } catch (err) {
        if (err instanceof _core_utils.MissingDataException) {
          throw err;
        }

        (0, _util.info)(err);
      }

      return (0, _util.shadow)(this, "linearization", linearization);
    }
  }, {
    key: "startXRef",
    get: function get() {
      var stream = this.stream;
      var startXRef = 0;

      if (this.linearization) {
        stream.reset();

        if (find(stream, ENDOBJ_SIGNATURE)) {
          startXRef = stream.pos + 6 - stream.start;
        }
      } else {
        var step = 1024;
        var startXRefLength = STARTXREF_SIGNATURE.length;
        var found = false,
            pos = stream.end;

        while (!found && pos > 0) {
          pos -= step - startXRefLength;

          if (pos < 0) {
            pos = 0;
          }

          stream.pos = pos;
          found = find(stream, STARTXREF_SIGNATURE, step, true);
        }

        if (found) {
          stream.skip(9);
          var ch;

          do {
            ch = stream.getByte();
          } while ((0, _core_utils.isWhiteSpace)(ch));

          var str = "";

          while (ch >= 0x20 && ch <= 0x39) {
            str += String.fromCharCode(ch);
            ch = stream.getByte();
          }

          startXRef = parseInt(str, 10);

          if (isNaN(startXRef)) {
            startXRef = 0;
          }
        }
      }

      return (0, _util.shadow)(this, "startXRef", startXRef);
    }
  }, {
    key: "checkHeader",
    value: function checkHeader() {
      var stream = this.stream;
      stream.reset();

      if (!find(stream, PDF_HEADER_SIGNATURE)) {
        return;
      }

      stream.moveStart();
      var MAX_PDF_VERSION_LENGTH = 12;
      var version = "",
          ch;

      while ((ch = stream.getByte()) > 0x20) {
        if (version.length >= MAX_PDF_VERSION_LENGTH) {
          break;
        }

        version += String.fromCharCode(ch);
      }

      if (!this._version) {
        this._version = version.substring(5);
      }
    }
  }, {
    key: "parseStartXRef",
    value: function parseStartXRef() {
      this.xref.setStartXRef(this.startXRef);
    }
  }, {
    key: "numPages",
    get: function get() {
      var linearization = this.linearization;
      var num = linearization ? linearization.numPages : this.catalog.numPages;
      return (0, _util.shadow)(this, "numPages", num);
    }
  }, {
    key: "_hasOnlyDocumentSignatures",
    value: function _hasOnlyDocumentSignatures(fields) {
      var _this5 = this;

      var recursionDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var RECURSION_LIMIT = 10;

      if (!Array.isArray(fields)) {
        return false;
      }

      return fields.every(function (field) {
        field = _this5.xref.fetchIfRef(field);

        if (!(field instanceof _primitives.Dict)) {
          return false;
        }

        if (field.has("Kids")) {
          if (++recursionDepth > RECURSION_LIMIT) {
            (0, _util.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
            return false;
          }

          return _this5._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
        }

        var isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
        var rectangle = field.get("Rect");
        var isInvisible = Array.isArray(rectangle) && rectangle.every(function (value) {
          return value === 0;
        });
        return isSignature && isInvisible;
      });
    }
  }, {
    key: "formInfo",
    get: function get() {
      var formInfo = {
        hasFields: false,
        hasAcroForm: false,
        hasXfa: false
      };
      var acroForm = this.catalog.acroForm;

      if (!acroForm) {
        return (0, _util.shadow)(this, "formInfo", formInfo);
      }

      try {
        var fields = acroForm.get("Fields");
        var hasFields = Array.isArray(fields) && fields.length > 0;
        formInfo.hasFields = hasFields;
        var xfa = acroForm.get("XFA");
        formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || (0, _primitives.isStream)(xfa) && !xfa.isEmpty;
        var sigFlags = acroForm.get("SigFlags");

        var hasOnlyDocumentSignatures = !!(sigFlags & 0x1) && this._hasOnlyDocumentSignatures(fields);

        formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Cannot fetch form information: \"".concat(ex, "\"."));
      }

      return (0, _util.shadow)(this, "formInfo", formInfo);
    }
  }, {
    key: "documentInfo",
    get: function get() {
      var DocumentInfoValidators = {
        Title: _util.isString,
        Author: _util.isString,
        Subject: _util.isString,
        Keywords: _util.isString,
        Creator: _util.isString,
        Producer: _util.isString,
        CreationDate: _util.isString,
        ModDate: _util.isString,
        Trapped: _primitives.isName
      };
      var version = this._version;

      if (typeof version !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version)) {
        (0, _util.warn)("Invalid PDF header version number: ".concat(version));
        version = null;
      }

      var docInfo = {
        PDFFormatVersion: version,
        IsLinearized: !!this.linearization,
        IsAcroFormPresent: this.formInfo.hasAcroForm,
        IsXFAPresent: this.formInfo.hasXfa,
        IsCollectionPresent: !!this.catalog.collection
      };
      var infoDict;

      try {
        infoDict = this.xref.trailer.get("Info");
      } catch (err) {
        if (err instanceof _core_utils.MissingDataException) {
          throw err;
        }

        (0, _util.info)("The document information dictionary is invalid.");
      }

      if ((0, _primitives.isDict)(infoDict)) {
        var _iterator6 = _createForOfIteratorHelper(infoDict.getKeys()),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var key = _step6.value;
            var value = infoDict.get(key);

            if (DocumentInfoValidators[key]) {
              if (DocumentInfoValidators[key](value)) {
                docInfo[key] = typeof value !== "string" ? value : (0, _util.stringToPDFString)(value);
              } else {
                (0, _util.info)("Bad value in document info for \"".concat(key, "\"."));
              }
            } else if (typeof key === "string") {
              var customValue = void 0;

              if ((0, _util.isString)(value)) {
                customValue = (0, _util.stringToPDFString)(value);
              } else if ((0, _primitives.isName)(value) || (0, _util.isNum)(value) || (0, _util.isBool)(value)) {
                customValue = value;
              } else {
                (0, _util.info)("Unsupported value in document info for (custom) \"".concat(key, "\"."));
                continue;
              }

              if (!docInfo.Custom) {
                docInfo.Custom = Object.create(null);
              }

              docInfo.Custom[key] = customValue;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }

      return (0, _util.shadow)(this, "documentInfo", docInfo);
    }
  }, {
    key: "fingerprint",
    get: function get() {
      var hash;
      var idArray = this.xref.trailer.get("ID");

      if (Array.isArray(idArray) && idArray[0] && (0, _util.isString)(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
        hash = (0, _util.stringToBytes)(idArray[0]);
      } else {
        hash = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
      }

      var fingerprintBuf = [];

      for (var i = 0, ii = hash.length; i < ii; i++) {
        var hex = hash[i].toString(16);
        fingerprintBuf.push(hex.padStart(2, "0"));
      }

      return (0, _util.shadow)(this, "fingerprint", fingerprintBuf.join(""));
    }
  }, {
    key: "_getLinearizationPage",
    value: function _getLinearizationPage(pageIndex) {
      var catalog = this.catalog,
          linearization = this.linearization;

      var ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);

      return this.xref.fetchAsync(ref).then(function (obj) {
        if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Type") && obj.has("Contents")) {
          if (ref && !catalog.pageKidsCountCache.has(ref)) {
            catalog.pageKidsCountCache.put(ref, 1);
          }

          return [obj, ref];
        }

        throw new _util.FormatError("The Linearization dictionary doesn't point " + "to a valid Page dictionary.");
      })["catch"](function (reason) {
        (0, _util.info)(reason);
        return catalog.getPageDict(pageIndex);
      });
    }
  }, {
    key: "getPage",
    value: function getPage(pageIndex) {
      var _this6 = this;

      if (this._pagePromises[pageIndex] !== undefined) {
        return this._pagePromises[pageIndex];
      }

      var catalog = this.catalog,
          linearization = this.linearization;
      var promise = linearization && linearization.pageFirst === pageIndex ? this._getLinearizationPage(pageIndex) : catalog.getPageDict(pageIndex);
      return this._pagePromises[pageIndex] = promise.then(function (_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2),
            pageDict = _ref11[0],
            ref = _ref11[1];

        return new Page({
          pdfManager: _this6.pdfManager,
          xref: _this6.xref,
          pageIndex: pageIndex,
          pageDict: pageDict,
          ref: ref,
          globalIdFactory: _this6._globalIdFactory,
          fontCache: catalog.fontCache,
          builtInCMapCache: catalog.builtInCMapCache,
          globalImageCache: catalog.globalImageCache,
          nonBlendModesSet: catalog.nonBlendModesSet
        });
      });
    }
  }, {
    key: "checkFirstPage",
    value: function checkFirstPage() {
      var _this7 = this;

      return this.getPage(0)["catch"]( /*#__PURE__*/function () {
        var _ref12 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(reason) {
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(reason instanceof _core_utils.XRefEntryException)) {
                    _context.next = 5;
                    break;
                  }

                  _this7._pagePromises.length = 0;
                  _context.next = 4;
                  return _this7.cleanup();

                case 4:
                  throw new _core_utils.XRefParseException();

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref12.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(id, handler) {
      return this.catalog.fontFallback(id, handler);
    }
  }, {
    key: "cleanup",
    value: function () {
      var _cleanup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var manuallyTriggered,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                manuallyTriggered = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;
                return _context2.abrupt("return", this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _primitives.clearPrimitiveCaches)());

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function cleanup() {
        return _cleanup.apply(this, arguments);
      }

      return cleanup;
    }()
  }, {
    key: "_collectFieldObjects",
    value: function _collectFieldObjects(name, fieldRef, promises) {
      var field = this.xref.fetchIfRef(fieldRef);

      if (field.has("T")) {
        var partName = (0, _util.stringToPDFString)(field.get("T"));

        if (name === "") {
          name = partName;
        } else {
          name = "".concat(name, ".").concat(partName);
        }
      }

      if (!promises.has(name)) {
        promises.set(name, []);
      }

      promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, this.pdfManager, this._localIdFactory).then(function (annotation) {
        return annotation && annotation.getFieldObject();
      })["catch"](function (reason) {
        (0, _util.warn)("_collectFieldObjects: \"".concat(reason, "\"."));
        return null;
      }));

      if (field.has("Kids")) {
        var kids = field.get("Kids");

        var _iterator7 = _createForOfIteratorHelper(kids),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var kid = _step7.value;

            this._collectFieldObjects(name, kid, promises);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      }
    }
  }, {
    key: "fieldObjects",
    get: function get() {
      if (!this.formInfo.hasFields) {
        return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
      }

      var allFields = Object.create(null);
      var fieldPromises = new Map();

      var _iterator8 = _createForOfIteratorHelper(this.catalog.acroForm.get("Fields")),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var fieldRef = _step8.value;

          this._collectFieldObjects("", fieldRef, fieldPromises);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      var allPromises = [];

      var _iterator9 = _createForOfIteratorHelper(fieldPromises),
          _step9;

      try {
        var _loop = function _loop() {
          var _step9$value = _slicedToArray(_step9.value, 2),
              name = _step9$value[0],
              promises = _step9$value[1];

          allPromises.push(Promise.all(promises).then(function (fields) {
            fields = fields.filter(function (field) {
              return !!field;
            });

            if (fields.length > 0) {
              allFields[name] = fields;
            }
          }));
        };

        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      return (0, _util.shadow)(this, "fieldObjects", Promise.all(allPromises).then(function () {
        return allFields;
      }));
    }
  }, {
    key: "hasJSActions",
    get: function get() {
      var _this8 = this;

      return (0, _util.shadow)(this, "hasJSActions", this.fieldObjects.then(function (fieldObjects) {
        return fieldObjects !== null && Object.values(fieldObjects).some(function (fieldObject) {
          return fieldObject.some(function (object) {
            return object.actions !== null;
          });
        }) || !!_this8.catalog.jsActions;
      }));
    }
  }, {
    key: "calculationOrderIds",
    get: function get() {
      var acroForm = this.catalog.acroForm;

      if (!acroForm || !acroForm.has("CO")) {
        return (0, _util.shadow)(this, "calculationOrderIds", null);
      }

      var calculationOrder = acroForm.get("CO");

      if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
        return (0, _util.shadow)(this, "calculationOrderIds", null);
      }

      var ids = calculationOrder.filter(_primitives.isRef).map(function (ref) {
        return ref.toString();
      });

      if (ids.length === 0) {
        return (0, _util.shadow)(this, "calculationOrderIds", null);
      }

      return (0, _util.shadow)(this, "calculationOrderIds", ids);
    }
  }]);

  return PDFDocument;
}();

exports.PDFDocument = PDFDocument;

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRef = exports.ObjectLoader = exports.FileSpec = exports.Catalog = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

var _parser = __w_pdfjs_require__(141);

var _crypto = __w_pdfjs_require__(152);

var _colorspace = __w_pdfjs_require__(153);

var _image_utils = __w_pdfjs_require__(154);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function fetchDestination(dest) {
  return (0, _primitives.isDict)(dest) ? dest.get("D") : dest;
}

var Catalog = /*#__PURE__*/function () {
  function Catalog(pdfManager, xref) {
    _classCallCheck(this, Catalog);

    this.pdfManager = pdfManager;
    this.xref = xref;
    this._catDict = xref.getCatalogObj();

    if (!(0, _primitives.isDict)(this._catDict)) {
      throw new _util.FormatError("Catalog object is not a dictionary.");
    }

    this.fontCache = new _primitives.RefSetCache();
    this.builtInCMapCache = new Map();
    this.globalImageCache = new _image_utils.GlobalImageCache();
    this.pageKidsCountCache = new _primitives.RefSetCache();
    this.nonBlendModesSet = new _primitives.RefSet();
  }

  _createClass(Catalog, [{
    key: "version",
    get: function get() {
      var version = this._catDict.get("Version");

      if (!(0, _primitives.isName)(version)) {
        return (0, _util.shadow)(this, "version", null);
      }

      return (0, _util.shadow)(this, "version", version.name);
    }
  }, {
    key: "collection",
    get: function get() {
      var collection = null;

      try {
        var obj = this._catDict.get("Collection");

        if ((0, _primitives.isDict)(obj) && obj.size > 0) {
          collection = obj;
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
      }

      return (0, _util.shadow)(this, "collection", collection);
    }
  }, {
    key: "acroForm",
    get: function get() {
      var acroForm = null;

      try {
        var obj = this._catDict.get("AcroForm");

        if ((0, _primitives.isDict)(obj) && obj.size > 0) {
          acroForm = obj;
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
      }

      return (0, _util.shadow)(this, "acroForm", acroForm);
    }
  }, {
    key: "metadata",
    get: function get() {
      var streamRef = this._catDict.getRaw("Metadata");

      if (!(0, _primitives.isRef)(streamRef)) {
        return (0, _util.shadow)(this, "metadata", null);
      }

      var suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
      var stream = this.xref.fetch(streamRef, suppressEncryption);
      var metadata;

      if (stream && (0, _primitives.isDict)(stream.dict)) {
        var type = stream.dict.get("Type");
        var subtype = stream.dict.get("Subtype");

        if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
          try {
            metadata = (0, _util.stringToUTF8String)((0, _util.bytesToString)(stream.getBytes()));
          } catch (e) {
            if (e instanceof _core_utils.MissingDataException) {
              throw e;
            }

            (0, _util.info)("Skipping invalid metadata.");
          }
        }
      }

      return (0, _util.shadow)(this, "metadata", metadata);
    }
  }, {
    key: "markInfo",
    get: function get() {
      var markInfo = null;

      try {
        markInfo = this._readMarkInfo();
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Unable to read mark info.");
      }

      return (0, _util.shadow)(this, "markInfo", markInfo);
    }
  }, {
    key: "_readMarkInfo",
    value: function _readMarkInfo() {
      var obj = this._catDict.get("MarkInfo");

      if (!(0, _primitives.isDict)(obj)) {
        return null;
      }

      var markInfo = Object.assign(Object.create(null), {
        Marked: false,
        UserProperties: false,
        Suspects: false
      });

      for (var key in markInfo) {
        if (!obj.has(key)) {
          continue;
        }

        var value = obj.get(key);

        if (!(0, _util.isBool)(value)) {
          continue;
        }

        markInfo[key] = value;
      }

      return markInfo;
    }
  }, {
    key: "toplevelPagesDict",
    get: function get() {
      var pagesObj = this._catDict.get("Pages");

      if (!(0, _primitives.isDict)(pagesObj)) {
        throw new _util.FormatError("Invalid top-level pages dictionary.");
      }

      return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
    }
  }, {
    key: "documentOutline",
    get: function get() {
      var obj = null;

      try {
        obj = this._readDocumentOutline();
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Unable to read document outline.");
      }

      return (0, _util.shadow)(this, "documentOutline", obj);
    }
  }, {
    key: "_readDocumentOutline",
    value: function _readDocumentOutline() {
      var obj = this._catDict.get("Outlines");

      if (!(0, _primitives.isDict)(obj)) {
        return null;
      }

      obj = obj.getRaw("First");

      if (!(0, _primitives.isRef)(obj)) {
        return null;
      }

      var root = {
        items: []
      };
      var queue = [{
        obj: obj,
        parent: root
      }];
      var processed = new _primitives.RefSet();
      processed.put(obj);
      var xref = this.xref,
          blackColor = new Uint8ClampedArray(3);

      while (queue.length > 0) {
        var i = queue.shift();
        var outlineDict = xref.fetchIfRef(i.obj);

        if (outlineDict === null) {
          continue;
        }

        if (!outlineDict.has("Title")) {
          throw new _util.FormatError("Invalid outline item encountered.");
        }

        var data = {
          url: null,
          dest: null
        };
        Catalog.parseDestDictionary({
          destDict: outlineDict,
          resultObj: data,
          docBaseUrl: this.pdfManager.docBaseUrl
        });
        var title = outlineDict.get("Title");
        var flags = outlineDict.get("F") || 0;
        var color = outlineDict.getArray("C");
        var count = outlineDict.get("Count");
        var rgbColor = blackColor;

        if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
          rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
        }

        var outlineItem = {
          dest: data.dest,
          url: data.url,
          unsafeUrl: data.unsafeUrl,
          newWindow: data.newWindow,
          title: (0, _util.stringToPDFString)(title),
          color: rgbColor,
          count: Number.isInteger(count) ? count : undefined,
          bold: !!(flags & 2),
          italic: !!(flags & 1),
          items: []
        };
        i.parent.items.push(outlineItem);
        obj = outlineDict.getRaw("First");

        if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
          queue.push({
            obj: obj,
            parent: outlineItem
          });
          processed.put(obj);
        }

        obj = outlineDict.getRaw("Next");

        if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
          queue.push({
            obj: obj,
            parent: i.parent
          });
          processed.put(obj);
        }
      }

      return root.items.length > 0 ? root.items : null;
    }
  }, {
    key: "permissions",
    get: function get() {
      var permissions = null;

      try {
        permissions = this._readPermissions();
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Unable to read permissions.");
      }

      return (0, _util.shadow)(this, "permissions", permissions);
    }
  }, {
    key: "_readPermissions",
    value: function _readPermissions() {
      var encrypt = this.xref.trailer.get("Encrypt");

      if (!(0, _primitives.isDict)(encrypt)) {
        return null;
      }

      var flags = encrypt.get("P");

      if (!(0, _util.isNum)(flags)) {
        return null;
      }

      flags += Math.pow(2, 32);
      var permissions = [];

      for (var key in _util.PermissionFlag) {
        var value = _util.PermissionFlag[key];

        if (flags & value) {
          permissions.push(value);
        }
      }

      return permissions;
    }
  }, {
    key: "optionalContentConfig",
    get: function get() {
      var config = null;

      try {
        var properties = this._catDict.get("OCProperties");

        if (!properties) {
          return (0, _util.shadow)(this, "optionalContentConfig", null);
        }

        var defaultConfig = properties.get("D");

        if (!defaultConfig) {
          return (0, _util.shadow)(this, "optionalContentConfig", null);
        }

        var groupsData = properties.get("OCGs");

        if (!Array.isArray(groupsData)) {
          return (0, _util.shadow)(this, "optionalContentConfig", null);
        }

        var groups = [];
        var groupRefs = [];

        var _iterator = _createForOfIteratorHelper(groupsData),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var groupRef = _step.value;

            if (!(0, _primitives.isRef)(groupRef)) {
              continue;
            }

            groupRefs.push(groupRef);
            var group = this.xref.fetchIfRef(groupRef);
            groups.push({
              id: groupRef.toString(),
              name: (0, _util.isString)(group.get("Name")) ? (0, _util.stringToPDFString)(group.get("Name")) : null,
              intent: (0, _util.isString)(group.get("Intent")) ? (0, _util.stringToPDFString)(group.get("Intent")) : null
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        config = this._readOptionalContentConfig(defaultConfig, groupRefs);
        config.groups = groups;
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Unable to read optional content config: ".concat(ex));
      }

      return (0, _util.shadow)(this, "optionalContentConfig", config);
    }
  }, {
    key: "_readOptionalContentConfig",
    value: function _readOptionalContentConfig(config, contentGroupRefs) {
      function parseOnOff(refs) {
        var onParsed = [];

        if (Array.isArray(refs)) {
          var _iterator2 = _createForOfIteratorHelper(refs),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var value = _step2.value;

              if (!(0, _primitives.isRef)(value)) {
                continue;
              }

              if (contentGroupRefs.includes(value)) {
                onParsed.push(value.toString());
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }

        return onParsed;
      }

      function parseOrder(refs) {
        var nestedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (!Array.isArray(refs)) {
          return null;
        }

        var order = [];

        var _iterator3 = _createForOfIteratorHelper(refs),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var value = _step3.value;

            if ((0, _primitives.isRef)(value) && contentGroupRefs.includes(value)) {
              parsedOrderRefs.put(value);
              order.push(value.toString());
              continue;
            }

            var nestedOrder = parseNestedOrder(value, nestedLevels);

            if (nestedOrder) {
              order.push(nestedOrder);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        if (nestedLevels > 0) {
          return order;
        }

        var hiddenGroups = [];

        var _iterator4 = _createForOfIteratorHelper(contentGroupRefs),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var groupRef = _step4.value;

            if (parsedOrderRefs.has(groupRef)) {
              continue;
            }

            hiddenGroups.push(groupRef.toString());
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (hiddenGroups.length) {
          order.push({
            name: null,
            order: hiddenGroups
          });
        }

        return order;
      }

      function parseNestedOrder(ref, nestedLevels) {
        if (++nestedLevels > MAX_NESTED_LEVELS) {
          (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
          return null;
        }

        var value = xref.fetchIfRef(ref);

        if (!Array.isArray(value)) {
          return null;
        }

        var nestedName = xref.fetchIfRef(value[0]);

        if (typeof nestedName !== "string") {
          return null;
        }

        var nestedOrder = parseOrder(value.slice(1), nestedLevels);

        if (!nestedOrder || !nestedOrder.length) {
          return null;
        }

        return {
          name: (0, _util.stringToPDFString)(nestedName),
          order: nestedOrder
        };
      }

      var xref = this.xref,
          parsedOrderRefs = new _primitives.RefSet(),
          MAX_NESTED_LEVELS = 10;
      return {
        name: (0, _util.isString)(config.get("Name")) ? (0, _util.stringToPDFString)(config.get("Name")) : null,
        creator: (0, _util.isString)(config.get("Creator")) ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
        baseState: (0, _primitives.isName)(config.get("BaseState")) ? config.get("BaseState").name : null,
        on: parseOnOff(config.get("ON")),
        off: parseOnOff(config.get("OFF")),
        order: parseOrder(config.get("Order")),
        groups: null
      };
    }
  }, {
    key: "numPages",
    get: function get() {
      var obj = this.toplevelPagesDict.get("Count");

      if (!Number.isInteger(obj)) {
        throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
      }

      return (0, _util.shadow)(this, "numPages", obj);
    }
  }, {
    key: "destinations",
    get: function get() {
      var obj = this._readDests(),
          dests = Object.create(null);

      if (obj instanceof NameTree) {
        var names = obj.getAll();

        for (var name in names) {
          dests[name] = fetchDestination(names[name]);
        }
      } else if (obj instanceof _primitives.Dict) {
        obj.forEach(function (key, value) {
          if (value) {
            dests[key] = fetchDestination(value);
          }
        });
      }

      return (0, _util.shadow)(this, "destinations", dests);
    }
  }, {
    key: "getDestination",
    value: function getDestination(destinationId) {
      var obj = this._readDests();

      if (obj instanceof NameTree || obj instanceof _primitives.Dict) {
        return fetchDestination(obj.get(destinationId) || null);
      }

      return null;
    }
  }, {
    key: "_readDests",
    value: function _readDests() {
      var obj = this._catDict.get("Names");

      if (obj && obj.has("Dests")) {
        return new NameTree(obj.getRaw("Dests"), this.xref);
      } else if (this._catDict.has("Dests")) {
        return this._catDict.get("Dests");
      }

      return undefined;
    }
  }, {
    key: "pageLabels",
    get: function get() {
      var obj = null;

      try {
        obj = this._readPageLabels();
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Unable to read page labels.");
      }

      return (0, _util.shadow)(this, "pageLabels", obj);
    }
  }, {
    key: "_readPageLabels",
    value: function _readPageLabels() {
      var obj = this._catDict.getRaw("PageLabels");

      if (!obj) {
        return null;
      }

      var pageLabels = new Array(this.numPages);
      var style = null,
          prefix = "";
      var numberTree = new NumberTree(obj, this.xref);
      var nums = numberTree.getAll();
      var currentLabel = "",
          currentIndex = 1;

      for (var i = 0, ii = this.numPages; i < ii; i++) {
        if (i in nums) {
          var labelDict = nums[i];

          if (!(0, _primitives.isDict)(labelDict)) {
            throw new _util.FormatError("PageLabel is not a dictionary.");
          }

          if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
            throw new _util.FormatError("Invalid type in PageLabel dictionary.");
          }

          if (labelDict.has("S")) {
            var s = labelDict.get("S");

            if (!(0, _primitives.isName)(s)) {
              throw new _util.FormatError("Invalid style in PageLabel dictionary.");
            }

            style = s.name;
          } else {
            style = null;
          }

          if (labelDict.has("P")) {
            var p = labelDict.get("P");

            if (!(0, _util.isString)(p)) {
              throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
            }

            prefix = (0, _util.stringToPDFString)(p);
          } else {
            prefix = "";
          }

          if (labelDict.has("St")) {
            var st = labelDict.get("St");

            if (!(Number.isInteger(st) && st >= 1)) {
              throw new _util.FormatError("Invalid start in PageLabel dictionary.");
            }

            currentIndex = st;
          } else {
            currentIndex = 1;
          }
        }

        switch (style) {
          case "D":
            currentLabel = currentIndex;
            break;

          case "R":
          case "r":
            currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
            break;

          case "A":
          case "a":
            var LIMIT = 26;
            var A_UPPER_CASE = 0x41,
                A_LOWER_CASE = 0x61;
            var baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
            var letterIndex = currentIndex - 1;
            var character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
            var charBuf = [];

            for (var j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
              charBuf.push(character);
            }

            currentLabel = charBuf.join("");
            break;

          default:
            if (style) {
              throw new _util.FormatError("Invalid style \"".concat(style, "\" in PageLabel dictionary."));
            }

            currentLabel = "";
        }

        pageLabels[i] = prefix + currentLabel;
        currentIndex++;
      }

      return pageLabels;
    }
  }, {
    key: "pageLayout",
    get: function get() {
      var obj = this._catDict.get("PageLayout");

      var pageLayout = "";

      if ((0, _primitives.isName)(obj)) {
        switch (obj.name) {
          case "SinglePage":
          case "OneColumn":
          case "TwoColumnLeft":
          case "TwoColumnRight":
          case "TwoPageLeft":
          case "TwoPageRight":
            pageLayout = obj.name;
        }
      }

      return (0, _util.shadow)(this, "pageLayout", pageLayout);
    }
  }, {
    key: "pageMode",
    get: function get() {
      var obj = this._catDict.get("PageMode");

      var pageMode = "UseNone";

      if ((0, _primitives.isName)(obj)) {
        switch (obj.name) {
          case "UseNone":
          case "UseOutlines":
          case "UseThumbs":
          case "FullScreen":
          case "UseOC":
          case "UseAttachments":
            pageMode = obj.name;
        }
      }

      return (0, _util.shadow)(this, "pageMode", pageMode);
    }
  }, {
    key: "viewerPreferences",
    get: function get() {
      var _this = this;

      var ViewerPreferencesValidators = {
        HideToolbar: _util.isBool,
        HideMenubar: _util.isBool,
        HideWindowUI: _util.isBool,
        FitWindow: _util.isBool,
        CenterWindow: _util.isBool,
        DisplayDocTitle: _util.isBool,
        NonFullScreenPageMode: _primitives.isName,
        Direction: _primitives.isName,
        ViewArea: _primitives.isName,
        ViewClip: _primitives.isName,
        PrintArea: _primitives.isName,
        PrintClip: _primitives.isName,
        PrintScaling: _primitives.isName,
        Duplex: _primitives.isName,
        PickTrayByPDFSize: _util.isBool,
        PrintPageRange: Array.isArray,
        NumCopies: Number.isInteger
      };

      var obj = this._catDict.get("ViewerPreferences");

      var prefs = null;

      if ((0, _primitives.isDict)(obj)) {
        for (var key in ViewerPreferencesValidators) {
          if (!obj.has(key)) {
            continue;
          }

          var value = obj.get(key);

          if (!ViewerPreferencesValidators[key](value)) {
            (0, _util.info)("Bad value in ViewerPreferences for \"".concat(key, "\"."));
            continue;
          }

          var prefValue = void 0;

          switch (key) {
            case "NonFullScreenPageMode":
              switch (value.name) {
                case "UseNone":
                case "UseOutlines":
                case "UseThumbs":
                case "UseOC":
                  prefValue = value.name;
                  break;

                default:
                  prefValue = "UseNone";
              }

              break;

            case "Direction":
              switch (value.name) {
                case "L2R":
                case "R2L":
                  prefValue = value.name;
                  break;

                default:
                  prefValue = "L2R";
              }

              break;

            case "ViewArea":
            case "ViewClip":
            case "PrintArea":
            case "PrintClip":
              switch (value.name) {
                case "MediaBox":
                case "CropBox":
                case "BleedBox":
                case "TrimBox":
                case "ArtBox":
                  prefValue = value.name;
                  break;

                default:
                  prefValue = "CropBox";
              }

              break;

            case "PrintScaling":
              switch (value.name) {
                case "None":
                case "AppDefault":
                  prefValue = value.name;
                  break;

                default:
                  prefValue = "AppDefault";
              }

              break;

            case "Duplex":
              switch (value.name) {
                case "Simplex":
                case "DuplexFlipShortEdge":
                case "DuplexFlipLongEdge":
                  prefValue = value.name;
                  break;

                default:
                  prefValue = "None";
              }

              break;

            case "PrintPageRange":
              var length = value.length;

              if (length % 2 !== 0) {
                break;
              }

              var isValid = value.every(function (page, i, arr) {
                return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= _this.numPages;
              });

              if (isValid) {
                prefValue = value;
              }

              break;

            case "NumCopies":
              if (value > 0) {
                prefValue = value;
              }

              break;

            default:
              if (typeof value !== "boolean") {
                throw new _util.FormatError("viewerPreferences - expected a boolean value for: ".concat(key));
              }

              prefValue = value;
          }

          if (prefValue !== undefined) {
            if (!prefs) {
              prefs = Object.create(null);
            }

            prefs[key] = prefValue;
          } else {
            (0, _util.info)("Bad value in ViewerPreferences for \"".concat(key, "\"."));
          }
        }
      }

      return (0, _util.shadow)(this, "viewerPreferences", prefs);
    }
  }, {
    key: "openAction",
    get: function get() {
      var obj = this._catDict.get("OpenAction");

      var openAction = Object.create(null);

      if ((0, _primitives.isDict)(obj)) {
        var destDict = new _primitives.Dict(this.xref);
        destDict.set("A", obj);
        var resultObj = {
          url: null,
          dest: null,
          action: null
        };
        Catalog.parseDestDictionary({
          destDict: destDict,
          resultObj: resultObj
        });

        if (Array.isArray(resultObj.dest)) {
          openAction.dest = resultObj.dest;
        } else if (resultObj.action) {
          openAction.action = resultObj.action;
        }
      } else if (Array.isArray(obj)) {
        openAction.dest = obj;
      }

      return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
    }
  }, {
    key: "attachments",
    get: function get() {
      var obj = this._catDict.get("Names");

      var attachments = null;

      if (obj && obj.has("EmbeddedFiles")) {
        var nameTree = new NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
        var names = nameTree.getAll();

        for (var name in names) {
          var fs = new FileSpec(names[name], this.xref);

          if (!attachments) {
            attachments = Object.create(null);
          }

          attachments[(0, _util.stringToPDFString)(name)] = fs.serializable;
        }
      }

      return (0, _util.shadow)(this, "attachments", attachments);
    }
  }, {
    key: "_collectJavaScript",
    value: function _collectJavaScript() {
      var obj = this._catDict.get("Names");

      var javaScript = null;

      function appendIfJavaScriptDict(name, jsDict) {
        var type = jsDict.get("S");

        if (!(0, _primitives.isName)(type, "JavaScript")) {
          return;
        }

        var js = jsDict.get("JS");

        if ((0, _primitives.isStream)(js)) {
          js = (0, _util.bytesToString)(js.getBytes());
        } else if (!(0, _util.isString)(js)) {
          return;
        }

        if (javaScript === null) {
          javaScript = Object.create(null);
        }

        javaScript[name] = (0, _util.stringToPDFString)(js);
      }

      if (obj && obj.has("JavaScript")) {
        var nameTree = new NameTree(obj.getRaw("JavaScript"), this.xref);
        var names = nameTree.getAll();

        for (var name in names) {
          var jsDict = names[name];

          if ((0, _primitives.isDict)(jsDict)) {
            appendIfJavaScriptDict(name, jsDict);
          }
        }
      }

      var openAction = this._catDict.get("OpenAction");

      if ((0, _primitives.isDict)(openAction) && (0, _primitives.isName)(openAction.get("S"), "JavaScript")) {
        appendIfJavaScriptDict("OpenAction", openAction);
      }

      return javaScript;
    }
  }, {
    key: "javaScript",
    get: function get() {
      var javaScript = this._collectJavaScript();

      return (0, _util.shadow)(this, "javaScript", javaScript ? Object.values(javaScript) : null);
    }
  }, {
    key: "jsActions",
    get: function get() {
      var js = this._collectJavaScript();

      var actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);

      if (!actions && js) {
        actions = Object.create(null);
      }

      if (actions && js) {
        for (var _i = 0, _Object$entries = Object.entries(js); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              val = _Object$entries$_i[1];

          if (key in actions) {
            actions[key].push(val);
          } else {
            actions[key] = [val];
          }
        }
      }

      return (0, _util.shadow)(this, "jsActions", actions);
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(id, handler) {
      var promises = [];
      this.fontCache.forEach(function (promise) {
        promises.push(promise);
      });
      return Promise.all(promises).then(function (translatedFonts) {
        var _iterator5 = _createForOfIteratorHelper(translatedFonts),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var translatedFont = _step5.value;

            if (translatedFont.loadedName === id) {
              translatedFont.fallback(handler);
              return;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      });
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var _this2 = this;

      var manuallyTriggered = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      (0, _primitives.clearPrimitiveCaches)();
      this.globalImageCache.clear(manuallyTriggered);
      this.pageKidsCountCache.clear();
      this.nonBlendModesSet.clear();
      var promises = [];
      this.fontCache.forEach(function (promise) {
        promises.push(promise);
      });
      return Promise.all(promises).then(function (translatedFonts) {
        var _iterator6 = _createForOfIteratorHelper(translatedFonts),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var dict = _step6.value.dict;
            delete dict.cacheKey;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        _this2.fontCache.clear();

        _this2.builtInCMapCache.clear();
      });
    }
  }, {
    key: "getPageDict",
    value: function getPageDict(pageIndex) {
      var capability = (0, _util.createPromiseCapability)();
      var nodesToVisit = [this._catDict.getRaw("Pages")];
      var visitedNodes = new _primitives.RefSet();
      var xref = this.xref,
          pageKidsCountCache = this.pageKidsCountCache;
      var count,
          currentPageIndex = 0;

      function next() {
        var _loop = function _loop() {
          var currentNode = nodesToVisit.pop();

          if ((0, _primitives.isRef)(currentNode)) {
            count = pageKidsCountCache.get(currentNode);

            if (count > 0 && currentPageIndex + count < pageIndex) {
              currentPageIndex += count;
              return "continue";
            }

            if (visitedNodes.has(currentNode)) {
              capability.reject(new _util.FormatError("Pages tree contains circular reference."));
              return {
                v: void 0
              };
            }

            visitedNodes.put(currentNode);
            xref.fetchAsync(currentNode).then(function (obj) {
              if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
                if (pageIndex === currentPageIndex) {
                  if (currentNode && !pageKidsCountCache.has(currentNode)) {
                    pageKidsCountCache.put(currentNode, 1);
                  }

                  capability.resolve([obj, currentNode]);
                } else {
                  currentPageIndex++;
                  next();
                }

                return;
              }

              nodesToVisit.push(obj);
              next();
            }, capability.reject);
            return {
              v: void 0
            };
          }

          if (!(0, _primitives.isDict)(currentNode)) {
            capability.reject(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
            return {
              v: void 0
            };
          }

          count = currentNode.get("Count");

          if (Number.isInteger(count) && count >= 0) {
            var objId = currentNode.objId;

            if (objId && !pageKidsCountCache.has(objId)) {
              pageKidsCountCache.put(objId, count);
            }

            if (currentPageIndex + count <= pageIndex) {
              currentPageIndex += count;
              return "continue";
            }
          }

          var kids = currentNode.get("Kids");

          if (!Array.isArray(kids)) {
            if ((0, _primitives.isName)(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
              if (currentPageIndex === pageIndex) {
                capability.resolve([currentNode, null]);
                return {
                  v: void 0
                };
              }

              currentPageIndex++;
              return "continue";
            }

            capability.reject(new _util.FormatError("Page dictionary kids object is not an array."));
            return {
              v: void 0
            };
          }

          for (var last = kids.length - 1; last >= 0; last--) {
            nodesToVisit.push(kids[last]);
          }
        };

        while (nodesToVisit.length) {
          var _ret = _loop();

          if (_ret === "continue") continue;
          if (_typeof(_ret) === "object") return _ret.v;
        }

        capability.reject(new Error("Page index ".concat(pageIndex, " not found.")));
      }

      next();
      return capability.promise;
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(pageRef) {
      var xref = this.xref;

      function pagesBeforeRef(kidRef) {
        var total = 0,
            parentRef;
        return xref.fetchAsync(kidRef).then(function (node) {
          if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
            throw new _util.FormatError("The reference does not point to a /Page dictionary.");
          }

          if (!node) {
            return null;
          }

          if (!(0, _primitives.isDict)(node)) {
            throw new _util.FormatError("Node must be a dictionary.");
          }

          parentRef = node.getRaw("Parent");
          return node.getAsync("Parent");
        }).then(function (parent) {
          if (!parent) {
            return null;
          }

          if (!(0, _primitives.isDict)(parent)) {
            throw new _util.FormatError("Parent must be a dictionary.");
          }

          return parent.getAsync("Kids");
        }).then(function (kids) {
          if (!kids) {
            return null;
          }

          var kidPromises = [];
          var found = false;

          for (var i = 0, ii = kids.length; i < ii; i++) {
            var kid = kids[i];

            if (!(0, _primitives.isRef)(kid)) {
              throw new _util.FormatError("Kid must be a reference.");
            }

            if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
              found = true;
              break;
            }

            kidPromises.push(xref.fetchAsync(kid).then(function (obj) {
              if (!(0, _primitives.isDict)(obj)) {
                throw new _util.FormatError("Kid node must be a dictionary.");
              }

              if (obj.has("Count")) {
                total += obj.get("Count");
              } else {
                total++;
              }
            }));
          }

          if (!found) {
            throw new _util.FormatError("Kid reference not found in parent's kids.");
          }

          return Promise.all(kidPromises).then(function () {
            return [total, parentRef];
          });
        });
      }

      var total = 0;

      function next(ref) {
        return pagesBeforeRef(ref).then(function (args) {
          if (!args) {
            return total;
          }

          var _args = _slicedToArray(args, 2),
              count = _args[0],
              parentRef = _args[1];

          total += count;
          return next(parentRef);
        });
      }

      return next(pageRef);
    }
  }], [{
    key: "parseDestDictionary",
    value: function parseDestDictionary(params) {
      function addDefaultProtocolToUrl(url) {
        return url.startsWith("www.") ? "http://".concat(url) : url;
      }

      function tryConvertUrlEncoding(url) {
        try {
          return (0, _util.stringToUTF8String)(url);
        } catch (e) {
          return url;
        }
      }

      var destDict = params.destDict;

      if (!(0, _primitives.isDict)(destDict)) {
        (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
        return;
      }

      var resultObj = params.resultObj;

      if (_typeof(resultObj) !== "object") {
        (0, _util.warn)("parseDestDictionary: `resultObj` must be an object.");
        return;
      }

      var docBaseUrl = params.docBaseUrl || null;
      var action = destDict.get("A"),
          url,
          dest;

      if (!(0, _primitives.isDict)(action)) {
        if (destDict.has("Dest")) {
          action = destDict.get("Dest");
        } else {
          action = destDict.get("AA");

          if ((0, _primitives.isDict)(action)) {
            if (action.has("D")) {
              action = action.get("D");
            } else if (action.has("U")) {
              action = action.get("U");
            }
          }
        }
      }

      if ((0, _primitives.isDict)(action)) {
        var actionType = action.get("S");

        if (!(0, _primitives.isName)(actionType)) {
          (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
          return;
        }

        var actionName = actionType.name;

        switch (actionName) {
          case "URI":
            url = action.get("URI");

            if ((0, _primitives.isName)(url)) {
              url = "/" + url.name;
            } else if ((0, _util.isString)(url)) {
              url = addDefaultProtocolToUrl(url);
            }

            break;

          case "GoTo":
            dest = action.get("D");
            break;

          case "Launch":
          case "GoToR":
            var urlDict = action.get("F");

            if ((0, _primitives.isDict)(urlDict)) {
              url = urlDict.get("F") || null;
            } else if ((0, _util.isString)(urlDict)) {
              url = urlDict;
            }

            var remoteDest = action.get("D");

            if (remoteDest) {
              if ((0, _primitives.isName)(remoteDest)) {
                remoteDest = remoteDest.name;
              }

              if ((0, _util.isString)(url)) {
                var baseUrl = url.split("#")[0];

                if ((0, _util.isString)(remoteDest)) {
                  url = baseUrl + "#" + remoteDest;
                } else if (Array.isArray(remoteDest)) {
                  url = baseUrl + "#" + JSON.stringify(remoteDest);
                }
              }
            }

            var newWindow = action.get("NewWindow");

            if ((0, _util.isBool)(newWindow)) {
              resultObj.newWindow = newWindow;
            }

            break;

          case "Named":
            var namedAction = action.get("N");

            if ((0, _primitives.isName)(namedAction)) {
              resultObj.action = namedAction.name;
            }

            break;

          case "JavaScript":
            var jsAction = action.get("JS");
            var js;

            if ((0, _primitives.isStream)(jsAction)) {
              js = (0, _util.bytesToString)(jsAction.getBytes());
            } else if ((0, _util.isString)(jsAction)) {
              js = jsAction;
            }

            if (js) {
              var URL_OPEN_METHODS = ["app.launchURL", "window.open"];
              var regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i");
              var jsUrl = regex.exec((0, _util.stringToPDFString)(js));

              if (jsUrl && jsUrl[2]) {
                url = jsUrl[2];

                if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                  resultObj.newWindow = true;
                }

                break;
              }
            }

          default:
            (0, _util.warn)("parseDestDictionary: unsupported action type \"".concat(actionName, "\"."));
            break;
        }
      } else if (destDict.has("Dest")) {
        dest = destDict.get("Dest");
      }

      if ((0, _util.isString)(url)) {
        url = tryConvertUrlEncoding(url);
        var absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl);

        if (absoluteUrl) {
          resultObj.url = absoluteUrl.href;
        }

        resultObj.unsafeUrl = url;
      }

      if (dest) {
        if ((0, _primitives.isName)(dest)) {
          dest = dest.name;
        }

        if ((0, _util.isString)(dest) || Array.isArray(dest)) {
          resultObj.dest = dest;
        }
      }
    }
  }]);

  return Catalog;
}();

exports.Catalog = Catalog;

var XRef = function XRefClosure() {
  function XRef(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this.xrefstms = Object.create(null);
    this._cacheMap = new Map();
    this.stats = {
      streamTypes: Object.create(null),
      fontTypes: Object.create(null)
    };
    this._newRefNum = null;
  }

  XRef.prototype = {
    getNewRef: function XRef_getNewRef() {
      if (this._newRefNum === null) {
        this._newRefNum = this.entries.length;
      }

      return _primitives.Ref.get(this._newRefNum++, 0);
    },
    resetNewRef: function XRef_resetNewRef() {
      this._newRefNum = null;
    },
    setStartXRef: function XRef_setStartXRef(startXRef) {
      this.startXRefQueue = [startXRef];
    },
    parse: function XRef_parse(recoveryMode) {
      var trailerDict;

      if (!recoveryMode) {
        trailerDict = this.readXRef();
      } else {
        (0, _util.warn)("Indexing all PDF objects");
        trailerDict = this.indexObjects();
      }

      trailerDict.assignXref(this);
      this.trailer = trailerDict;
      var encrypt;

      try {
        encrypt = trailerDict.get("Encrypt");
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("XRef.parse - Invalid \"Encrypt\" reference: \"".concat(ex, "\"."));
      }

      if ((0, _primitives.isDict)(encrypt)) {
        var ids = trailerDict.get("ID");
        var fileId = ids && ids.length ? ids[0] : "";
        encrypt.suppressEncryption = true;
        this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
      }

      var root;

      try {
        root = trailerDict.get("Root");
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("XRef.parse - Invalid \"Root\" reference: \"".concat(ex, "\"."));
      }

      if ((0, _primitives.isDict)(root) && root.has("Pages")) {
        this.root = root;
      } else {
        if (!recoveryMode) {
          throw new _core_utils.XRefParseException();
        }

        throw new _util.FormatError("Invalid root reference");
      }
    },
    processXRefTable: function XRef_processXRefTable(parser) {
      if (!("tableState" in this)) {
        this.tableState = {
          entryNum: 0,
          streamPos: parser.lexer.stream.pos,
          parserBuf1: parser.buf1,
          parserBuf2: parser.buf2
        };
      }

      var obj = this.readXRefTable(parser);

      if (!(0, _primitives.isCmd)(obj, "trailer")) {
        throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
      }

      var dict = parser.getObj();

      if (!(0, _primitives.isDict)(dict) && dict.dict) {
        dict = dict.dict;
      }

      if (!(0, _primitives.isDict)(dict)) {
        throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
      }

      delete this.tableState;
      return dict;
    },
    readXRefTable: function XRef_readXRefTable(parser) {
      var stream = parser.lexer.stream;
      var tableState = this.tableState;
      stream.pos = tableState.streamPos;
      parser.buf1 = tableState.parserBuf1;
      parser.buf2 = tableState.parserBuf2;
      var obj;

      while (true) {
        if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
          if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
            break;
          }

          tableState.firstEntryNum = obj;
          tableState.entryCount = parser.getObj();
        }

        var first = tableState.firstEntryNum;
        var count = tableState.entryCount;

        if (!Number.isInteger(first) || !Number.isInteger(count)) {
          throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
        }

        for (var i = tableState.entryNum; i < count; i++) {
          tableState.streamPos = stream.pos;
          tableState.entryNum = i;
          tableState.parserBuf1 = parser.buf1;
          tableState.parserBuf2 = parser.buf2;
          var entry = {};
          entry.offset = parser.getObj();
          entry.gen = parser.getObj();
          var type = parser.getObj();

          if (type instanceof _primitives.Cmd) {
            switch (type.cmd) {
              case "f":
                entry.free = true;
                break;

              case "n":
                entry.uncompressed = true;
                break;
            }
          }

          if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
            throw new _util.FormatError("Invalid entry in XRef subsection: ".concat(first, ", ").concat(count));
          }

          if (i === 0 && entry.free && first === 1) {
            first = 0;
          }

          if (!this.entries[i + first]) {
            this.entries[i + first] = entry;
          }
        }

        tableState.entryNum = 0;
        tableState.streamPos = stream.pos;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        delete tableState.firstEntryNum;
        delete tableState.entryCount;
      }

      if (this.entries[0] && !this.entries[0].free) {
        throw new _util.FormatError("Invalid XRef table: unexpected first object");
      }

      return obj;
    },
    processXRefStream: function XRef_processXRefStream(stream) {
      if (!("streamState" in this)) {
        var streamParameters = stream.dict;
        var byteWidths = streamParameters.get("W");
        var range = streamParameters.get("Index");

        if (!range) {
          range = [0, streamParameters.get("Size")];
        }

        this.streamState = {
          entryRanges: range,
          byteWidths: byteWidths,
          entryNum: 0,
          streamPos: stream.pos
        };
      }

      this.readXRefStream(stream);
      delete this.streamState;
      return stream.dict;
    },
    readXRefStream: function XRef_readXRefStream(stream) {
      var i, j;
      var streamState = this.streamState;
      stream.pos = streamState.streamPos;
      var byteWidths = streamState.byteWidths;
      var typeFieldWidth = byteWidths[0];
      var offsetFieldWidth = byteWidths[1];
      var generationFieldWidth = byteWidths[2];
      var entryRanges = streamState.entryRanges;

      while (entryRanges.length > 0) {
        var first = entryRanges[0];
        var n = entryRanges[1];

        if (!Number.isInteger(first) || !Number.isInteger(n)) {
          throw new _util.FormatError("Invalid XRef range fields: ".concat(first, ", ").concat(n));
        }

        if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
          throw new _util.FormatError("Invalid XRef entry fields length: ".concat(first, ", ").concat(n));
        }

        for (i = streamState.entryNum; i < n; ++i) {
          streamState.entryNum = i;
          streamState.streamPos = stream.pos;
          var type = 0,
              offset = 0,
              generation = 0;

          for (j = 0; j < typeFieldWidth; ++j) {
            type = type << 8 | stream.getByte();
          }

          if (typeFieldWidth === 0) {
            type = 1;
          }

          for (j = 0; j < offsetFieldWidth; ++j) {
            offset = offset << 8 | stream.getByte();
          }

          for (j = 0; j < generationFieldWidth; ++j) {
            generation = generation << 8 | stream.getByte();
          }

          var entry = {};
          entry.offset = offset;
          entry.gen = generation;

          switch (type) {
            case 0:
              entry.free = true;
              break;

            case 1:
              entry.uncompressed = true;
              break;

            case 2:
              break;

            default:
              throw new _util.FormatError("Invalid XRef entry type: ".concat(type));
          }

          if (!this.entries[first + i]) {
            this.entries[first + i] = entry;
          }
        }

        streamState.entryNum = 0;
        streamState.streamPos = stream.pos;
        entryRanges.splice(0, 2);
      }
    },
    indexObjects: function XRef_indexObjects() {
      var TAB = 0x9,
          LF = 0xa,
          CR = 0xd,
          SPACE = 0x20;
      var PERCENT = 0x25,
          LT = 0x3c;

      function readToken(data, offset) {
        var token = "",
            ch = data[offset];

        while (ch !== LF && ch !== CR && ch !== LT) {
          if (++offset >= data.length) {
            break;
          }

          token += String.fromCharCode(ch);
          ch = data[offset];
        }

        return token;
      }

      function skipUntil(data, offset, what) {
        var length = what.length,
            dataLength = data.length;
        var skipped = 0;

        while (offset < dataLength) {
          var i = 0;

          while (i < length && data[offset + i] === what[i]) {
            ++i;
          }

          if (i >= length) {
            break;
          }

          offset++;
          skipped++;
        }

        return skipped;
      }

      var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
      var endobjRegExp = /\bendobj[\b\s]$/;
      var nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
      var CHECK_CONTENT_LENGTH = 25;
      var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
      var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
      var objBytes = new Uint8Array([111, 98, 106]);
      var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
      this.entries.length = 0;
      var stream = this.stream;
      stream.pos = 0;
      var buffer = stream.getBytes();
      var position = stream.start,
          length = buffer.length;
      var trailers = [],
          xrefStms = [];

      while (position < length) {
        var ch = buffer[position];

        if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
          ++position;
          continue;
        }

        if (ch === PERCENT) {
          do {
            ++position;

            if (position >= length) {
              break;
            }

            ch = buffer[position];
          } while (ch !== LF && ch !== CR);

          continue;
        }

        var token = readToken(buffer, position);
        var m;

        if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
          position += skipUntil(buffer, position, trailerBytes);
          trailers.push(position);
          position += skipUntil(buffer, position, startxrefBytes);
        } else if (m = objRegExp.exec(token)) {
          var num = m[1] | 0,
              gen = m[2] | 0;

          if (!this.entries[num] || this.entries[num].gen === gen) {
            this.entries[num] = {
              offset: position - stream.start,
              gen: gen,
              uncompressed: true
            };
          }

          var contentLength = void 0,
              startPos = position + token.length;

          while (startPos < buffer.length) {
            var endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
            contentLength = endPos - position;
            var checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
            var tokenStr = (0, _util.bytesToString)(buffer.subarray(checkPos, endPos));

            if (endobjRegExp.test(tokenStr)) {
              break;
            } else {
              var objToken = nestedObjRegExp.exec(tokenStr);

              if (objToken && objToken[1]) {
                (0, _util.warn)('indexObjects: Found new "obj" inside of another "obj", ' + 'caused by missing "endobj" -- trying to recover.');
                contentLength -= objToken[1].length;
                break;
              }
            }

            startPos = endPos;
          }

          var content = buffer.subarray(position, position + contentLength);
          var xrefTagOffset = skipUntil(content, 0, xrefBytes);

          if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
            xrefStms.push(position - stream.start);
            this.xrefstms[position - stream.start] = 1;
          }

          position += contentLength;
        } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
          trailers.push(position);
          position += skipUntil(buffer, position, startxrefBytes);
        } else {
          position += token.length + 1;
        }
      }

      for (var i = 0, ii = xrefStms.length; i < ii; ++i) {
        this.startXRefQueue.push(xrefStms[i]);
        this.readXRef(true);
      }

      var trailerDict;

      for (var _i2 = 0, _ii = trailers.length; _i2 < _ii; ++_i2) {
        stream.pos = trailers[_i2];
        var parser = new _parser.Parser({
          lexer: new _parser.Lexer(stream),
          xref: this,
          allowStreams: true,
          recoveryMode: true
        });
        var obj = parser.getObj();

        if (!(0, _primitives.isCmd)(obj, "trailer")) {
          continue;
        }

        var dict = parser.getObj();

        if (!(0, _primitives.isDict)(dict)) {
          continue;
        }

        try {
          var rootDict = dict.get("Root");

          if (!(rootDict instanceof _primitives.Dict)) {
            continue;
          }

          var pagesDict = rootDict.get("Pages");

          if (!(pagesDict instanceof _primitives.Dict)) {
            continue;
          }

          var pagesCount = pagesDict.get("Count");

          if (!Number.isInteger(pagesCount)) {
            continue;
          }
        } catch (ex) {
          if (ex instanceof _core_utils.MissingDataException) {
            throw ex;
          }

          continue;
        }

        if (dict.has("ID")) {
          return dict;
        }

        trailerDict = dict;
      }

      if (trailerDict) {
        return trailerDict;
      }

      throw new _util.InvalidPDFException("Invalid PDF structure.");
    },
    readXRef: function XRef_readXRef(recoveryMode) {
      var stream = this.stream;
      var startXRefParsedCache = Object.create(null);

      try {
        while (this.startXRefQueue.length) {
          var startXRef = this.startXRefQueue[0];

          if (startXRefParsedCache[startXRef]) {
            (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
            this.startXRefQueue.shift();
            continue;
          }

          startXRefParsedCache[startXRef] = true;
          stream.pos = startXRef + stream.start;
          var parser = new _parser.Parser({
            lexer: new _parser.Lexer(stream),
            xref: this,
            allowStreams: true
          });
          var obj = parser.getObj();
          var dict;

          if ((0, _primitives.isCmd)(obj, "xref")) {
            dict = this.processXRefTable(parser);

            if (!this.topDict) {
              this.topDict = dict;
            }

            obj = dict.get("XRefStm");

            if (Number.isInteger(obj)) {
              var pos = obj;

              if (!(pos in this.xrefstms)) {
                this.xrefstms[pos] = 1;
                this.startXRefQueue.push(pos);
              }
            }
          } else if (Number.isInteger(obj)) {
            if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
              throw new _util.FormatError("Invalid XRef stream");
            }

            dict = this.processXRefStream(obj);

            if (!this.topDict) {
              this.topDict = dict;
            }

            if (!dict) {
              throw new _util.FormatError("Failed to read XRef stream");
            }
          } else {
            throw new _util.FormatError("Invalid XRef stream header");
          }

          obj = dict.get("Prev");

          if (Number.isInteger(obj)) {
            this.startXRefQueue.push(obj);
          } else if ((0, _primitives.isRef)(obj)) {
            this.startXRefQueue.push(obj.num);
          }

          this.startXRefQueue.shift();
        }

        return this.topDict;
      } catch (e) {
        if (e instanceof _core_utils.MissingDataException) {
          throw e;
        }

        (0, _util.info)("(while reading XRef): " + e);
      }

      if (recoveryMode) {
        return undefined;
      }

      throw new _core_utils.XRefParseException();
    },
    getEntry: function XRef_getEntry(i) {
      var xrefEntry = this.entries[i];

      if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
        return xrefEntry;
      }

      return null;
    },
    fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
      if (obj instanceof _primitives.Ref) {
        return this.fetch(obj, suppressEncryption);
      }

      return obj;
    },
    fetch: function XRef_fetch(ref, suppressEncryption) {
      if (!(ref instanceof _primitives.Ref)) {
        throw new Error("ref object is not a reference");
      }

      var num = ref.num;

      var cacheEntry = this._cacheMap.get(num);

      if (cacheEntry !== undefined) {
        if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
          cacheEntry.objId = ref.toString();
        }

        return cacheEntry;
      }

      var xrefEntry = this.getEntry(num);

      if (xrefEntry === null) {
        this._cacheMap.set(num, xrefEntry);

        return xrefEntry;
      }

      if (xrefEntry.uncompressed) {
        xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
      } else {
        xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
      }

      if ((0, _primitives.isDict)(xrefEntry)) {
        xrefEntry.objId = ref.toString();
      } else if ((0, _primitives.isStream)(xrefEntry)) {
        xrefEntry.dict.objId = ref.toString();
      }

      return xrefEntry;
    },
    fetchUncompressed: function fetchUncompressed(ref, xrefEntry) {
      var suppressEncryption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var gen = ref.gen;
      var num = ref.num;

      if (xrefEntry.gen !== gen) {
        throw new _core_utils.XRefEntryException("Inconsistent generation in XRef: ".concat(ref));
      }

      var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
      var parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream),
        xref: this,
        allowStreams: true
      });
      var obj1 = parser.getObj();
      var obj2 = parser.getObj();
      var obj3 = parser.getObj();

      if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
        throw new _core_utils.XRefEntryException("Bad (uncompressed) XRef entry: ".concat(ref));
      }

      if (obj3.cmd !== "obj") {
        if (obj3.cmd.startsWith("obj")) {
          num = parseInt(obj3.cmd.substring(3), 10);

          if (!Number.isNaN(num)) {
            return num;
          }
        }

        throw new _core_utils.XRefEntryException("Bad (uncompressed) XRef entry: ".concat(ref));
      }

      if (this.encrypt && !suppressEncryption) {
        xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
      } else {
        xrefEntry = parser.getObj();
      }

      if (!(0, _primitives.isStream)(xrefEntry)) {
        this._cacheMap.set(num, xrefEntry);
      }

      return xrefEntry;
    },
    fetchCompressed: function fetchCompressed(ref, xrefEntry) {
      var suppressEncryption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tableOffset = xrefEntry.offset;
      var stream = this.fetch(_primitives.Ref.get(tableOffset, 0));

      if (!(0, _primitives.isStream)(stream)) {
        throw new _util.FormatError("bad ObjStm stream");
      }

      var first = stream.dict.get("First");
      var n = stream.dict.get("N");

      if (!Number.isInteger(first) || !Number.isInteger(n)) {
        throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
      }

      var parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream),
        xref: this,
        allowStreams: true
      });
      var nums = new Array(n);

      for (var i = 0; i < n; ++i) {
        var num = parser.getObj();

        if (!Number.isInteger(num)) {
          throw new _util.FormatError("invalid object number in the ObjStm stream: ".concat(num));
        }

        var offset = parser.getObj();

        if (!Number.isInteger(offset)) {
          throw new _util.FormatError("invalid object offset in the ObjStm stream: ".concat(offset));
        }

        nums[i] = num;
      }

      var entries = new Array(n);

      for (var _i3 = 0; _i3 < n; ++_i3) {
        var obj = parser.getObj();
        entries[_i3] = obj;

        if (parser.buf1 instanceof _primitives.Cmd && parser.buf1.cmd === "endobj") {
          parser.shift();
        }

        if ((0, _primitives.isStream)(obj)) {
          continue;
        }

        var _num = nums[_i3],
            entry = this.entries[_num];

        if (entry && entry.offset === tableOffset && entry.gen === _i3) {
          this._cacheMap.set(_num, obj);
        }
      }

      xrefEntry = entries[xrefEntry.gen];

      if (xrefEntry === undefined) {
        throw new _core_utils.XRefEntryException("Bad (compressed) XRef entry: ".concat(ref));
      }

      return xrefEntry;
    },
    fetchIfRefAsync: function fetchIfRefAsync(obj, suppressEncryption) {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(obj instanceof _primitives.Ref)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", _this3.fetchAsync(obj, suppressEncryption));

              case 2:
                return _context.abrupt("return", obj);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    fetchAsync: function fetchAsync(ref, suppressEncryption) {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                return _context2.abrupt("return", _this4.fetch(ref, suppressEncryption));

              case 4:
                _context2.prev = 4;
                _context2.t0 = _context2["catch"](0);

                if (_context2.t0 instanceof _core_utils.MissingDataException) {
                  _context2.next = 8;
                  break;
                }

                throw _context2.t0;

              case 8:
                _context2.next = 10;
                return _this4.pdfManager.requestRange(_context2.t0.begin, _context2.t0.end);

              case 10:
                return _context2.abrupt("return", _this4.fetchAsync(ref, suppressEncryption));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 4]]);
      }))();
    },
    getCatalogObj: function XRef_getCatalogObj() {
      return this.root;
    }
  };
  return XRef;
}();

exports.XRef = XRef;

var NameOrNumberTree = /*#__PURE__*/function () {
  function NameOrNumberTree(root, xref, type) {
    _classCallCheck(this, NameOrNumberTree);

    if (this.constructor === NameOrNumberTree) {
      (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
    }

    this.root = root;
    this.xref = xref;
    this._type = type;
  }

  _createClass(NameOrNumberTree, [{
    key: "getAll",
    value: function getAll() {
      var dict = Object.create(null);

      if (!this.root) {
        return dict;
      }

      var xref = this.xref;
      var processed = new _primitives.RefSet();
      processed.put(this.root);
      var queue = [this.root];

      while (queue.length > 0) {
        var obj = xref.fetchIfRef(queue.shift());

        if (!(0, _primitives.isDict)(obj)) {
          continue;
        }

        if (obj.has("Kids")) {
          var kids = obj.get("Kids");

          for (var i = 0, ii = kids.length; i < ii; i++) {
            var kid = kids[i];

            if (processed.has(kid)) {
              throw new _util.FormatError("Duplicate entry in \"".concat(this._type, "\" tree."));
            }

            queue.push(kid);
            processed.put(kid);
          }

          continue;
        }

        var entries = obj.get(this._type);

        if (Array.isArray(entries)) {
          for (var _i4 = 0, _ii2 = entries.length; _i4 < _ii2; _i4 += 2) {
            dict[xref.fetchIfRef(entries[_i4])] = xref.fetchIfRef(entries[_i4 + 1]);
          }
        }
      }

      return dict;
    }
  }, {
    key: "get",
    value: function get(key) {
      if (!this.root) {
        return null;
      }

      var xref = this.xref;
      var kidsOrEntries = xref.fetchIfRef(this.root);
      var loopCount = 0;
      var MAX_LEVELS = 10;

      while (kidsOrEntries.has("Kids")) {
        if (++loopCount > MAX_LEVELS) {
          (0, _util.warn)("Search depth limit reached for \"".concat(this._type, "\" tree."));
          return null;
        }

        var kids = kidsOrEntries.get("Kids");

        if (!Array.isArray(kids)) {
          return null;
        }

        var l = 0,
            r = kids.length - 1;

        while (l <= r) {
          var m = l + r >> 1;
          var kid = xref.fetchIfRef(kids[m]);
          var limits = kid.get("Limits");

          if (key < xref.fetchIfRef(limits[0])) {
            r = m - 1;
          } else if (key > xref.fetchIfRef(limits[1])) {
            l = m + 1;
          } else {
            kidsOrEntries = xref.fetchIfRef(kids[m]);
            break;
          }
        }

        if (l > r) {
          return null;
        }
      }

      var entries = kidsOrEntries.get(this._type);

      if (Array.isArray(entries)) {
        var _l = 0,
            _r = entries.length - 2;

        while (_l <= _r) {
          var tmp = _l + _r >> 1,
              _m = tmp + (tmp & 1);

          var currentKey = xref.fetchIfRef(entries[_m]);

          if (key < currentKey) {
            _r = _m - 2;
          } else if (key > currentKey) {
            _l = _m + 2;
          } else {
            return xref.fetchIfRef(entries[_m + 1]);
          }
        }

        (0, _util.info)("Falling back to an exhaustive search, for key \"".concat(key, "\", ") + "in \"".concat(this._type, "\" tree."));

        for (var _m2 = 0, mm = entries.length; _m2 < mm; _m2 += 2) {
          var _currentKey = xref.fetchIfRef(entries[_m2]);

          if (_currentKey === key) {
            (0, _util.warn)("The \"".concat(key, "\" key was found at an incorrect, ") + "i.e. out-of-order, position in \"".concat(this._type, "\" tree."));
            return xref.fetchIfRef(entries[_m2 + 1]);
          }
        }
      }

      return null;
    }
  }]);

  return NameOrNumberTree;
}();

var NameTree = /*#__PURE__*/function (_NameOrNumberTree) {
  _inherits(NameTree, _NameOrNumberTree);

  var _super = _createSuper(NameTree);

  function NameTree(root, xref) {
    _classCallCheck(this, NameTree);

    return _super.call(this, root, xref, "Names");
  }

  return NameTree;
}(NameOrNumberTree);

var NumberTree = /*#__PURE__*/function (_NameOrNumberTree2) {
  _inherits(NumberTree, _NameOrNumberTree2);

  var _super2 = _createSuper(NumberTree);

  function NumberTree(root, xref) {
    _classCallCheck(this, NumberTree);

    return _super2.call(this, root, xref, "Nums");
  }

  return NumberTree;
}(NameOrNumberTree);

var FileSpec = function FileSpecClosure() {
  function FileSpec(root, xref) {
    if (!root || !(0, _primitives.isDict)(root)) {
      return;
    }

    this.xref = xref;
    this.root = root;

    if (root.has("FS")) {
      this.fs = root.get("FS");
    }

    this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";

    if (root.has("RF")) {
      (0, _util.warn)("Related file specifications are not supported");
    }

    this.contentAvailable = true;

    if (!root.has("EF")) {
      this.contentAvailable = false;
      (0, _util.warn)("Non-embedded file specifications are not supported");
    }
  }

  function pickPlatformItem(dict) {
    if (dict.has("UF")) {
      return dict.get("UF");
    } else if (dict.has("F")) {
      return dict.get("F");
    } else if (dict.has("Unix")) {
      return dict.get("Unix");
    } else if (dict.has("Mac")) {
      return dict.get("Mac");
    } else if (dict.has("DOS")) {
      return dict.get("DOS");
    }

    return null;
  }

  FileSpec.prototype = {
    get filename() {
      if (!this._filename && this.root) {
        var filename = pickPlatformItem(this.root) || "unnamed";
        this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
      }

      return this._filename;
    },

    get content() {
      if (!this.contentAvailable) {
        return null;
      }

      if (!this.contentRef && this.root) {
        this.contentRef = pickPlatformItem(this.root.get("EF"));
      }

      var content = null;

      if (this.contentRef) {
        var xref = this.xref;
        var fileObj = xref.fetchIfRef(this.contentRef);

        if (fileObj && (0, _primitives.isStream)(fileObj)) {
          content = fileObj.getBytes();
        } else {
          (0, _util.warn)("Embedded file specification points to non-existing/invalid " + "content");
        }
      } else {
        (0, _util.warn)("Embedded file specification does not have a content");
      }

      return content;
    },

    get serializable() {
      return {
        filename: this.filename,
        content: this.content
      };
    }

  };
  return FileSpec;
}();

exports.FileSpec = FileSpec;

var ObjectLoader = function () {
  function mayHaveChildren(value) {
    return value instanceof _primitives.Ref || value instanceof _primitives.Dict || Array.isArray(value) || (0, _primitives.isStream)(value);
  }

  function addChildren(node, nodesToVisit) {
    if (node instanceof _primitives.Dict) {
      node = node.getRawValues();
    } else if ((0, _primitives.isStream)(node)) {
      node = node.dict.getRawValues();
    } else if (!Array.isArray(node)) {
      return;
    }

    var _iterator7 = _createForOfIteratorHelper(node),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var rawValue = _step7.value;

        if (mayHaveChildren(rawValue)) {
          nodesToVisit.push(rawValue);
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }

  function ObjectLoader(dict, keys, xref) {
    this.dict = dict;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
  }

  ObjectLoader.prototype = {
    load: function load() {
      var _this5 = this;

      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var keys, dict, nodesToVisit, i, ii, rawValue;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!_this5.xref.stream.allChunksLoaded || _this5.xref.stream.allChunksLoaded())) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", undefined);

              case 2:
                keys = _this5.keys, dict = _this5.dict;
                _this5.refSet = new _primitives.RefSet();
                nodesToVisit = [];

                for (i = 0, ii = keys.length; i < ii; i++) {
                  rawValue = dict.getRaw(keys[i]);

                  if (rawValue !== undefined) {
                    nodesToVisit.push(rawValue);
                  }
                }

                return _context3.abrupt("return", _this5._walk(nodesToVisit));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    _walk: function _walk(nodesToVisit) {
      var _this6 = this;

      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var nodesToRevisit, pendingRequests, currentNode, manager, baseStreams, foundMissingData, i, ii, stream, _i5, _ii3, node;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                nodesToRevisit = [];
                pendingRequests = [];

              case 2:
                if (!nodesToVisit.length) {
                  _context4.next = 25;
                  break;
                }

                currentNode = nodesToVisit.pop();

                if (!(currentNode instanceof _primitives.Ref)) {
                  _context4.next = 21;
                  break;
                }

                if (!_this6.refSet.has(currentNode)) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("continue", 2);

              case 7:
                _context4.prev = 7;

                _this6.refSet.put(currentNode);

                currentNode = _this6.xref.fetch(currentNode);
                _context4.next = 21;
                break;

              case 12:
                _context4.prev = 12;
                _context4.t0 = _context4["catch"](7);

                if (_context4.t0 instanceof _core_utils.MissingDataException) {
                  _context4.next = 19;
                  break;
                }

                (0, _util.warn)("ObjectLoader._walk - requesting all data: \"".concat(_context4.t0, "\"."));
                _this6.refSet = null;
                manager = _this6.xref.stream.manager;
                return _context4.abrupt("return", manager.requestAllChunks());

              case 19:
                nodesToRevisit.push(currentNode);
                pendingRequests.push({
                  begin: _context4.t0.begin,
                  end: _context4.t0.end
                });

              case 21:
                if (currentNode && currentNode.getBaseStreams) {
                  baseStreams = currentNode.getBaseStreams();
                  foundMissingData = false;

                  for (i = 0, ii = baseStreams.length; i < ii; i++) {
                    stream = baseStreams[i];

                    if (stream.allChunksLoaded && !stream.allChunksLoaded()) {
                      foundMissingData = true;
                      pendingRequests.push({
                        begin: stream.start,
                        end: stream.end
                      });
                    }
                  }

                  if (foundMissingData) {
                    nodesToRevisit.push(currentNode);
                  }
                }

                addChildren(currentNode, nodesToVisit);
                _context4.next = 2;
                break;

              case 25:
                if (!pendingRequests.length) {
                  _context4.next = 30;
                  break;
                }

                _context4.next = 28;
                return _this6.xref.stream.manager.requestRanges(pendingRequests);

              case 28:
                for (_i5 = 0, _ii3 = nodesToRevisit.length; _i5 < _ii3; _i5++) {
                  node = nodesToRevisit[_i5];

                  if (node instanceof _primitives.Ref) {
                    _this6.refSet.remove(node);
                  }
                }

                return _context4.abrupt("return", _this6._walk(nodesToRevisit));

              case 30:
                _this6.refSet = null;
                return _context4.abrupt("return", undefined);

              case 32:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[7, 12]]);
      }))();
    }
  };
  return ObjectLoader;
}();

exports.ObjectLoader = ObjectLoader;

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Parser = exports.Linearization = exports.Lexer = void 0;

var _stream = __w_pdfjs_require__(142);

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

var _ccitt_stream = __w_pdfjs_require__(143);

var _jbig2_stream = __w_pdfjs_require__(145);

var _jpeg_stream = __w_pdfjs_require__(148);

var _jpx_stream = __w_pdfjs_require__(150);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MAX_LENGTH_TO_CACHE = 1000;
var MAX_ADLER32_LENGTH = 5552;

function computeAdler32(bytes) {
  var bytesLength = bytes.length;
  var a = 1,
      b = 0;

  for (var i = 0; i < bytesLength; ++i) {
    a += bytes[i] & 0xff;
    b += a;
  }

  return b % 65521 << 16 | a % 65521;
}

var Parser = /*#__PURE__*/function () {
  function Parser(_ref) {
    var lexer = _ref.lexer,
        xref = _ref.xref,
        _ref$allowStreams = _ref.allowStreams,
        allowStreams = _ref$allowStreams === void 0 ? false : _ref$allowStreams,
        _ref$recoveryMode = _ref.recoveryMode,
        recoveryMode = _ref$recoveryMode === void 0 ? false : _ref$recoveryMode;

    _classCallCheck(this, Parser);

    this.lexer = lexer;
    this.xref = xref;
    this.allowStreams = allowStreams;
    this.recoveryMode = recoveryMode;
    this.imageCache = Object.create(null);
    this.refill();
  }

  _createClass(Parser, [{
    key: "refill",
    value: function refill() {
      this.buf1 = this.lexer.getObj();
      this.buf2 = this.lexer.getObj();
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
        this.buf1 = this.buf2;
        this.buf2 = null;
      } else {
        this.buf1 = this.buf2;
        this.buf2 = this.lexer.getObj();
      }
    }
  }, {
    key: "tryShift",
    value: function tryShift() {
      try {
        this.shift();
        return true;
      } catch (e) {
        if (e instanceof _core_utils.MissingDataException) {
          throw e;
        }

        return false;
      }
    }
  }, {
    key: "getObj",
    value: function getObj() {
      var cipherTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var buf1 = this.buf1;
      this.shift();

      if (buf1 instanceof _primitives.Cmd) {
        switch (buf1.cmd) {
          case "BI":
            return this.makeInlineImage(cipherTransform);

          case "[":
            var array = [];

            while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
              array.push(this.getObj(cipherTransform));
            }

            if ((0, _primitives.isEOF)(this.buf1)) {
              if (!this.recoveryMode) {
                throw new _util.FormatError("End of file inside array");
              }

              return array;
            }

            this.shift();
            return array;

          case "<<":
            var dict = new _primitives.Dict(this.xref);

            while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
              if (!(0, _primitives.isName)(this.buf1)) {
                (0, _util.info)("Malformed dictionary: key must be a name object");
                this.shift();
                continue;
              }

              var key = this.buf1.name;
              this.shift();

              if ((0, _primitives.isEOF)(this.buf1)) {
                break;
              }

              dict.set(key, this.getObj(cipherTransform));
            }

            if ((0, _primitives.isEOF)(this.buf1)) {
              if (!this.recoveryMode) {
                throw new _util.FormatError("End of file inside dictionary");
              }

              return dict;
            }

            if ((0, _primitives.isCmd)(this.buf2, "stream")) {
              return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
            }

            this.shift();
            return dict;

          default:
            return buf1;
        }
      }

      if (Number.isInteger(buf1)) {
        if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
          var ref = _primitives.Ref.get(buf1, this.buf1);

          this.shift();
          this.shift();
          return ref;
        }

        return buf1;
      }

      if (typeof buf1 === "string") {
        if (cipherTransform) {
          return cipherTransform.decryptString(buf1);
        }

        return buf1;
      }

      return buf1;
    }
  }, {
    key: "findDefaultInlineStreamEnd",
    value: function findDefaultInlineStreamEnd(stream) {
      var E = 0x45,
          I = 0x49,
          SPACE = 0x20,
          LF = 0xa,
          CR = 0xd,
          NUL = 0x0;
      var lexer = this.lexer,
          startPos = stream.pos,
          n = 10;
      var state = 0,
          ch,
          maybeEIPos;

      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else {
          (0, _util.assert)(state === 2, "findDefaultInlineStreamEnd - invalid state.");

          if (ch === SPACE || ch === LF || ch === CR) {
            maybeEIPos = stream.pos;
            var followingBytes = stream.peekBytes(n);

            for (var i = 0, ii = followingBytes.length; i < ii; i++) {
              ch = followingBytes[i];

              if (ch === NUL && followingBytes[i + 1] !== NUL) {
                continue;
              }

              if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7f)) {
                state = 0;
                break;
              }
            }

            if (state !== 2) {
              continue;
            }

            if (lexer.knownCommands) {
              var nextObj = lexer.peekObj();

              if (nextObj instanceof _primitives.Cmd && !lexer.knownCommands[nextObj.cmd]) {
                state = 0;
              }
            } else {
              (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
            }

            if (state === 2) {
              break;
            }
          } else {
            state = 0;
          }
        }
      }

      if (ch === -1) {
        (0, _util.warn)("findDefaultInlineStreamEnd: " + "Reached the end of the stream without finding a valid EI marker");

        if (maybeEIPos) {
          (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
          stream.skip(-(stream.pos - maybeEIPos));
        }
      }

      var endOffset = 4;
      stream.skip(-endOffset);
      ch = stream.peekByte();
      stream.skip(endOffset);

      if (!(0, _core_utils.isWhiteSpace)(ch)) {
        endOffset--;
      }

      return stream.pos - endOffset - startPos;
    }
  }, {
    key: "findDCTDecodeInlineStreamEnd",
    value: function findDCTDecodeInlineStreamEnd(stream) {
      var startPos = stream.pos;
      var foundEOI = false,
          b,
          markerLength;

      while ((b = stream.getByte()) !== -1) {
        if (b !== 0xff) {
          continue;
        }

        switch (stream.getByte()) {
          case 0x00:
            break;

          case 0xff:
            stream.skip(-1);
            break;

          case 0xd9:
            foundEOI = true;
            break;

          case 0xc0:
          case 0xc1:
          case 0xc2:
          case 0xc3:
          case 0xc5:
          case 0xc6:
          case 0xc7:
          case 0xc9:
          case 0xca:
          case 0xcb:
          case 0xcd:
          case 0xce:
          case 0xcf:
          case 0xc4:
          case 0xcc:
          case 0xda:
          case 0xdb:
          case 0xdc:
          case 0xdd:
          case 0xde:
          case 0xdf:
          case 0xe0:
          case 0xe1:
          case 0xe2:
          case 0xe3:
          case 0xe4:
          case 0xe5:
          case 0xe6:
          case 0xe7:
          case 0xe8:
          case 0xe9:
          case 0xea:
          case 0xeb:
          case 0xec:
          case 0xed:
          case 0xee:
          case 0xef:
          case 0xfe:
            markerLength = stream.getUint16();

            if (markerLength > 2) {
              stream.skip(markerLength - 2);
            } else {
              stream.skip(-2);
            }

            break;
        }

        if (foundEOI) {
          break;
        }
      }

      var length = stream.pos - startPos;

      if (b === -1) {
        (0, _util.warn)("Inline DCTDecode image stream: " + "EOI marker not found, searching for /EI/ instead.");
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }

      this.inlineStreamSkipEI(stream);
      return length;
    }
  }, {
    key: "findASCII85DecodeInlineStreamEnd",
    value: function findASCII85DecodeInlineStreamEnd(stream) {
      var TILDE = 0x7e,
          GT = 0x3e;
      var startPos = stream.pos;
      var ch;

      while ((ch = stream.getByte()) !== -1) {
        if (ch === TILDE) {
          var tildePos = stream.pos;
          ch = stream.peekByte();

          while ((0, _core_utils.isWhiteSpace)(ch)) {
            stream.skip();
            ch = stream.peekByte();
          }

          if (ch === GT) {
            stream.skip();
            break;
          }

          if (stream.pos > tildePos) {
            var maybeEI = stream.peekBytes(2);

            if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {
              break;
            }
          }
        }
      }

      var length = stream.pos - startPos;

      if (ch === -1) {
        (0, _util.warn)("Inline ASCII85Decode image stream: " + "EOD marker not found, searching for /EI/ instead.");
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }

      this.inlineStreamSkipEI(stream);
      return length;
    }
  }, {
    key: "findASCIIHexDecodeInlineStreamEnd",
    value: function findASCIIHexDecodeInlineStreamEnd(stream) {
      var GT = 0x3e;
      var startPos = stream.pos;
      var ch;

      while ((ch = stream.getByte()) !== -1) {
        if (ch === GT) {
          break;
        }
      }

      var length = stream.pos - startPos;

      if (ch === -1) {
        (0, _util.warn)("Inline ASCIIHexDecode image stream: " + "EOD marker not found, searching for /EI/ instead.");
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }

      this.inlineStreamSkipEI(stream);
      return length;
    }
  }, {
    key: "inlineStreamSkipEI",
    value: function inlineStreamSkipEI(stream) {
      var E = 0x45,
          I = 0x49;
      var state = 0,
          ch;

      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else if (state === 2) {
          break;
        }
      }
    }
  }, {
    key: "makeInlineImage",
    value: function makeInlineImage(cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      var dict = new _primitives.Dict(this.xref);
      var dictLength;

      while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
        if (!(0, _primitives.isName)(this.buf1)) {
          throw new _util.FormatError("Dictionary key must be a name object");
        }

        var key = this.buf1.name;
        this.shift();

        if ((0, _primitives.isEOF)(this.buf1)) {
          break;
        }

        dict.set(key, this.getObj(cipherTransform));
      }

      if (lexer.beginInlineImagePos !== -1) {
        dictLength = stream.pos - lexer.beginInlineImagePos;
      }

      var filter = dict.get("Filter", "F");
      var filterName;

      if ((0, _primitives.isName)(filter)) {
        filterName = filter.name;
      } else if (Array.isArray(filter)) {
        var filterZero = this.xref.fetchIfRef(filter[0]);

        if ((0, _primitives.isName)(filterZero)) {
          filterName = filterZero.name;
        }
      }

      var startPos = stream.pos;
      var length;

      if (filterName === "DCTDecode" || filterName === "DCT") {
        length = this.findDCTDecodeInlineStreamEnd(stream);
      } else if (filterName === "ASCII85Decode" || filterName === "A85") {
        length = this.findASCII85DecodeInlineStreamEnd(stream);
      } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
        length = this.findASCIIHexDecodeInlineStreamEnd(stream);
      } else {
        length = this.findDefaultInlineStreamEnd(stream);
      }

      var imageStream = stream.makeSubStream(startPos, length, dict);
      var cacheKey;

      if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
        var imageBytes = imageStream.getBytes();
        imageStream.reset();
        var initialStreamPos = stream.pos;
        stream.pos = lexer.beginInlineImagePos;
        var dictBytes = stream.getBytes(dictLength);
        stream.pos = initialStreamPos;
        cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
        var cacheEntry = this.imageCache[cacheKey];

        if (cacheEntry !== undefined) {
          this.buf2 = _primitives.Cmd.get("EI");
          this.shift();
          cacheEntry.reset();
          return cacheEntry;
        }
      }

      if (cipherTransform) {
        imageStream = cipherTransform.createStream(imageStream, length);
      }

      imageStream = this.filter(imageStream, dict, length);
      imageStream.dict = dict;

      if (cacheKey !== undefined) {
        imageStream.cacheKey = "inline_".concat(length, "_").concat(cacheKey);
        this.imageCache[cacheKey] = imageStream;
      }

      this.buf2 = _primitives.Cmd.get("EI");
      this.shift();
      return imageStream;
    }
  }, {
    key: "_findStreamLength",
    value: function _findStreamLength(startPos, signature) {
      var stream = this.lexer.stream;
      stream.pos = startPos;
      var SCAN_BLOCK_LENGTH = 2048;
      var signatureLength = signature.length;

      while (stream.pos < stream.end) {
        var scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
        var scanLength = scanBytes.length - signatureLength;

        if (scanLength <= 0) {
          break;
        }

        var pos = 0;

        while (pos < scanLength) {
          var j = 0;

          while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
            j++;
          }

          if (j >= signatureLength) {
            stream.pos += pos;
            return stream.pos - startPos;
          }

          pos++;
        }

        stream.pos += scanLength;
      }

      return -1;
    }
  }, {
    key: "makeStream",
    value: function makeStream(dict, cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      lexer.skipToNextLine();
      var startPos = stream.pos - 1;
      var length = dict.get("Length");

      if (!Number.isInteger(length)) {
        (0, _util.info)("Bad length \"".concat(length, "\" in stream"));
        length = 0;
      }

      stream.pos = startPos + length;
      lexer.nextChar();

      if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
        this.shift();
      } else {
        var ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6E, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D]);

        var actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);

        if (actualLength < 0) {
          var MAX_TRUNCATION = 1;

          for (var i = 1; i <= MAX_TRUNCATION; i++) {
            var end = ENDSTREAM_SIGNATURE.length - i;
            var TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);

            var maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);

            if (maybeLength >= 0) {
              var lastByte = stream.peekBytes(end + 1)[end];

              if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
                break;
              }

              (0, _util.info)("Found \"".concat((0, _util.bytesToString)(TRUNCATED_SIGNATURE), "\" when ") + "searching for endstream command.");
              actualLength = maybeLength;
              break;
            }
          }

          if (actualLength < 0) {
            throw new _util.FormatError("Missing endstream command.");
          }
        }

        length = actualLength;
        lexer.nextChar();
        this.shift();
        this.shift();
      }

      this.shift();
      stream = stream.makeSubStream(startPos, length, dict);

      if (cipherTransform) {
        stream = cipherTransform.createStream(stream, length);
      }

      stream = this.filter(stream, dict, length);
      stream.dict = dict;
      return stream;
    }
  }, {
    key: "filter",
    value: function filter(stream, dict, length) {
      var filter = dict.get("Filter", "F");
      var params = dict.get("DecodeParms", "DP");

      if ((0, _primitives.isName)(filter)) {
        if (Array.isArray(params)) {
          (0, _util.warn)("/DecodeParms should not contain an Array, " + "when /Filter contains a Name.");
        }

        return this.makeFilter(stream, filter.name, length, params);
      }

      var maybeLength = length;

      if (Array.isArray(filter)) {
        var filterArray = filter;
        var paramsArray = params;

        for (var i = 0, ii = filterArray.length; i < ii; ++i) {
          filter = this.xref.fetchIfRef(filterArray[i]);

          if (!(0, _primitives.isName)(filter)) {
            throw new _util.FormatError("Bad filter name \"".concat(filter, "\""));
          }

          params = null;

          if (Array.isArray(paramsArray) && i in paramsArray) {
            params = this.xref.fetchIfRef(paramsArray[i]);
          }

          stream = this.makeFilter(stream, filter.name, maybeLength, params);
          maybeLength = null;
        }
      }

      return stream;
    }
  }, {
    key: "makeFilter",
    value: function makeFilter(stream, name, maybeLength, params) {
      if (maybeLength === 0) {
        (0, _util.warn)("Empty \"".concat(name, "\" stream."));
        return new _stream.NullStream();
      }

      try {
        var xrefStreamStats = this.xref.stats.streamTypes;

        if (name === "FlateDecode" || name === "Fl") {
          xrefStreamStats[_util.StreamType.FLATE] = true;

          if (params) {
            return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
          }

          return new _stream.FlateStream(stream, maybeLength);
        }

        if (name === "LZWDecode" || name === "LZW") {
          xrefStreamStats[_util.StreamType.LZW] = true;
          var earlyChange = 1;

          if (params) {
            if (params.has("EarlyChange")) {
              earlyChange = params.get("EarlyChange");
            }

            return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
          }

          return new _stream.LZWStream(stream, maybeLength, earlyChange);
        }

        if (name === "DCTDecode" || name === "DCT") {
          xrefStreamStats[_util.StreamType.DCT] = true;
          return new _jpeg_stream.JpegStream(stream, maybeLength, stream.dict, params);
        }

        if (name === "JPXDecode" || name === "JPX") {
          xrefStreamStats[_util.StreamType.JPX] = true;
          return new _jpx_stream.JpxStream(stream, maybeLength, stream.dict, params);
        }

        if (name === "ASCII85Decode" || name === "A85") {
          xrefStreamStats[_util.StreamType.A85] = true;
          return new _stream.Ascii85Stream(stream, maybeLength);
        }

        if (name === "ASCIIHexDecode" || name === "AHx") {
          xrefStreamStats[_util.StreamType.AHX] = true;
          return new _stream.AsciiHexStream(stream, maybeLength);
        }

        if (name === "CCITTFaxDecode" || name === "CCF") {
          xrefStreamStats[_util.StreamType.CCF] = true;
          return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
        }

        if (name === "RunLengthDecode" || name === "RL") {
          xrefStreamStats[_util.StreamType.RLX] = true;
          return new _stream.RunLengthStream(stream, maybeLength);
        }

        if (name === "JBIG2Decode") {
          xrefStreamStats[_util.StreamType.JBIG] = true;
          return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
        }

        (0, _util.warn)("Filter \"".concat(name, "\" is not supported."));
        return stream;
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Invalid stream: \"".concat(ex, "\""));
        return new _stream.NullStream();
      }
    }
  }]);

  return Parser;
}();

exports.Parser = Parser;
var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function toHexDigit(ch) {
  if (ch >= 0x30 && ch <= 0x39) {
    return ch & 0x0f;
  }

  if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
    return (ch & 0x0f) + 9;
  }

  return -1;
}

var Lexer = /*#__PURE__*/function () {
  function Lexer(stream) {
    var knownCommands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Lexer);

    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }

  _createClass(Lexer, [{
    key: "nextChar",
    value: function nextChar() {
      return this.currentChar = this.stream.getByte();
    }
  }, {
    key: "peekChar",
    value: function peekChar() {
      return this.stream.peekByte();
    }
  }, {
    key: "getNumber",
    value: function getNumber() {
      var ch = this.currentChar;
      var eNotation = false;
      var divideBy = 0;
      var sign = 0;

      if (ch === 0x2d) {
        sign = -1;
        ch = this.nextChar();

        if (ch === 0x2d) {
          ch = this.nextChar();
        }
      } else if (ch === 0x2b) {
        sign = 1;
        ch = this.nextChar();
      }

      if (ch === 0x0a || ch === 0x0d) {
        do {
          ch = this.nextChar();
        } while (ch === 0x0a || ch === 0x0d);
      }

      if (ch === 0x2e) {
        divideBy = 10;
        ch = this.nextChar();
      }

      if (ch < 0x30 || ch > 0x39) {
        if (divideBy === 10 && sign === 0 && ((0, _core_utils.isWhiteSpace)(ch) || ch === -1)) {
          (0, _util.warn)("Lexer.getNumber - treating a single decimal point as zero.");
          return 0;
        }

        throw new _util.FormatError("Invalid number: ".concat(String.fromCharCode(ch), " (charCode ").concat(ch, ")"));
      }

      sign = sign || 1;
      var baseValue = ch - 0x30;
      var powerValue = 0;
      var powerValueSign = 1;

      while ((ch = this.nextChar()) >= 0) {
        if (ch >= 0x30 && ch <= 0x39) {
          var currentDigit = ch - 0x30;

          if (eNotation) {
            powerValue = powerValue * 10 + currentDigit;
          } else {
            if (divideBy !== 0) {
              divideBy *= 10;
            }

            baseValue = baseValue * 10 + currentDigit;
          }
        } else if (ch === 0x2e) {
          if (divideBy === 0) {
            divideBy = 1;
          } else {
            break;
          }
        } else if (ch === 0x2d) {
          (0, _util.warn)("Badly formatted number: minus sign in the middle");
        } else if (ch === 0x45 || ch === 0x65) {
          ch = this.peekChar();

          if (ch === 0x2b || ch === 0x2d) {
            powerValueSign = ch === 0x2d ? -1 : 1;
            this.nextChar();
          } else if (ch < 0x30 || ch > 0x39) {
            break;
          }

          eNotation = true;
        } else {
          break;
        }
      }

      if (divideBy !== 0) {
        baseValue /= divideBy;
      }

      if (eNotation) {
        baseValue *= Math.pow(10, powerValueSign * powerValue);
      }

      return sign * baseValue;
    }
  }, {
    key: "getString",
    value: function getString() {
      var numParen = 1;
      var done = false;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.nextChar();

      while (true) {
        var charBuffered = false;

        switch (ch | 0) {
          case -1:
            (0, _util.warn)("Unterminated string");
            done = true;
            break;

          case 0x28:
            ++numParen;
            strBuf.push("(");
            break;

          case 0x29:
            if (--numParen === 0) {
              this.nextChar();
              done = true;
            } else {
              strBuf.push(")");
            }

            break;

          case 0x5c:
            ch = this.nextChar();

            switch (ch) {
              case -1:
                (0, _util.warn)("Unterminated string");
                done = true;
                break;

              case 0x6e:
                strBuf.push("\n");
                break;

              case 0x72:
                strBuf.push("\r");
                break;

              case 0x74:
                strBuf.push("\t");
                break;

              case 0x62:
                strBuf.push("\b");
                break;

              case 0x66:
                strBuf.push("\f");
                break;

              case 0x5c:
              case 0x28:
              case 0x29:
                strBuf.push(String.fromCharCode(ch));
                break;

              case 0x30:
              case 0x31:
              case 0x32:
              case 0x33:
              case 0x34:
              case 0x35:
              case 0x36:
              case 0x37:
                var x = ch & 0x0f;
                ch = this.nextChar();
                charBuffered = true;

                if (ch >= 0x30 && ch <= 0x37) {
                  x = (x << 3) + (ch & 0x0f);
                  ch = this.nextChar();

                  if (ch >= 0x30 && ch <= 0x37) {
                    charBuffered = false;
                    x = (x << 3) + (ch & 0x0f);
                  }
                }

                strBuf.push(String.fromCharCode(x));
                break;

              case 0x0d:
                if (this.peekChar() === 0x0a) {
                  this.nextChar();
                }

                break;

              case 0x0a:
                break;

              default:
                strBuf.push(String.fromCharCode(ch));
                break;
            }

            break;

          default:
            strBuf.push(String.fromCharCode(ch));
            break;
        }

        if (done) {
          break;
        }

        if (!charBuffered) {
          ch = this.nextChar();
        }
      }

      return strBuf.join("");
    }
  }, {
    key: "getName",
    value: function getName() {
      var ch, previousCh;
      var strBuf = this.strBuf;
      strBuf.length = 0;

      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        if (ch === 0x23) {
          ch = this.nextChar();

          if (specialChars[ch]) {
            (0, _util.warn)("Lexer_getName: " + "NUMBER SIGN (#) should be followed by a hexadecimal number.");
            strBuf.push("#");
            break;
          }

          var x = toHexDigit(ch);

          if (x !== -1) {
            previousCh = ch;
            ch = this.nextChar();
            var x2 = toHexDigit(ch);

            if (x2 === -1) {
              (0, _util.warn)("Lexer_getName: Illegal digit (".concat(String.fromCharCode(ch), ") ") + "in hexadecimal number.");
              strBuf.push("#", String.fromCharCode(previousCh));

              if (specialChars[ch]) {
                break;
              }

              strBuf.push(String.fromCharCode(ch));
              continue;
            }

            strBuf.push(String.fromCharCode(x << 4 | x2));
          } else {
            strBuf.push("#", String.fromCharCode(ch));
          }
        } else {
          strBuf.push(String.fromCharCode(ch));
        }
      }

      if (strBuf.length > 127) {
        (0, _util.warn)("Name token is longer than allowed by the spec: ".concat(strBuf.length));
      }

      return _primitives.Name.get(strBuf.join(""));
    }
  }, {
    key: "_hexStringWarn",
    value: function _hexStringWarn(ch) {
      var MAX_HEX_STRING_NUM_WARN = 5;

      if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
        (0, _util.warn)("getHexString - ignoring additional invalid characters.");
        return;
      }

      if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
        return;
      }

      (0, _util.warn)("getHexString - ignoring invalid character: ".concat(ch));
    }
  }, {
    key: "getHexString",
    value: function getHexString() {
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.currentChar;
      var isFirstHex = true;
      var firstDigit, secondDigit;
      this._hexStringNumWarn = 0;

      while (true) {
        if (ch < 0) {
          (0, _util.warn)("Unterminated hex string");
          break;
        } else if (ch === 0x3e) {
          this.nextChar();
          break;
        } else if (specialChars[ch] === 1) {
          ch = this.nextChar();
          continue;
        } else {
          if (isFirstHex) {
            firstDigit = toHexDigit(ch);

            if (firstDigit === -1) {
              this._hexStringWarn(ch);

              ch = this.nextChar();
              continue;
            }
          } else {
            secondDigit = toHexDigit(ch);

            if (secondDigit === -1) {
              this._hexStringWarn(ch);

              ch = this.nextChar();
              continue;
            }

            strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
          }

          isFirstHex = !isFirstHex;
          ch = this.nextChar();
        }
      }

      return strBuf.join("");
    }
  }, {
    key: "getObj",
    value: function getObj() {
      var comment = false;
      var ch = this.currentChar;

      while (true) {
        if (ch < 0) {
          return _primitives.EOF;
        }

        if (comment) {
          if (ch === 0x0a || ch === 0x0d) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (specialChars[ch] !== 1) {
          break;
        }

        ch = this.nextChar();
      }

      switch (ch | 0) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 0x2b:
        case 0x2d:
        case 0x2e:
          return this.getNumber();

        case 0x28:
          return this.getString();

        case 0x2f:
          return this.getName();

        case 0x5b:
          this.nextChar();
          return _primitives.Cmd.get("[");

        case 0x5d:
          this.nextChar();
          return _primitives.Cmd.get("]");

        case 0x3c:
          ch = this.nextChar();

          if (ch === 0x3c) {
            this.nextChar();
            return _primitives.Cmd.get("<<");
          }

          return this.getHexString();

        case 0x3e:
          ch = this.nextChar();

          if (ch === 0x3e) {
            this.nextChar();
            return _primitives.Cmd.get(">>");
          }

          return _primitives.Cmd.get(">");

        case 0x7b:
          this.nextChar();
          return _primitives.Cmd.get("{");

        case 0x7d:
          this.nextChar();
          return _primitives.Cmd.get("}");

        case 0x29:
          this.nextChar();
          throw new _util.FormatError("Illegal character: ".concat(ch));
      }

      var str = String.fromCharCode(ch);
      var knownCommands = this.knownCommands;
      var knownCommandFound = knownCommands && knownCommands[str] !== undefined;

      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        var possibleCommand = str + String.fromCharCode(ch);

        if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
          break;
        }

        if (str.length === 128) {
          throw new _util.FormatError("Command token too long: ".concat(str.length));
        }

        str = possibleCommand;
        knownCommandFound = knownCommands && knownCommands[str] !== undefined;
      }

      if (str === "true") {
        return true;
      }

      if (str === "false") {
        return false;
      }

      if (str === "null") {
        return null;
      }

      if (str === "BI") {
        this.beginInlineImagePos = this.stream.pos;
      }

      return _primitives.Cmd.get(str);
    }
  }, {
    key: "peekObj",
    value: function peekObj() {
      var streamPos = this.stream.pos,
          currentChar = this.currentChar,
          beginInlineImagePos = this.beginInlineImagePos;
      var nextObj;

      try {
        nextObj = this.getObj();
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("peekObj: ".concat(ex));
      }

      this.stream.pos = streamPos;
      this.currentChar = currentChar;
      this.beginInlineImagePos = beginInlineImagePos;
      return nextObj;
    }
  }, {
    key: "skipToNextLine",
    value: function skipToNextLine() {
      var ch = this.currentChar;

      while (ch >= 0) {
        if (ch === 0x0d) {
          ch = this.nextChar();

          if (ch === 0x0a) {
            this.nextChar();
          }

          break;
        } else if (ch === 0x0a) {
          this.nextChar();
          break;
        }

        ch = this.nextChar();
      }
    }
  }]);

  return Lexer;
}();

exports.Lexer = Lexer;

var Linearization = /*#__PURE__*/function () {
  function Linearization() {
    _classCallCheck(this, Linearization);
  }

  _createClass(Linearization, null, [{
    key: "create",
    value: function create(stream) {
      function getInt(linDict, name) {
        var allowZeroValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var obj = linDict.get(name);

        if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
          return obj;
        }

        throw new Error("The \"".concat(name, "\" parameter in the linearization ") + "dictionary is invalid.");
      }

      function getHints(linDict) {
        var hints = linDict.get("H");
        var hintsLength;

        if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
          for (var index = 0; index < hintsLength; index++) {
            var hint = hints[index];

            if (!(Number.isInteger(hint) && hint > 0)) {
              throw new Error("Hint (".concat(index, ") in the linearization dictionary is invalid."));
            }
          }

          return hints;
        }

        throw new Error("Hint array in the linearization dictionary is invalid.");
      }

      var parser = new Parser({
        lexer: new Lexer(stream),
        xref: null
      });
      var obj1 = parser.getObj();
      var obj2 = parser.getObj();
      var obj3 = parser.getObj();
      var linDict = parser.getObj();
      var obj, length;

      if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
        return null;
      } else if ((length = getInt(linDict, "L")) !== stream.length) {
        throw new Error('The "L" parameter in the linearization dictionary ' + "does not equal the stream length.");
      }

      return {
        length: length,
        hints: getHints(linDict),
        objectNumberFirst: getInt(linDict, "O"),
        endFirst: getInt(linDict, "E"),
        numPages: getInt(linDict, "N"),
        mainXRefEntriesOffset: getInt(linDict, "T"),
        pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
      };
    }
  }]);

  return Linearization;
}();

exports.Linearization = Linearization;

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StringStream = exports.StreamsSequenceStream = exports.Stream = exports.RunLengthStream = exports.PredictorStream = exports.NullStream = exports.LZWStream = exports.FlateStream = exports.DecryptStream = exports.DecodeStream = exports.AsciiHexStream = exports.Ascii85Stream = void 0;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Stream = function StreamClosure() {
  function Stream(arrayBuffer, start, length, dict) {
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }

  Stream.prototype = {
    get length() {
      return this.end - this.start;
    },

    get isEmpty() {
      return this.length === 0;
    },

    getByte: function Stream_getByte() {
      if (this.pos >= this.end) {
        return -1;
      }

      return this.bytes[this.pos++];
    },
    getUint16: function Stream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();

      if (b0 === -1 || b1 === -1) {
        return -1;
      }

      return (b0 << 8) + b1;
    },
    getInt32: function Stream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function getBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;

      if (!length) {
        var _subarray = bytes.subarray(pos, strEnd);

        return forceClamped ? new Uint8ClampedArray(_subarray) : _subarray;
      }

      var end = pos + length;

      if (end > strEnd) {
        end = strEnd;
      }

      this.pos = end;
      var subarray = bytes.subarray(pos, end);
      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
    },
    peekByte: function Stream_peekByte() {
      var peekedByte = this.getByte();

      if (peekedByte !== -1) {
        this.pos--;
      }

      return peekedByte;
    },
    peekBytes: function peekBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bytes = this.getBytes(length, forceClamped);
      this.pos -= bytes.length;
      return bytes;
    },
    getByteRange: function getByteRange(begin, end) {
      if (begin < 0) {
        begin = 0;
      }

      if (end > this.end) {
        end = this.end;
      }

      return this.bytes.subarray(begin, end);
    },
    skip: function Stream_skip(n) {
      if (!n) {
        n = 1;
      }

      this.pos += n;
    },
    reset: function Stream_reset() {
      this.pos = this.start;
    },
    moveStart: function Stream_moveStart() {
      this.start = this.pos;
    },
    makeSubStream: function Stream_makeSubStream(start, length, dict) {
      return new Stream(this.bytes.buffer, start, length, dict);
    }
  };
  return Stream;
}();

exports.Stream = Stream;

var StringStream = function StringStreamClosure() {
  function StringStream(str) {
    var bytes = (0, _util.stringToBytes)(str);
    Stream.call(this, bytes);
  }

  StringStream.prototype = Stream.prototype;
  return StringStream;
}();

exports.StringStream = StringStream;

var DecodeStream = function DecodeStreamClosure() {
  var emptyBuffer = new Uint8Array(0);

  function DecodeStream(maybeMinBufferLength) {
    this._rawMinBufferLength = maybeMinBufferLength || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;

    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }

  DecodeStream.prototype = {
    get length() {
      (0, _util.unreachable)("Should not access DecodeStream.length");
    },

    get isEmpty() {
      while (!this.eof && this.bufferLength === 0) {
        this.readBlock();
      }

      return this.bufferLength === 0;
    },

    ensureBuffer: function DecodeStream_ensureBuffer(requested) {
      var buffer = this.buffer;

      if (requested <= buffer.byteLength) {
        return buffer;
      }

      var size = this.minBufferLength;

      while (size < requested) {
        size *= 2;
      }

      var buffer2 = new Uint8Array(size);
      buffer2.set(buffer);
      return this.buffer = buffer2;
    },
    getByte: function DecodeStream_getByte() {
      var pos = this.pos;

      while (this.bufferLength <= pos) {
        if (this.eof) {
          return -1;
        }

        this.readBlock();
      }

      return this.buffer[this.pos++];
    },
    getUint16: function DecodeStream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();

      if (b0 === -1 || b1 === -1) {
        return -1;
      }

      return (b0 << 8) + b1;
    },
    getInt32: function DecodeStream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function getBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var end,
          pos = this.pos;

      if (length) {
        this.ensureBuffer(pos + length);
        end = pos + length;

        while (!this.eof && this.bufferLength < end) {
          this.readBlock();
        }

        var bufEnd = this.bufferLength;

        if (end > bufEnd) {
          end = bufEnd;
        }
      } else {
        while (!this.eof) {
          this.readBlock();
        }

        end = this.bufferLength;
      }

      this.pos = end;
      var subarray = this.buffer.subarray(pos, end);
      return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
    },
    peekByte: function DecodeStream_peekByte() {
      var peekedByte = this.getByte();

      if (peekedByte !== -1) {
        this.pos--;
      }

      return peekedByte;
    },
    peekBytes: function peekBytes(length) {
      var forceClamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bytes = this.getBytes(length, forceClamped);
      this.pos -= bytes.length;
      return bytes;
    },
    makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
      var end = start + length;

      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }

      return new Stream(this.buffer, start, length, dict);
    },
    getByteRange: function getByteRange(begin, end) {
      (0, _util.unreachable)("Should not call DecodeStream.getByteRange");
    },
    skip: function DecodeStream_skip(n) {
      if (!n) {
        n = 1;
      }

      this.pos += n;
    },
    reset: function DecodeStream_reset() {
      this.pos = 0;
    },
    getBaseStreams: function DecodeStream_getBaseStreams() {
      if (this.str && this.str.getBaseStreams) {
        return this.str.getBaseStreams();
      }

      return [];
    }
  };
  return DecodeStream;
}();

exports.DecodeStream = DecodeStream;

var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
  function StreamsSequenceStream(streams) {
    this.streams = streams;
    var maybeLength = 0;

    for (var i = 0, ii = streams.length; i < ii; i++) {
      var stream = streams[i];

      if (stream instanceof DecodeStream) {
        maybeLength += stream._rawMinBufferLength;
      } else {
        maybeLength += stream.length;
      }
    }

    DecodeStream.call(this, maybeLength);
  }

  StreamsSequenceStream.prototype = Object.create(DecodeStream.prototype);

  StreamsSequenceStream.prototype.readBlock = function streamSequenceStreamReadBlock() {
    var streams = this.streams;

    if (streams.length === 0) {
      this.eof = true;
      return;
    }

    var stream = streams.shift();
    var chunk = stream.getBytes();
    var bufferLength = this.bufferLength;
    var newLength = bufferLength + chunk.length;
    var buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  };

  StreamsSequenceStream.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
    var baseStreams = [];

    for (var i = 0, ii = this.streams.length; i < ii; i++) {
      var stream = this.streams[i];

      if (stream.getBaseStreams) {
        baseStreams.push.apply(baseStreams, _toConsumableArray(stream.getBaseStreams()));
      }
    }

    return baseStreams;
  };

  return StreamsSequenceStream;
}();

exports.StreamsSequenceStream = StreamsSequenceStream;

var FlateStream = function FlateStreamClosure() {
  var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
  var distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
  var fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
  var fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];

  function FlateStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    var cmf = str.getByte();
    var flg = str.getByte();

    if (cmf === -1 || flg === -1) {
      throw new _util.FormatError("Invalid header in flate stream: ".concat(cmf, ", ").concat(flg));
    }

    if ((cmf & 0x0f) !== 0x08) {
      throw new _util.FormatError("Unknown compression method in flate stream: ".concat(cmf, ", ").concat(flg));
    }

    if (((cmf << 8) + flg) % 31 !== 0) {
      throw new _util.FormatError("Bad FCHECK in flate stream: ".concat(cmf, ", ").concat(flg));
    }

    if (flg & 0x20) {
      throw new _util.FormatError("FDICT bit set in flate stream: ".concat(cmf, ", ").concat(flg));
    }

    this.codeSize = 0;
    this.codeBuf = 0;
    DecodeStream.call(this, maybeLength);
  }

  FlateStream.prototype = Object.create(DecodeStream.prototype);

  FlateStream.prototype.getBits = function FlateStream_getBits(bits) {
    var str = this.str;
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;

    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad encoding in flate stream");
      }

      codeBuf |= b << codeSize;
      codeSize += 8;
    }

    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  };

  FlateStream.prototype.getCode = function FlateStream_getCode(table) {
    var str = this.str;
    var codes = table[0];
    var maxLen = table[1];
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;

    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }

      codeBuf |= b << codeSize;
      codeSize += 8;
    }

    var code = codes[codeBuf & (1 << maxLen) - 1];
    var codeLen = code >> 16;
    var codeVal = code & 0xffff;

    if (codeLen < 1 || codeSize < codeLen) {
      throw new _util.FormatError("Bad encoding in flate stream");
    }

    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  };

  FlateStream.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
    var n = lengths.length;
    var maxLen = 0;
    var i;

    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }

    var size = 1 << maxLen;
    var codes = new Int32Array(size);

    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (var val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          var code2 = 0;
          var t = code;

          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }

          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }

          ++code;
        }
      }
    }

    return [codes, maxLen];
  };

  FlateStream.prototype.readBlock = function FlateStream_readBlock() {
    var buffer, len;
    var str = this.str;
    var hdr = this.getBits(3);

    if (hdr & 1) {
      this.eof = true;
    }

    hdr >>= 1;

    if (hdr === 0) {
      var b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      var blockLen = b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      blockLen |= b << 8;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      var check = b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      check |= b << 8;

      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
        throw new _util.FormatError("Bad uncompressed block length in flate stream");
      }

      this.codeBuf = 0;
      this.codeSize = 0;
      var bufferLength = this.bufferLength,
          end = bufferLength + blockLen;
      buffer = this.ensureBuffer(end);
      this.bufferLength = end;

      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        var block = str.getBytes(blockLen);
        buffer.set(block, bufferLength);

        if (block.length < blockLen) {
          this.eof = true;
        }
      }

      return;
    }

    var litCodeTable;
    var distCodeTable;

    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      var numLitCodes = this.getBits(5) + 257;
      var numDistCodes = this.getBits(5) + 1;
      var numCodeLenCodes = this.getBits(4) + 4;
      var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      var i;

      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }

      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      var codes = numLitCodes + numDistCodes;
      var codeLengths = new Uint8Array(codes);
      var bitsLength, bitsOffset, what;

      while (i < codes) {
        var code = this.getCode(codeLenCodeTab);

        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }

        var repeatLength = this.getBits(bitsLength) + bitsOffset;

        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }

      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      throw new _util.FormatError("Unknown block type in flate stream");
    }

    buffer = this.buffer;
    var limit = buffer ? buffer.length : 0;
    var pos = this.bufferLength;

    while (true) {
      var code1 = this.getCode(litCodeTable);

      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }

        buffer[pos++] = code1;
        continue;
      }

      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }

      code1 -= 257;
      code1 = lengthDecode[code1];
      var code2 = code1 >> 16;

      if (code2 > 0) {
        code2 = this.getBits(code2);
      }

      len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;

      if (code2 > 0) {
        code2 = this.getBits(code2);
      }

      var dist = (code1 & 0xffff) + code2;

      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }

      for (var k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  };

  return FlateStream;
}();

exports.FlateStream = FlateStream;

var PredictorStream = function PredictorStreamClosure() {
  function PredictorStream(str, maybeLength, params) {
    if (!(0, _primitives.isDict)(params)) {
      return str;
    }

    var predictor = this.predictor = params.get("Predictor") || 1;

    if (predictor <= 1) {
      return str;
    }

    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new _util.FormatError("Unsupported predictor: ".concat(predictor));
    }

    if (predictor === 2) {
      this.readBlock = this.readBlockTiff;
    } else {
      this.readBlock = this.readBlockPng;
    }

    this.str = str;
    this.dict = str.dict;
    var colors = this.colors = params.get("Colors") || 1;
    var bits = this.bits = params.get("BitsPerComponent") || 8;
    var columns = this.columns = params.get("Columns") || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    DecodeStream.call(this, maybeLength);
    return this;
  }

  PredictorStream.prototype = Object.create(DecodeStream.prototype);

  PredictorStream.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
    var rowBytes = this.rowBytes;
    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var bits = this.bits;
    var colors = this.colors;
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;

    if (this.eof) {
      return;
    }

    var inbuf = 0,
        outbuf = 0;
    var inbits = 0,
        outbits = 0;
    var pos = bufferLength;
    var i;

    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        var c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }

      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else if (bits === 16) {
      var bytesPerPixel = colors * 2;

      for (i = 0; i < bytesPerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }

      for (; i < rowBytes; i += 2) {
        var sum = ((rawBytes[i] & 0xff) << 8) + (rawBytes[i + 1] & 0xff) + ((buffer[pos - bytesPerPixel] & 0xff) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xff);
        buffer[pos++] = sum >> 8 & 0xff;
        buffer[pos++] = sum & 0xff;
      }
    } else {
      var compArray = new Uint8Array(colors + 1);
      var bitMask = (1 << bits) - 1;
      var j = 0,
          k = bufferLength;
      var columns = this.columns;

      for (i = 0; i < columns; ++i) {
        for (var kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xff;
            inbits += 8;
          }

          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;

          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xff;
            outbits -= 8;
          }
        }
      }

      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }

    this.bufferLength += rowBytes;
  };

  PredictorStream.prototype.readBlockPng = function predictorStreamReadBlockPng() {
    var rowBytes = this.rowBytes;
    var pixBytes = this.pixBytes;
    var predictor = this.str.getByte();
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;

    if (this.eof) {
      return;
    }

    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);

    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }

    var i,
        j = bufferLength,
        up,
        c;

    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }

        break;

      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }

        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xff;
          j++;
        }

        break;

      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xff;
        }

        break;

      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }

        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xff;
          j++;
        }

        break;

      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }

        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          var upLeft = prevRow[i - pixBytes];
          var left = buffer[j - pixBytes];
          var p = left + up - upLeft;
          var pa = p - left;

          if (pa < 0) {
            pa = -pa;
          }

          var pb = p - up;

          if (pb < 0) {
            pb = -pb;
          }

          var pc = p - upLeft;

          if (pc < 0) {
            pc = -pc;
          }

          c = rawBytes[i];

          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }

        break;

      default:
        throw new _util.FormatError("Unsupported predictor: ".concat(predictor));
    }

    this.bufferLength += rowBytes;
  };

  return PredictorStream;
}();

exports.PredictorStream = PredictorStream;

var DecryptStream = function DecryptStreamClosure() {
  function DecryptStream(str, maybeLength, decrypt) {
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
    DecodeStream.call(this, maybeLength);
  }

  var chunkSize = 512;
  DecryptStream.prototype = Object.create(DecodeStream.prototype);

  DecryptStream.prototype.readBlock = function DecryptStream_readBlock() {
    var chunk;

    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }

    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }

    this.nextChunk = this.str.getBytes(chunkSize);
    var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
    var decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    var bufferLength = this.bufferLength;
    var i,
        n = chunk.length;
    var buffer = this.ensureBuffer(bufferLength + n);

    for (i = 0; i < n; i++) {
      buffer[bufferLength++] = chunk[i];
    }

    this.bufferLength = bufferLength;
  };

  return DecryptStream;
}();

exports.DecryptStream = DecryptStream;

var Ascii85Stream = function Ascii85StreamClosure() {
  function Ascii85Stream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);

    if (maybeLength) {
      maybeLength = 0.8 * maybeLength;
    }

    DecodeStream.call(this, maybeLength);
  }

  Ascii85Stream.prototype = Object.create(DecodeStream.prototype);

  Ascii85Stream.prototype.readBlock = function Ascii85Stream_readBlock() {
    var TILDA_CHAR = 0x7e;
    var Z_LOWER_CHAR = 0x7a;
    var EOF = -1;
    var str = this.str;
    var c = str.getByte();

    while ((0, _core_utils.isWhiteSpace)(c)) {
      c = str.getByte();
    }

    if (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }

    var bufferLength = this.bufferLength,
        buffer;
    var i;

    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);

      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }

      this.bufferLength += 4;
    } else {
      var input = this.input;
      input[0] = c;

      for (i = 1; i < 5; ++i) {
        c = str.getByte();

        while ((0, _core_utils.isWhiteSpace)(c)) {
          c = str.getByte();
        }

        input[i] = c;

        if (c === EOF || c === TILDA_CHAR) {
          break;
        }
      }

      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;

      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }

        this.eof = true;
      }

      var t = 0;

      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }

      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 0xff;
        t >>= 8;
      }
    }
  };

  return Ascii85Stream;
}();

exports.Ascii85Stream = Ascii85Stream;

var AsciiHexStream = function AsciiHexStreamClosure() {
  function AsciiHexStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;

    if (maybeLength) {
      maybeLength = 0.5 * maybeLength;
    }

    DecodeStream.call(this, maybeLength);
  }

  AsciiHexStream.prototype = Object.create(DecodeStream.prototype);

  AsciiHexStream.prototype.readBlock = function AsciiHexStream_readBlock() {
    var UPSTREAM_BLOCK_SIZE = 8000;
    var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);

    if (!bytes.length) {
      this.eof = true;
      return;
    }

    var maxDecodeLength = bytes.length + 1 >> 1;
    var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    var bufferLength = this.bufferLength;
    var firstDigit = this.firstDigit;

    for (var i = 0, ii = bytes.length; i < ii; i++) {
      var ch = bytes[i],
          digit;

      if (ch >= 0x30 && ch <= 0x39) {
        digit = ch & 0x0f;
      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
        digit = (ch & 0x0f) + 9;
      } else if (ch === 0x3e) {
        this.eof = true;
        break;
      } else {
        continue;
      }

      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }

    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }

    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  };

  return AsciiHexStream;
}();

exports.AsciiHexStream = AsciiHexStream;

var RunLengthStream = function RunLengthStreamClosure() {
  function RunLengthStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    DecodeStream.call(this, maybeLength);
  }

  RunLengthStream.prototype = Object.create(DecodeStream.prototype);

  RunLengthStream.prototype.readBlock = function RunLengthStream_readBlock() {
    var repeatHeader = this.str.getBytes(2);

    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }

    var buffer;
    var bufferLength = this.bufferLength;
    var n = repeatHeader[0];

    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];

      if (n > 0) {
        var source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      var b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);

      for (var i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }

    this.bufferLength = bufferLength;
  };

  return RunLengthStream;
}();

exports.RunLengthStream = RunLengthStream;

var LZWStream = function LZWStreamClosure() {
  function LZWStream(str, maybeLength, earlyChange) {
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    var maxLzwDictionarySize = 4096;
    var lzwState = {
      earlyChange: earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };

    for (var i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }

    this.lzwState = lzwState;
    DecodeStream.call(this, maybeLength);
  }

  LZWStream.prototype = Object.create(DecodeStream.prototype);

  LZWStream.prototype.readBits = function LZWStream_readBits(n) {
    var bitsCached = this.bitsCached;
    var cachedData = this.cachedData;

    while (bitsCached < n) {
      var c = this.str.getByte();

      if (c === -1) {
        this.eof = true;
        return null;
      }

      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }

    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  };

  LZWStream.prototype.readBlock = function LZWStream_readBlock() {
    var blockSize = 512;
    var estimatedDecodedSize = blockSize * 2,
        decodedSizeDelta = blockSize;
    var i, j, q;
    var lzwState = this.lzwState;

    if (!lzwState) {
      return;
    }

    var earlyChange = lzwState.earlyChange;
    var nextCode = lzwState.nextCode;
    var dictionaryValues = lzwState.dictionaryValues;
    var dictionaryLengths = lzwState.dictionaryLengths;
    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    var codeLength = lzwState.codeLength;
    var prevCode = lzwState.prevCode;
    var currentSequence = lzwState.currentSequence;
    var currentSequenceLength = lzwState.currentSequenceLength;
    var decodedLength = 0;
    var currentBufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);

    for (i = 0; i < blockSize; i++) {
      var code = this.readBits(codeLength);
      var hasPrev = currentSequenceLength > 0;

      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];

          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }

      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }

      prevCode = code;
      decodedLength += currentSequenceLength;

      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);

        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }

      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }

    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  };

  return LZWStream;
}();

exports.LZWStream = LZWStream;

var NullStream = function NullStreamClosure() {
  function NullStream() {
    Stream.call(this, new Uint8Array(0));
  }

  NullStream.prototype = Stream.prototype;
  return NullStream;
}();

exports.NullStream = NullStream;

/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxStream = void 0;

var _primitives = __w_pdfjs_require__(135);

var _ccitt = __w_pdfjs_require__(144);

var _stream = __w_pdfjs_require__(142);

var CCITTFaxStream = function CCITTFaxStreamClosure() {
  function CCITTFaxStream(str, maybeLength, params) {
    this.str = str;
    this.dict = str.dict;

    if (!(0, _primitives.isDict)(params)) {
      params = _primitives.Dict.empty;
    }

    var source = {
      next: function next() {
        return str.getByte();
      }
    };
    this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
      K: params.get("K"),
      EndOfLine: params.get("EndOfLine"),
      EncodedByteAlign: params.get("EncodedByteAlign"),
      Columns: params.get("Columns"),
      Rows: params.get("Rows"),
      EndOfBlock: params.get("EndOfBlock"),
      BlackIs1: params.get("BlackIs1")
    });

    _stream.DecodeStream.call(this, maybeLength);
  }

  CCITTFaxStream.prototype = Object.create(_stream.DecodeStream.prototype);

  CCITTFaxStream.prototype.readBlock = function () {
    while (!this.eof) {
      var c = this.ccittFaxDecoder.readNextChar();

      if (c === -1) {
        this.eof = true;
        return;
      }

      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = c;
    }
  };

  return CCITTFaxStream;
}();

exports.CCITTFaxStream = CCITTFaxStream;

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxDecoder = void 0;

var _util = __w_pdfjs_require__(4);

var CCITTFaxDecoder = function CCITTFaxDecoder() {
  var ccittEOL = -2;
  var ccittEOF = -1;
  var twoDimPass = 0;
  var twoDimHoriz = 1;
  var twoDimVert0 = 2;
  var twoDimVertR1 = 3;
  var twoDimVertL1 = 4;
  var twoDimVertR2 = 5;
  var twoDimVertL2 = 6;
  var twoDimVertR3 = 7;
  var twoDimVertL3 = 8;
  var twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
  var whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
  var whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
  var blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
  var blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
  var blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];

  function CCITTFaxDecoder(source) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!source || typeof source.next !== "function") {
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    }

    this.source = source;
    this.eof = false;
    this.encoding = options.K || 0;
    this.eoline = options.EndOfLine || false;
    this.byteAlign = options.EncodedByteAlign || false;
    this.columns = options.Columns || 1728;
    this.rows = options.Rows || 0;
    var eoblock = options.EndOfBlock;

    if (eoblock === null || eoblock === undefined) {
      eoblock = true;
    }

    this.eoblock = eoblock;
    this.black = options.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    var code1;

    while ((code1 = this._lookBits(12)) === 0) {
      this._eatBits(1);
    }

    if (code1 === 1) {
      this._eatBits(12);
    }

    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);

      this._eatBits(1);
    }
  }

  CCITTFaxDecoder.prototype = {
    readNextChar: function readNextChar() {
      if (this.eof) {
        return -1;
      }

      var refLine = this.refLine;
      var codingLine = this.codingLine;
      var columns = this.columns;
      var refPos, blackPixels, bits, i;

      if (this.outputBits === 0) {
        if (this.rowsDone) {
          this.eof = true;
        }

        if (this.eof) {
          return -1;
        }

        this.err = false;
        var code1, code2, code3;

        if (this.nextLine2D) {
          for (i = 0; codingLine[i] < columns; ++i) {
            refLine[i] = codingLine[i];
          }

          refLine[i++] = columns;
          refLine[i] = columns;
          codingLine[0] = 0;
          this.codingPos = 0;
          refPos = 0;
          blackPixels = 0;

          while (codingLine[this.codingPos] < columns) {
            code1 = this._getTwoDimCode();

            switch (code1) {
              case twoDimPass:
                this._addPixels(refLine[refPos + 1], blackPixels);

                if (refLine[refPos + 1] < columns) {
                  refPos += 2;
                }

                break;

              case twoDimHoriz:
                code1 = code2 = 0;

                if (blackPixels) {
                  do {
                    code1 += code3 = this._getBlackCode();
                  } while (code3 >= 64);

                  do {
                    code2 += code3 = this._getWhiteCode();
                  } while (code3 >= 64);
                } else {
                  do {
                    code1 += code3 = this._getWhiteCode();
                  } while (code3 >= 64);

                  do {
                    code2 += code3 = this._getBlackCode();
                  } while (code3 >= 64);
                }

                this._addPixels(codingLine[this.codingPos] + code1, blackPixels);

                if (codingLine[this.codingPos] < columns) {
                  this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                }

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }

                break;

              case twoDimVertR3:
                this._addPixels(refLine[refPos] + 3, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  ++refPos;

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVertR2:
                this._addPixels(refLine[refPos] + 2, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  ++refPos;

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVertR1:
                this._addPixels(refLine[refPos] + 1, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  ++refPos;

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVert0:
                this._addPixels(refLine[refPos], blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  ++refPos;

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVertL3:
                this._addPixelsNeg(refLine[refPos] - 3, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  if (refPos > 0) {
                    --refPos;
                  } else {
                    ++refPos;
                  }

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVertL2:
                this._addPixelsNeg(refLine[refPos] - 2, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  if (refPos > 0) {
                    --refPos;
                  } else {
                    ++refPos;
                  }

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case twoDimVertL1:
                this._addPixelsNeg(refLine[refPos] - 1, blackPixels);

                blackPixels ^= 1;

                if (codingLine[this.codingPos] < columns) {
                  if (refPos > 0) {
                    --refPos;
                  } else {
                    ++refPos;
                  }

                  while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                    refPos += 2;
                  }
                }

                break;

              case ccittEOF:
                this._addPixels(columns, 0);

                this.eof = true;
                break;

              default:
                (0, _util.info)("bad 2d code");

                this._addPixels(columns, 0);

                this.err = true;
            }
          }
        } else {
          codingLine[0] = 0;
          this.codingPos = 0;
          blackPixels = 0;

          while (codingLine[this.codingPos] < columns) {
            code1 = 0;

            if (blackPixels) {
              do {
                code1 += code3 = this._getBlackCode();
              } while (code3 >= 64);
            } else {
              do {
                code1 += code3 = this._getWhiteCode();
              } while (code3 >= 64);
            }

            this._addPixels(codingLine[this.codingPos] + code1, blackPixels);

            blackPixels ^= 1;
          }
        }

        var gotEOL = false;

        if (this.byteAlign) {
          this.inputBits &= ~7;
        }

        if (!this.eoblock && this.row === this.rows - 1) {
          this.rowsDone = true;
        } else {
          code1 = this._lookBits(12);

          if (this.eoline) {
            while (code1 !== ccittEOF && code1 !== 1) {
              this._eatBits(1);

              code1 = this._lookBits(12);
            }
          } else {
            while (code1 === 0) {
              this._eatBits(1);

              code1 = this._lookBits(12);
            }
          }

          if (code1 === 1) {
            this._eatBits(12);

            gotEOL = true;
          } else if (code1 === ccittEOF) {
            this.eof = true;
          }
        }

        if (!this.eof && this.encoding > 0 && !this.rowsDone) {
          this.nextLine2D = !this._lookBits(1);

          this._eatBits(1);
        }

        if (this.eoblock && gotEOL && this.byteAlign) {
          code1 = this._lookBits(12);

          if (code1 === 1) {
            this._eatBits(12);

            if (this.encoding > 0) {
              this._lookBits(1);

              this._eatBits(1);
            }

            if (this.encoding >= 0) {
              for (i = 0; i < 4; ++i) {
                code1 = this._lookBits(12);

                if (code1 !== 1) {
                  (0, _util.info)("bad rtc code: " + code1);
                }

                this._eatBits(12);

                if (this.encoding > 0) {
                  this._lookBits(1);

                  this._eatBits(1);
                }
              }
            }

            this.eof = true;
          }
        } else if (this.err && this.eoline) {
          while (true) {
            code1 = this._lookBits(13);

            if (code1 === ccittEOF) {
              this.eof = true;
              return -1;
            }

            if (code1 >> 1 === 1) {
              break;
            }

            this._eatBits(1);
          }

          this._eatBits(12);

          if (this.encoding > 0) {
            this._eatBits(1);

            this.nextLine2D = !(code1 & 1);
          }
        }

        if (codingLine[0] > 0) {
          this.outputBits = codingLine[this.codingPos = 0];
        } else {
          this.outputBits = codingLine[this.codingPos = 1];
        }

        this.row++;
      }

      var c;

      if (this.outputBits >= 8) {
        c = this.codingPos & 1 ? 0 : 0xff;
        this.outputBits -= 8;

        if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
          this.codingPos++;
          this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
        }
      } else {
        bits = 8;
        c = 0;

        do {
          if (this.outputBits > bits) {
            c <<= bits;

            if (!(this.codingPos & 1)) {
              c |= 0xff >> 8 - bits;
            }

            this.outputBits -= bits;
            bits = 0;
          } else {
            c <<= this.outputBits;

            if (!(this.codingPos & 1)) {
              c |= 0xff >> 8 - this.outputBits;
            }

            bits -= this.outputBits;
            this.outputBits = 0;

            if (codingLine[this.codingPos] < columns) {
              this.codingPos++;
              this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
            } else if (bits > 0) {
              c <<= bits;
              bits = 0;
            }
          }
        } while (bits);
      }

      if (this.black) {
        c ^= 0xff;
      }

      return c;
    },
    _addPixels: function _addPixels(a1, blackPixels) {
      var codingLine = this.codingLine;
      var codingPos = this.codingPos;

      if (a1 > codingLine[codingPos]) {
        if (a1 > this.columns) {
          (0, _util.info)("row is wrong length");
          this.err = true;
          a1 = this.columns;
        }

        if (codingPos & 1 ^ blackPixels) {
          ++codingPos;
        }

        codingLine[codingPos] = a1;
      }

      this.codingPos = codingPos;
    },
    _addPixelsNeg: function _addPixelsNeg(a1, blackPixels) {
      var codingLine = this.codingLine;
      var codingPos = this.codingPos;

      if (a1 > codingLine[codingPos]) {
        if (a1 > this.columns) {
          (0, _util.info)("row is wrong length");
          this.err = true;
          a1 = this.columns;
        }

        if (codingPos & 1 ^ blackPixels) {
          ++codingPos;
        }

        codingLine[codingPos] = a1;
      } else if (a1 < codingLine[codingPos]) {
        if (a1 < 0) {
          (0, _util.info)("invalid code");
          this.err = true;
          a1 = 0;
        }

        while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
          --codingPos;
        }

        codingLine[codingPos] = a1;
      }

      this.codingPos = codingPos;
    },
    _findTableCode: function _findTableCode(start, end, table, limit) {
      var limitValue = limit || 0;

      for (var i = start; i <= end; ++i) {
        var code = this._lookBits(i);

        if (code === ccittEOF) {
          return [true, 1, false];
        }

        if (i < end) {
          code <<= end - i;
        }

        if (!limitValue || code >= limitValue) {
          var p = table[code - limitValue];

          if (p[0] === i) {
            this._eatBits(i);

            return [true, p[1], true];
          }
        }
      }

      return [false, 0, false];
    },
    _getTwoDimCode: function _getTwoDimCode() {
      var code = 0;
      var p;

      if (this.eoblock) {
        code = this._lookBits(7);
        p = twoDimTable[code];

        if (p && p[0] > 0) {
          this._eatBits(p[0]);

          return p[1];
        }
      } else {
        var result = this._findTableCode(1, 7, twoDimTable);

        if (result[0] && result[2]) {
          return result[1];
        }
      }

      (0, _util.info)("Bad two dim code");
      return ccittEOF;
    },
    _getWhiteCode: function _getWhiteCode() {
      var code = 0;
      var p;

      if (this.eoblock) {
        code = this._lookBits(12);

        if (code === ccittEOF) {
          return 1;
        }

        if (code >> 5 === 0) {
          p = whiteTable1[code];
        } else {
          p = whiteTable2[code >> 3];
        }

        if (p[0] > 0) {
          this._eatBits(p[0]);

          return p[1];
        }
      } else {
        var result = this._findTableCode(1, 9, whiteTable2);

        if (result[0]) {
          return result[1];
        }

        result = this._findTableCode(11, 12, whiteTable1);

        if (result[0]) {
          return result[1];
        }
      }

      (0, _util.info)("bad white code");

      this._eatBits(1);

      return 1;
    },
    _getBlackCode: function _getBlackCode() {
      var code, p;

      if (this.eoblock) {
        code = this._lookBits(13);

        if (code === ccittEOF) {
          return 1;
        }

        if (code >> 7 === 0) {
          p = blackTable1[code];
        } else if (code >> 9 === 0 && code >> 7 !== 0) {
          p = blackTable2[(code >> 1) - 64];
        } else {
          p = blackTable3[code >> 7];
        }

        if (p[0] > 0) {
          this._eatBits(p[0]);

          return p[1];
        }
      } else {
        var result = this._findTableCode(2, 6, blackTable3);

        if (result[0]) {
          return result[1];
        }

        result = this._findTableCode(7, 12, blackTable2, 64);

        if (result[0]) {
          return result[1];
        }

        result = this._findTableCode(10, 13, blackTable1);

        if (result[0]) {
          return result[1];
        }
      }

      (0, _util.info)("bad black code");

      this._eatBits(1);

      return 1;
    },
    _lookBits: function _lookBits(n) {
      var c;

      while (this.inputBits < n) {
        if ((c = this.source.next()) === -1) {
          if (this.inputBits === 0) {
            return ccittEOF;
          }

          return this.inputBuf << n - this.inputBits & 0xffff >> 16 - n;
        }

        this.inputBuf = this.inputBuf << 8 | c;
        this.inputBits += 8;
      }

      return this.inputBuf >> this.inputBits - n & 0xffff >> 16 - n;
    },
    _eatBits: function _eatBits(n) {
      if ((this.inputBits -= n) < 0) {
        this.inputBits = 0;
      }
    }
  };
  return CCITTFaxDecoder;
}();

exports.CCITTFaxDecoder = CCITTFaxDecoder;

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Stream = void 0;

var _primitives = __w_pdfjs_require__(135);

var _stream = __w_pdfjs_require__(142);

var _jbig = __w_pdfjs_require__(146);

var _util = __w_pdfjs_require__(4);

var Jbig2Stream = function Jbig2StreamClosure() {
  function Jbig2Stream(stream, maybeLength, dict, params) {
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;

    _stream.DecodeStream.call(this, maybeLength);
  }

  Jbig2Stream.prototype = Object.create(_stream.DecodeStream.prototype);
  Object.defineProperty(Jbig2Stream.prototype, "bytes", {
    get: function get() {
      return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });

  Jbig2Stream.prototype.ensureBuffer = function (requested) {};

  Jbig2Stream.prototype.readBlock = function () {
    if (this.eof) {
      return;
    }

    var jbig2Image = new _jbig.Jbig2Image();
    var chunks = [];

    if ((0, _primitives.isDict)(this.params)) {
      var globalsStream = this.params.get("JBIG2Globals");

      if ((0, _primitives.isStream)(globalsStream)) {
        var globals = globalsStream.getBytes();
        chunks.push({
          data: globals,
          start: 0,
          end: globals.length
        });
      }
    }

    chunks.push({
      data: this.bytes,
      start: 0,
      end: this.bytes.length
    });
    var data = jbig2Image.parseChunks(chunks);
    var dataLength = data.length;

    for (var i = 0; i < dataLength; i++) {
      data[i] ^= 0xff;
    }

    this.buffer = data;
    this.bufferLength = dataLength;
    this.eof = true;
  };

  return Jbig2Stream;
}();

exports.Jbig2Stream = Jbig2Stream;

/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Image = void 0;

var _util = __w_pdfjs_require__(4);

var _core_utils = __w_pdfjs_require__(138);

var _arithmetic_decoder = __w_pdfjs_require__(147);

var _ccitt = __w_pdfjs_require__(144);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Jbig2Error = /*#__PURE__*/function (_BaseException) {
  _inherits(Jbig2Error, _BaseException);

  var _super = _createSuper(Jbig2Error);

  function Jbig2Error(msg) {
    _classCallCheck(this, Jbig2Error);

    return _super.call(this, "JBIG2 error: ".concat(msg));
  }

  return Jbig2Error;
}(_util.BaseException);

var Jbig2Image = function Jbig2ImageClosure() {
  function ContextCache() {}

  ContextCache.prototype = {
    getContexts: function getContexts(id) {
      if (id in this) {
        return this[id];
      }

      return this[id] = new Int8Array(1 << 16);
    }
  };

  function DecodingContext(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
  }

  DecodingContext.prototype = {
    get decoder() {
      var decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
      return (0, _util.shadow)(this, "decoder", decoder);
    },

    get contextCache() {
      var cache = new ContextCache();
      return (0, _util.shadow)(this, "contextCache", cache);
    }

  };

  function decodeInteger(contextCache, procedure, decoder) {
    var contexts = contextCache.getContexts(procedure);
    var prev = 1;

    function readBits(length) {
      var v = 0;

      for (var i = 0; i < length; i++) {
        var bit = decoder.readBit(contexts, prev);
        prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
        v = v << 1 | bit;
      }

      return v >>> 0;
    }

    var sign = readBits(1);
    var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);

    if (sign === 0) {
      return value;
    } else if (value > 0) {
      return -value;
    }

    return null;
  }

  function decodeIAID(contextCache, decoder, codeLength) {
    var contexts = contextCache.getContexts("IAID");
    var prev = 1;

    for (var i = 0; i < codeLength; i++) {
      var bit = decoder.readBit(contexts, prev);
      prev = prev << 1 | bit;
    }

    if (codeLength < 31) {
      return prev & (1 << codeLength) - 1;
    }

    return prev & 0x7fffffff;
  }

  var SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
  var CodingTemplates = [[{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: 2,
    y: -1
  }, {
    x: -4,
    y: 0
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: 2,
    y: -1
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -3,
    y: -1
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -4,
    y: 0
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }]];
  var RefinementTemplates = [{
    coding: [{
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }],
    reference: [{
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 0
    }, {
      x: -1,
      y: 1
    }, {
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 1
    }]
  }, {
    coding: [{
      x: -1,
      y: -1
    }, {
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }],
    reference: [{
      x: 0,
      y: -1
    }, {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 0
    }, {
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 1
    }]
  }];
  var ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195];
  var RefinementReusedContexts = [0x0020, 0x0008];

  function decodeBitmapTemplate0(width, height, decodingContext) {
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts("GB");
    var contextLabel,
        i,
        j,
        pixel,
        row,
        row1,
        row2,
        bitmap = [];
    var OLD_PIXEL_MASK = 0x7bf7;

    for (i = 0; i < height; i++) {
      row = bitmap[i] = new Uint8Array(width);
      row1 = i < 1 ? row : bitmap[i - 1];
      row2 = i < 2 ? row : bitmap[i - 2];
      contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;

      for (j = 0; j < width; j++) {
        row[j] = pixel = decoder.readBit(contexts, contextLabel);
        contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
      }
    }

    return bitmap;
  }

  function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
    if (mmr) {
      var input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
      return decodeMMRBitmap(input, width, height, false);
    }

    if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
      return decodeBitmapTemplate0(width, height, decodingContext);
    }

    var useskip = !!skip;
    var template = CodingTemplates[templateIndex].concat(at);
    template.sort(function (a, b) {
      return a.y - b.y || a.x - b.x;
    });
    var templateLength = template.length;
    var templateX = new Int8Array(templateLength);
    var templateY = new Int8Array(templateLength);
    var changingTemplateEntries = [];
    var reuseMask = 0,
        minX = 0,
        maxX = 0,
        minY = 0;
    var c, k;

    for (k = 0; k < templateLength; k++) {
      templateX[k] = template[k].x;
      templateY[k] = template[k].y;
      minX = Math.min(minX, template[k].x);
      maxX = Math.max(maxX, template[k].x);
      minY = Math.min(minY, template[k].y);

      if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
        reuseMask |= 1 << templateLength - 1 - k;
      } else {
        changingTemplateEntries.push(k);
      }
    }

    var changingEntriesLength = changingTemplateEntries.length;
    var changingTemplateX = new Int8Array(changingEntriesLength);
    var changingTemplateY = new Int8Array(changingEntriesLength);
    var changingTemplateBit = new Uint16Array(changingEntriesLength);

    for (c = 0; c < changingEntriesLength; c++) {
      k = changingTemplateEntries[c];
      changingTemplateX[c] = template[k].x;
      changingTemplateY[c] = template[k].y;
      changingTemplateBit[c] = 1 << templateLength - 1 - k;
    }

    var sbb_left = -minX;
    var sbb_top = -minY;
    var sbb_right = width - maxX;
    var pseudoPixelContext = ReusedContexts[templateIndex];
    var row = new Uint8Array(width);
    var bitmap = [];
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts("GB");
    var ltp = 0,
        j,
        i0,
        j0,
        contextLabel = 0,
        bit,
        shift;

    for (var i = 0; i < height; i++) {
      if (prediction) {
        var sltp = decoder.readBit(contexts, pseudoPixelContext);
        ltp ^= sltp;

        if (ltp) {
          bitmap.push(row);
          continue;
        }
      }

      row = new Uint8Array(row);
      bitmap.push(row);

      for (j = 0; j < width; j++) {
        if (useskip && skip[i][j]) {
          row[j] = 0;
          continue;
        }

        if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
          contextLabel = contextLabel << 1 & reuseMask;

          for (k = 0; k < changingEntriesLength; k++) {
            i0 = i + changingTemplateY[k];
            j0 = j + changingTemplateX[k];
            bit = bitmap[i0][j0];

            if (bit) {
              bit = changingTemplateBit[k];
              contextLabel |= bit;
            }
          }
        } else {
          contextLabel = 0;
          shift = templateLength - 1;

          for (k = 0; k < templateLength; k++, shift--) {
            j0 = j + templateX[k];

            if (j0 >= 0 && j0 < width) {
              i0 = i + templateY[k];

              if (i0 >= 0) {
                bit = bitmap[i0][j0];

                if (bit) {
                  contextLabel |= bit << shift;
                }
              }
            }
          }
        }

        var pixel = decoder.readBit(contexts, contextLabel);
        row[j] = pixel;
      }
    }

    return bitmap;
  }

  function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
    var codingTemplate = RefinementTemplates[templateIndex].coding;

    if (templateIndex === 0) {
      codingTemplate = codingTemplate.concat([at[0]]);
    }

    var codingTemplateLength = codingTemplate.length;
    var codingTemplateX = new Int32Array(codingTemplateLength);
    var codingTemplateY = new Int32Array(codingTemplateLength);
    var k;

    for (k = 0; k < codingTemplateLength; k++) {
      codingTemplateX[k] = codingTemplate[k].x;
      codingTemplateY[k] = codingTemplate[k].y;
    }

    var referenceTemplate = RefinementTemplates[templateIndex].reference;

    if (templateIndex === 0) {
      referenceTemplate = referenceTemplate.concat([at[1]]);
    }

    var referenceTemplateLength = referenceTemplate.length;
    var referenceTemplateX = new Int32Array(referenceTemplateLength);
    var referenceTemplateY = new Int32Array(referenceTemplateLength);

    for (k = 0; k < referenceTemplateLength; k++) {
      referenceTemplateX[k] = referenceTemplate[k].x;
      referenceTemplateY[k] = referenceTemplate[k].y;
    }

    var referenceWidth = referenceBitmap[0].length;
    var referenceHeight = referenceBitmap.length;
    var pseudoPixelContext = RefinementReusedContexts[templateIndex];
    var bitmap = [];
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts("GR");
    var ltp = 0;

    for (var i = 0; i < height; i++) {
      if (prediction) {
        var sltp = decoder.readBit(contexts, pseudoPixelContext);
        ltp ^= sltp;

        if (ltp) {
          throw new Jbig2Error("prediction is not supported");
        }
      }

      var row = new Uint8Array(width);
      bitmap.push(row);

      for (var j = 0; j < width; j++) {
        var i0, j0;
        var contextLabel = 0;

        for (k = 0; k < codingTemplateLength; k++) {
          i0 = i + codingTemplateY[k];
          j0 = j + codingTemplateX[k];

          if (i0 < 0 || j0 < 0 || j0 >= width) {
            contextLabel <<= 1;
          } else {
            contextLabel = contextLabel << 1 | bitmap[i0][j0];
          }
        }

        for (k = 0; k < referenceTemplateLength; k++) {
          i0 = i + referenceTemplateY[k] - offsetY;
          j0 = j + referenceTemplateX[k] - offsetX;

          if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
            contextLabel <<= 1;
          } else {
            contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
          }
        }

        var pixel = decoder.readBit(contexts, contextLabel);
        row[j] = pixel;
      }
    }

    return bitmap;
  }

  function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
    if (huffman && refinement) {
      throw new Jbig2Error("symbol refinement with Huffman is not supported");
    }

    var newSymbols = [];
    var currentHeight = 0;
    var symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
    var decoder = decodingContext.decoder;
    var contextCache = decodingContext.contextCache;
    var tableB1, symbolWidths;

    if (huffman) {
      tableB1 = getStandardTable(1);
      symbolWidths = [];
      symbolCodeLength = Math.max(symbolCodeLength, 1);
    }

    while (newSymbols.length < numberOfNewSymbols) {
      var deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
      currentHeight += deltaHeight;
      var currentWidth = 0,
          totalWidth = 0;
      var firstSymbol = huffman ? symbolWidths.length : 0;

      while (true) {
        var deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);

        if (deltaWidth === null) {
          break;
        }

        currentWidth += deltaWidth;
        totalWidth += currentWidth;
        var bitmap;

        if (refinement) {
          var numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);

          if (numberOfInstances > 1) {
            bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
          } else {
            var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
            var rdx = decodeInteger(contextCache, "IARDX", decoder);
            var rdy = decodeInteger(contextCache, "IARDY", decoder);
            var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
            bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
          }

          newSymbols.push(bitmap);
        } else if (huffman) {
          symbolWidths.push(currentWidth);
        } else {
          bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
          newSymbols.push(bitmap);
        }
      }

      if (huffman && !refinement) {
        var bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
        huffmanInput.byteAlign();
        var collectiveBitmap = void 0;

        if (bitmapSize === 0) {
          collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
        } else {
          var originalEnd = huffmanInput.end;
          var bitmapEnd = huffmanInput.position + bitmapSize;
          huffmanInput.end = bitmapEnd;
          collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
          huffmanInput.end = originalEnd;
          huffmanInput.position = bitmapEnd;
        }

        var numberOfSymbolsDecoded = symbolWidths.length;

        if (firstSymbol === numberOfSymbolsDecoded - 1) {
          newSymbols.push(collectiveBitmap);
        } else {
          var _i = void 0,
              y = void 0,
              xMin = 0,
              xMax = void 0,
              bitmapWidth = void 0,
              symbolBitmap = void 0;

          for (_i = firstSymbol; _i < numberOfSymbolsDecoded; _i++) {
            bitmapWidth = symbolWidths[_i];
            xMax = xMin + bitmapWidth;
            symbolBitmap = [];

            for (y = 0; y < currentHeight; y++) {
              symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
            }

            newSymbols.push(symbolBitmap);
            xMin = xMax;
          }
        }
      }
    }

    var exportedSymbols = [];
    var flags = [],
        currentFlag = false;
    var totalSymbolsLength = symbols.length + numberOfNewSymbols;

    while (flags.length < totalSymbolsLength) {
      var runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);

      while (runLength--) {
        flags.push(currentFlag);
      }

      currentFlag = !currentFlag;
    }

    for (var i = 0, ii = symbols.length; i < ii; i++) {
      if (flags[i]) {
        exportedSymbols.push(symbols[i]);
      }
    }

    for (var j = 0; j < numberOfNewSymbols; i++, j++) {
      if (flags[i]) {
        exportedSymbols.push(newSymbols[j]);
      }
    }

    return exportedSymbols;
  }

  function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
    if (huffman && refinement) {
      throw new Jbig2Error("refinement with Huffman is not supported");
    }

    var bitmap = [];
    var i, row;

    for (i = 0; i < height; i++) {
      row = new Uint8Array(width);

      if (defaultPixelValue) {
        for (var j = 0; j < width; j++) {
          row[j] = defaultPixelValue;
        }
      }

      bitmap.push(row);
    }

    var decoder = decodingContext.decoder;
    var contextCache = decodingContext.contextCache;
    var stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
    var firstS = 0;
    i = 0;

    while (i < numberOfSymbolInstances) {
      var deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
      stripT += deltaT;
      var deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
      firstS += deltaFirstS;
      var currentS = firstS;

      do {
        var currentT = 0;

        if (stripSize > 1) {
          currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
        }

        var t = stripSize * stripT + currentT;
        var symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
        var applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
        var symbolBitmap = inputSymbols[symbolId];
        var symbolWidth = symbolBitmap[0].length;
        var symbolHeight = symbolBitmap.length;

        if (applyRefinement) {
          var rdw = decodeInteger(contextCache, "IARDW", decoder);
          var rdh = decodeInteger(contextCache, "IARDH", decoder);
          var rdx = decodeInteger(contextCache, "IARDX", decoder);
          var rdy = decodeInteger(contextCache, "IARDY", decoder);
          symbolWidth += rdw;
          symbolHeight += rdh;
          symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
        }

        var offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
        var offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
        var s2, t2, symbolRow;

        if (transposed) {
          for (s2 = 0; s2 < symbolHeight; s2++) {
            row = bitmap[offsetS + s2];

            if (!row) {
              continue;
            }

            symbolRow = symbolBitmap[s2];
            var maxWidth = Math.min(width - offsetT, symbolWidth);

            switch (combinationOperator) {
              case 0:
                for (t2 = 0; t2 < maxWidth; t2++) {
                  row[offsetT + t2] |= symbolRow[t2];
                }

                break;

              case 2:
                for (t2 = 0; t2 < maxWidth; t2++) {
                  row[offsetT + t2] ^= symbolRow[t2];
                }

                break;

              default:
                throw new Jbig2Error("operator ".concat(combinationOperator, " is not supported"));
            }
          }

          currentS += symbolHeight - 1;
        } else {
          for (t2 = 0; t2 < symbolHeight; t2++) {
            row = bitmap[offsetT + t2];

            if (!row) {
              continue;
            }

            symbolRow = symbolBitmap[t2];

            switch (combinationOperator) {
              case 0:
                for (s2 = 0; s2 < symbolWidth; s2++) {
                  row[offsetS + s2] |= symbolRow[s2];
                }

                break;

              case 2:
                for (s2 = 0; s2 < symbolWidth; s2++) {
                  row[offsetS + s2] ^= symbolRow[s2];
                }

                break;

              default:
                throw new Jbig2Error("operator ".concat(combinationOperator, " is not supported"));
            }
          }

          currentS += symbolWidth - 1;
        }

        i++;
        var deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);

        if (deltaS === null) {
          break;
        }

        currentS += deltaS + dsOffset;
      } while (true);
    }

    return bitmap;
  }

  function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
    var at = [];

    if (!mmr) {
      at.push({
        x: -patternWidth,
        y: 0
      });

      if (template === 0) {
        at.push({
          x: -3,
          y: -1
        });
        at.push({
          x: 2,
          y: -2
        });
        at.push({
          x: -2,
          y: -2
        });
      }
    }

    var collectiveWidth = (maxPatternIndex + 1) * patternWidth;
    var collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
    var patterns = [];

    for (var i = 0; i <= maxPatternIndex; i++) {
      var patternBitmap = [];
      var xMin = patternWidth * i;
      var xMax = xMin + patternWidth;

      for (var y = 0; y < patternHeight; y++) {
        patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
      }

      patterns.push(patternBitmap);
    }

    return patterns;
  }

  function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
    var skip = null;

    if (enableSkip) {
      throw new Jbig2Error("skip is not supported");
    }

    if (combinationOperator !== 0) {
      throw new Jbig2Error("operator " + combinationOperator + " is not supported in halftone region");
    }

    var regionBitmap = [];
    var i, j, row;

    for (i = 0; i < regionHeight; i++) {
      row = new Uint8Array(regionWidth);

      if (defaultPixelValue) {
        for (j = 0; j < regionWidth; j++) {
          row[j] = defaultPixelValue;
        }
      }

      regionBitmap.push(row);
    }

    var numberOfPatterns = patterns.length;
    var pattern0 = patterns[0];
    var patternWidth = pattern0[0].length,
        patternHeight = pattern0.length;
    var bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
    var at = [];

    if (!mmr) {
      at.push({
        x: template <= 1 ? 3 : 2,
        y: -1
      });

      if (template === 0) {
        at.push({
          x: -3,
          y: -1
        });
        at.push({
          x: 2,
          y: -2
        });
        at.push({
          x: -2,
          y: -2
        });
      }
    }

    var grayScaleBitPlanes = [];
    var mmrInput, bitmap;

    if (mmr) {
      mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
    }

    for (i = bitsPerValue - 1; i >= 0; i--) {
      if (mmr) {
        bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
      } else {
        bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
      }

      grayScaleBitPlanes[i] = bitmap;
    }

    var mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;

    for (mg = 0; mg < gridHeight; mg++) {
      for (ng = 0; ng < gridWidth; ng++) {
        bit = 0;
        patternIndex = 0;

        for (j = bitsPerValue - 1; j >= 0; j--) {
          bit = grayScaleBitPlanes[j][mg][ng] ^ bit;
          patternIndex |= bit << j;
        }

        patternBitmap = patterns[patternIndex];
        x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
        y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;

        if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
          for (i = 0; i < patternHeight; i++) {
            regionRow = regionBitmap[y + i];
            patternRow = patternBitmap[i];

            for (j = 0; j < patternWidth; j++) {
              regionRow[x + j] |= patternRow[j];
            }
          }
        } else {
          var regionX = void 0,
              regionY = void 0;

          for (i = 0; i < patternHeight; i++) {
            regionY = y + i;

            if (regionY < 0 || regionY >= regionHeight) {
              continue;
            }

            regionRow = regionBitmap[regionY];
            patternRow = patternBitmap[i];

            for (j = 0; j < patternWidth; j++) {
              regionX = x + j;

              if (regionX >= 0 && regionX < regionWidth) {
                regionRow[regionX] |= patternRow[j];
              }
            }
          }
        }
      }
    }

    return regionBitmap;
  }

  function readSegmentHeader(data, start) {
    var segmentHeader = {};
    segmentHeader.number = (0, _core_utils.readUint32)(data, start);
    var flags = data[start + 4];
    var segmentType = flags & 0x3f;

    if (!SegmentTypes[segmentType]) {
      throw new Jbig2Error("invalid segment type: " + segmentType);
    }

    segmentHeader.type = segmentType;
    segmentHeader.typeName = SegmentTypes[segmentType];
    segmentHeader.deferredNonRetain = !!(flags & 0x80);
    var pageAssociationFieldSize = !!(flags & 0x40);
    var referredFlags = data[start + 5];
    var referredToCount = referredFlags >> 5 & 7;
    var retainBits = [referredFlags & 31];
    var position = start + 6;

    if (referredFlags === 7) {
      referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 0x1fffffff;
      position += 3;
      var bytes = referredToCount + 7 >> 3;
      retainBits[0] = data[position++];

      while (--bytes > 0) {
        retainBits.push(data[position++]);
      }
    } else if (referredFlags === 5 || referredFlags === 6) {
      throw new Jbig2Error("invalid referred-to flags");
    }

    segmentHeader.retainBits = retainBits;
    var referredToSegmentNumberSize = 4;

    if (segmentHeader.number <= 256) {
      referredToSegmentNumberSize = 1;
    } else if (segmentHeader.number <= 65536) {
      referredToSegmentNumberSize = 2;
    }

    var referredTo = [];
    var i, ii;

    for (i = 0; i < referredToCount; i++) {
      var number = void 0;

      if (referredToSegmentNumberSize === 1) {
        number = data[position];
      } else if (referredToSegmentNumberSize === 2) {
        number = (0, _core_utils.readUint16)(data, position);
      } else {
        number = (0, _core_utils.readUint32)(data, position);
      }

      referredTo.push(number);
      position += referredToSegmentNumberSize;
    }

    segmentHeader.referredTo = referredTo;

    if (!pageAssociationFieldSize) {
      segmentHeader.pageAssociation = data[position++];
    } else {
      segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
      position += 4;
    }

    segmentHeader.length = (0, _core_utils.readUint32)(data, position);
    position += 4;

    if (segmentHeader.length === 0xffffffff) {
      if (segmentType === 38) {
        var genericRegionInfo = readRegionSegmentInformation(data, position);
        var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
        var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
        var searchPatternLength = 6;
        var searchPattern = new Uint8Array(searchPatternLength);

        if (!genericRegionMmr) {
          searchPattern[0] = 0xff;
          searchPattern[1] = 0xac;
        }

        searchPattern[2] = genericRegionInfo.height >>> 24 & 0xff;
        searchPattern[3] = genericRegionInfo.height >> 16 & 0xff;
        searchPattern[4] = genericRegionInfo.height >> 8 & 0xff;
        searchPattern[5] = genericRegionInfo.height & 0xff;

        for (i = position, ii = data.length; i < ii; i++) {
          var j = 0;

          while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
            j++;
          }

          if (j === searchPatternLength) {
            segmentHeader.length = i + searchPatternLength;
            break;
          }
        }

        if (segmentHeader.length === 0xffffffff) {
          throw new Jbig2Error("segment end was not found");
        }
      } else {
        throw new Jbig2Error("invalid unknown segment length");
      }
    }

    segmentHeader.headerEnd = position;
    return segmentHeader;
  }

  function readSegments(header, data, start, end) {
    var segments = [];
    var position = start;

    while (position < end) {
      var segmentHeader = readSegmentHeader(data, position);
      position = segmentHeader.headerEnd;
      var segment = {
        header: segmentHeader,
        data: data
      };

      if (!header.randomAccess) {
        segment.start = position;
        position += segmentHeader.length;
        segment.end = position;
      }

      segments.push(segment);

      if (segmentHeader.type === 51) {
        break;
      }
    }

    if (header.randomAccess) {
      for (var i = 0, ii = segments.length; i < ii; i++) {
        segments[i].start = position;
        position += segments[i].header.length;
        segments[i].end = position;
      }
    }

    return segments;
  }

  function readRegionSegmentInformation(data, start) {
    return {
      width: (0, _core_utils.readUint32)(data, start),
      height: (0, _core_utils.readUint32)(data, start + 4),
      x: (0, _core_utils.readUint32)(data, start + 8),
      y: (0, _core_utils.readUint32)(data, start + 12),
      combinationOperator: data[start + 16] & 7
    };
  }

  var RegionSegmentInformationFieldLength = 17;

  function processSegment(segment, visitor) {
    var header = segment.header;
    var data = segment.data,
        position = segment.start,
        end = segment.end;
    var args, at, i, atLength;

    switch (header.type) {
      case 0:
        var dictionary = {};
        var dictionaryFlags = (0, _core_utils.readUint16)(data, position);
        dictionary.huffman = !!(dictionaryFlags & 1);
        dictionary.refinement = !!(dictionaryFlags & 2);
        dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
        dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
        dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
        dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
        dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
        dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
        dictionary.template = dictionaryFlags >> 10 & 3;
        dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
        position += 2;

        if (!dictionary.huffman) {
          atLength = dictionary.template === 0 ? 4 : 1;
          at = [];

          for (i = 0; i < atLength; i++) {
            at.push({
              x: (0, _core_utils.readInt8)(data, position),
              y: (0, _core_utils.readInt8)(data, position + 1)
            });
            position += 2;
          }

          dictionary.at = at;
        }

        if (dictionary.refinement && !dictionary.refinementTemplate) {
          at = [];

          for (i = 0; i < 2; i++) {
            at.push({
              x: (0, _core_utils.readInt8)(data, position),
              y: (0, _core_utils.readInt8)(data, position + 1)
            });
            position += 2;
          }

          dictionary.refinementAt = at;
        }

        dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
        position += 4;
        dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
        position += 4;
        args = [dictionary, header.number, header.referredTo, data, position, end];
        break;

      case 6:
      case 7:
        var textRegion = {};
        textRegion.info = readRegionSegmentInformation(data, position);
        position += RegionSegmentInformationFieldLength;
        var textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
        position += 2;
        textRegion.huffman = !!(textRegionSegmentFlags & 1);
        textRegion.refinement = !!(textRegionSegmentFlags & 2);
        textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
        textRegion.stripSize = 1 << textRegion.logStripSize;
        textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
        textRegion.transposed = !!(textRegionSegmentFlags & 64);
        textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
        textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
        textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
        textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;

        if (textRegion.huffman) {
          var textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
          position += 2;
          textRegion.huffmanFS = textRegionHuffmanFlags & 3;
          textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
          textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
          textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
          textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
          textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
          textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
          textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 0x4000);
        }

        if (textRegion.refinement && !textRegion.refinementTemplate) {
          at = [];

          for (i = 0; i < 2; i++) {
            at.push({
              x: (0, _core_utils.readInt8)(data, position),
              y: (0, _core_utils.readInt8)(data, position + 1)
            });
            position += 2;
          }

          textRegion.refinementAt = at;
        }

        textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
        position += 4;
        args = [textRegion, header.referredTo, data, position, end];
        break;

      case 16:
        var patternDictionary = {};
        var patternDictionaryFlags = data[position++];
        patternDictionary.mmr = !!(patternDictionaryFlags & 1);
        patternDictionary.template = patternDictionaryFlags >> 1 & 3;
        patternDictionary.patternWidth = data[position++];
        patternDictionary.patternHeight = data[position++];
        patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
        position += 4;
        args = [patternDictionary, header.number, data, position, end];
        break;

      case 22:
      case 23:
        var halftoneRegion = {};
        halftoneRegion.info = readRegionSegmentInformation(data, position);
        position += RegionSegmentInformationFieldLength;
        var halftoneRegionFlags = data[position++];
        halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
        halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
        halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
        halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
        halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
        halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
        position += 4;
        halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
        position += 4;
        halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
        position += 4;
        halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
        position += 4;
        halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
        position += 2;
        halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
        position += 2;
        args = [halftoneRegion, header.referredTo, data, position, end];
        break;

      case 38:
      case 39:
        var genericRegion = {};
        genericRegion.info = readRegionSegmentInformation(data, position);
        position += RegionSegmentInformationFieldLength;
        var genericRegionSegmentFlags = data[position++];
        genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
        genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
        genericRegion.prediction = !!(genericRegionSegmentFlags & 8);

        if (!genericRegion.mmr) {
          atLength = genericRegion.template === 0 ? 4 : 1;
          at = [];

          for (i = 0; i < atLength; i++) {
            at.push({
              x: (0, _core_utils.readInt8)(data, position),
              y: (0, _core_utils.readInt8)(data, position + 1)
            });
            position += 2;
          }

          genericRegion.at = at;
        }

        args = [genericRegion, data, position, end];
        break;

      case 48:
        var pageInfo = {
          width: (0, _core_utils.readUint32)(data, position),
          height: (0, _core_utils.readUint32)(data, position + 4),
          resolutionX: (0, _core_utils.readUint32)(data, position + 8),
          resolutionY: (0, _core_utils.readUint32)(data, position + 12)
        };

        if (pageInfo.height === 0xffffffff) {
          delete pageInfo.height;
        }

        var pageSegmentFlags = data[position + 16];
        (0, _core_utils.readUint16)(data, position + 17);
        pageInfo.lossless = !!(pageSegmentFlags & 1);
        pageInfo.refinement = !!(pageSegmentFlags & 2);
        pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
        pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
        pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
        pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
        args = [pageInfo];
        break;

      case 49:
        break;

      case 50:
        break;

      case 51:
        break;

      case 53:
        args = [header.number, data, position, end];
        break;

      case 62:
        break;

      default:
        throw new Jbig2Error("segment type ".concat(header.typeName, "(").concat(header.type, ")") + " is not implemented");
    }

    var callbackName = "on" + header.typeName;

    if (callbackName in visitor) {
      visitor[callbackName].apply(visitor, args);
    }
  }

  function processSegments(segments, visitor) {
    for (var i = 0, ii = segments.length; i < ii; i++) {
      processSegment(segments[i], visitor);
    }
  }

  function parseJbig2Chunks(chunks) {
    var visitor = new SimpleSegmentVisitor();

    for (var i = 0, ii = chunks.length; i < ii; i++) {
      var chunk = chunks[i];
      var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
      processSegments(segments, visitor);
    }

    return visitor.buffer;
  }

  function parseJbig2(data) {
    var end = data.length;
    var position = 0;

    if (data[position] !== 0x97 || data[position + 1] !== 0x4a || data[position + 2] !== 0x42 || data[position + 3] !== 0x32 || data[position + 4] !== 0x0d || data[position + 5] !== 0x0a || data[position + 6] !== 0x1a || data[position + 7] !== 0x0a) {
      throw new Jbig2Error("parseJbig2 - invalid header.");
    }

    var header = Object.create(null);
    position += 8;
    var flags = data[position++];
    header.randomAccess = !(flags & 1);

    if (!(flags & 2)) {
      header.numberOfPages = (0, _core_utils.readUint32)(data, position);
      position += 4;
    }

    var segments = readSegments(header, data, position, end);
    var visitor = new SimpleSegmentVisitor();
    processSegments(segments, visitor);
    var _visitor$currentPageI = visitor.currentPageInfo,
        width = _visitor$currentPageI.width,
        height = _visitor$currentPageI.height;
    var bitPacked = visitor.buffer;
    var imgData = new Uint8ClampedArray(width * height);
    var q = 0,
        k = 0;

    for (var i = 0; i < height; i++) {
      var mask = 0,
          buffer = void 0;

      for (var j = 0; j < width; j++) {
        if (!mask) {
          mask = 128;
          buffer = bitPacked[k++];
        }

        imgData[q++] = buffer & mask ? 0 : 255;
        mask >>= 1;
      }
    }

    return {
      imgData: imgData,
      width: width,
      height: height
    };
  }

  function SimpleSegmentVisitor() {}

  SimpleSegmentVisitor.prototype = {
    onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
      this.currentPageInfo = info;
      var rowSize = info.width + 7 >> 3;
      var buffer = new Uint8ClampedArray(rowSize * info.height);

      if (info.defaultPixelValue) {
        for (var i = 0, ii = buffer.length; i < ii; i++) {
          buffer[i] = 0xff;
        }
      }

      this.buffer = buffer;
    },
    drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
      var pageInfo = this.currentPageInfo;
      var width = regionInfo.width,
          height = regionInfo.height;
      var rowSize = pageInfo.width + 7 >> 3;
      var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
      var buffer = this.buffer;
      var mask0 = 128 >> (regionInfo.x & 7);
      var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
      var i, j, mask, offset;

      switch (combinationOperator) {
        case 0:
          for (i = 0; i < height; i++) {
            mask = mask0;
            offset = offset0;

            for (j = 0; j < width; j++) {
              if (bitmap[i][j]) {
                buffer[offset] |= mask;
              }

              mask >>= 1;

              if (!mask) {
                mask = 128;
                offset++;
              }
            }

            offset0 += rowSize;
          }

          break;

        case 2:
          for (i = 0; i < height; i++) {
            mask = mask0;
            offset = offset0;

            for (j = 0; j < width; j++) {
              if (bitmap[i][j]) {
                buffer[offset] ^= mask;
              }

              mask >>= 1;

              if (!mask) {
                mask = 128;
                offset++;
              }
            }

            offset0 += rowSize;
          }

          break;

        default:
          throw new Jbig2Error("operator ".concat(combinationOperator, " is not supported"));
      }
    },
    onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
      var regionInfo = region.info;
      var decodingContext = new DecodingContext(data, start, end);
      var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
      this.drawBitmap(regionInfo, bitmap);
    },
    onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
      this.onImmediateGenericRegion.apply(this, arguments);
    },
    onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
      var huffmanTables, huffmanInput;

      if (dictionary.huffman) {
        huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
        huffmanInput = new Reader(data, start, end);
      }

      var symbols = this.symbols;

      if (!symbols) {
        this.symbols = symbols = {};
      }

      var inputSymbols = [];

      for (var i = 0, ii = referredSegments.length; i < ii; i++) {
        var referredSymbols = symbols[referredSegments[i]];

        if (referredSymbols) {
          inputSymbols = inputSymbols.concat(referredSymbols);
        }
      }

      var decodingContext = new DecodingContext(data, start, end);
      symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
    },
    onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
      var regionInfo = region.info;
      var huffmanTables, huffmanInput;
      var symbols = this.symbols;
      var inputSymbols = [];

      for (var i = 0, ii = referredSegments.length; i < ii; i++) {
        var referredSymbols = symbols[referredSegments[i]];

        if (referredSymbols) {
          inputSymbols = inputSymbols.concat(referredSymbols);
        }
      }

      var symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);

      if (region.huffman) {
        huffmanInput = new Reader(data, start, end);
        huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
      }

      var decodingContext = new DecodingContext(data, start, end);
      var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
      this.drawBitmap(regionInfo, bitmap);
    },
    onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
      this.onImmediateTextRegion.apply(this, arguments);
    },
    onPatternDictionary: function onPatternDictionary(dictionary, currentSegment, data, start, end) {
      var patterns = this.patterns;

      if (!patterns) {
        this.patterns = patterns = {};
      }

      var decodingContext = new DecodingContext(data, start, end);
      patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
    },
    onImmediateHalftoneRegion: function onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
      var patterns = this.patterns[referredSegments[0]];
      var regionInfo = region.info;
      var decodingContext = new DecodingContext(data, start, end);
      var bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
      this.drawBitmap(regionInfo, bitmap);
    },
    onImmediateLosslessHalftoneRegion: function onImmediateLosslessHalftoneRegion() {
      this.onImmediateHalftoneRegion.apply(this, arguments);
    },
    onTables: function onTables(currentSegment, data, start, end) {
      var customTables = this.customTables;

      if (!customTables) {
        this.customTables = customTables = {};
      }

      customTables[currentSegment] = decodeTablesSegment(data, start, end);
    }
  };

  function HuffmanLine(lineData) {
    if (lineData.length === 2) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = lineData[0];
      this.rangeLength = 0;
      this.prefixCode = lineData[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = lineData[0];
      this.prefixLength = lineData[1];
      this.rangeLength = lineData[2];
      this.prefixCode = lineData[3];
      this.isLowerRange = lineData[4] === "lower";
    }
  }

  function HuffmanTreeNode(line) {
    this.children = [];

    if (line) {
      this.isLeaf = true;
      this.rangeLength = line.rangeLength;
      this.rangeLow = line.rangeLow;
      this.isLowerRange = line.isLowerRange;
      this.isOOB = line.isOOB;
    } else {
      this.isLeaf = false;
    }
  }

  HuffmanTreeNode.prototype = {
    buildTree: function buildTree(line, shift) {
      var bit = line.prefixCode >> shift & 1;

      if (shift <= 0) {
        this.children[bit] = new HuffmanTreeNode(line);
      } else {
        var node = this.children[bit];

        if (!node) {
          this.children[bit] = node = new HuffmanTreeNode(null);
        }

        node.buildTree(line, shift - 1);
      }
    },
    decodeNode: function decodeNode(reader) {
      if (this.isLeaf) {
        if (this.isOOB) {
          return null;
        }

        var htOffset = reader.readBits(this.rangeLength);
        return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
      }

      var node = this.children[reader.readBit()];

      if (!node) {
        throw new Jbig2Error("invalid Huffman data");
      }

      return node.decodeNode(reader);
    }
  };

  function HuffmanTable(lines, prefixCodesDone) {
    if (!prefixCodesDone) {
      this.assignPrefixCodes(lines);
    }

    this.rootNode = new HuffmanTreeNode(null);

    for (var i = 0, ii = lines.length; i < ii; i++) {
      var line = lines[i];

      if (line.prefixLength > 0) {
        this.rootNode.buildTree(line, line.prefixLength - 1);
      }
    }
  }

  HuffmanTable.prototype = {
    decode: function decode(reader) {
      return this.rootNode.decodeNode(reader);
    },
    assignPrefixCodes: function assignPrefixCodes(lines) {
      var linesLength = lines.length;
      var prefixLengthMax = 0;

      for (var i = 0; i < linesLength; i++) {
        prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
      }

      var histogram = new Uint32Array(prefixLengthMax + 1);

      for (var _i2 = 0; _i2 < linesLength; _i2++) {
        histogram[lines[_i2].prefixLength]++;
      }

      var currentLength = 1,
          firstCode = 0,
          currentCode,
          currentTemp,
          line;
      histogram[0] = 0;

      while (currentLength <= prefixLengthMax) {
        firstCode = firstCode + histogram[currentLength - 1] << 1;
        currentCode = firstCode;
        currentTemp = 0;

        while (currentTemp < linesLength) {
          line = lines[currentTemp];

          if (line.prefixLength === currentLength) {
            line.prefixCode = currentCode;
            currentCode++;
          }

          currentTemp++;
        }

        currentLength++;
      }
    }
  };

  function decodeTablesSegment(data, start, end) {
    var flags = data[start];
    var lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 0xffffffff;
    var highestValue = (0, _core_utils.readUint32)(data, start + 5) & 0xffffffff;
    var reader = new Reader(data, start + 9, end);
    var prefixSizeBits = (flags >> 1 & 7) + 1;
    var rangeSizeBits = (flags >> 4 & 7) + 1;
    var lines = [];
    var prefixLength,
        rangeLength,
        currentRangeLow = lowestValue;

    do {
      prefixLength = reader.readBits(prefixSizeBits);
      rangeLength = reader.readBits(rangeSizeBits);
      lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
      currentRangeLow += 1 << rangeLength;
    } while (currentRangeLow < highestValue);

    prefixLength = reader.readBits(prefixSizeBits);
    lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
    prefixLength = reader.readBits(prefixSizeBits);
    lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));

    if (flags & 1) {
      prefixLength = reader.readBits(prefixSizeBits);
      lines.push(new HuffmanLine([prefixLength, 0]));
    }

    return new HuffmanTable(lines, false);
  }

  var standardTablesCache = {};

  function getStandardTable(number) {
    var table = standardTablesCache[number];

    if (table) {
      return table;
    }

    var lines;

    switch (number) {
      case 1:
        lines = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]];
        break;

      case 2:
        lines = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]];
        break;

      case 3:
        lines = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, "lower"], [75, 7, 32, 0x7e], [6, 0x3e]];
        break;

      case 4:
        lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]];
        break;

      case 5:
        lines = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, "lower"], [76, 6, 32, 0x3e]];
        break;

      case 6:
        lines = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, "lower"], [2048, 6, 32, 0x3f]];
        break;

      case 7:
        lines = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, "lower"], [2048, 5, 32, 0x1f]];
        break;

      case 8:
        lines = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, "lower"], [1670, 9, 32, 0x1ff], [2, 0x1]];
        break;

      case 9:
        lines = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, "lower"], [3339, 9, 32, 0x1ff], [2, 0x0]];
        break;

      case 10:
        lines = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, "lower"], [4166, 8, 32, 0xff], [2, 0x2]];
        break;

      case 11:
        lines = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
        break;

      case 12:
        lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]];
        break;

      case 13:
        lines = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
        break;

      case 14:
        lines = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]];
        break;

      case 15:
        lines = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, "lower"], [25, 7, 32, 0x7f]];
        break;

      default:
        throw new Jbig2Error("standard table B.".concat(number, " does not exist"));
    }

    for (var i = 0, ii = lines.length; i < ii; i++) {
      lines[i] = new HuffmanLine(lines[i]);
    }

    table = new HuffmanTable(lines, true);
    standardTablesCache[number] = table;
    return table;
  }

  function Reader(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
    this.position = start;
    this.shift = -1;
    this.currentByte = 0;
  }

  Reader.prototype = {
    readBit: function readBit() {
      if (this.shift < 0) {
        if (this.position >= this.end) {
          throw new Jbig2Error("end of data while reading bit");
        }

        this.currentByte = this.data[this.position++];
        this.shift = 7;
      }

      var bit = this.currentByte >> this.shift & 1;
      this.shift--;
      return bit;
    },
    readBits: function readBits(numBits) {
      var result = 0,
          i;

      for (i = numBits - 1; i >= 0; i--) {
        result |= this.readBit() << i;
      }

      return result;
    },
    byteAlign: function byteAlign() {
      this.shift = -1;
    },
    next: function next() {
      if (this.position >= this.end) {
        return -1;
      }

      return this.data[this.position++];
    }
  };

  function getCustomHuffmanTable(index, referredTo, customTables) {
    var currentIndex = 0;

    for (var i = 0, ii = referredTo.length; i < ii; i++) {
      var table = customTables[referredTo[i]];

      if (table) {
        if (index === currentIndex) {
          return table;
        }

        currentIndex++;
      }
    }

    throw new Jbig2Error("can't find custom Huffman table");
  }

  function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
    var codes = [];

    for (var i = 0; i <= 34; i++) {
      var codeLength = reader.readBits(4);
      codes.push(new HuffmanLine([i, codeLength, 0, 0]));
    }

    var runCodesTable = new HuffmanTable(codes, false);
    codes.length = 0;

    for (var _i3 = 0; _i3 < numberOfSymbols;) {
      var _codeLength = runCodesTable.decode(reader);

      if (_codeLength >= 32) {
        var repeatedLength = void 0,
            numberOfRepeats = void 0,
            j = void 0;

        switch (_codeLength) {
          case 32:
            if (_i3 === 0) {
              throw new Jbig2Error("no previous value in symbol ID table");
            }

            numberOfRepeats = reader.readBits(2) + 3;
            repeatedLength = codes[_i3 - 1].prefixLength;
            break;

          case 33:
            numberOfRepeats = reader.readBits(3) + 3;
            repeatedLength = 0;
            break;

          case 34:
            numberOfRepeats = reader.readBits(7) + 11;
            repeatedLength = 0;
            break;

          default:
            throw new Jbig2Error("invalid code length in symbol ID table");
        }

        for (j = 0; j < numberOfRepeats; j++) {
          codes.push(new HuffmanLine([_i3, repeatedLength, 0, 0]));
          _i3++;
        }
      } else {
        codes.push(new HuffmanLine([_i3, _codeLength, 0, 0]));
        _i3++;
      }
    }

    reader.byteAlign();
    var symbolIDTable = new HuffmanTable(codes, false);
    var customIndex = 0,
        tableFirstS,
        tableDeltaS,
        tableDeltaT;

    switch (textRegion.huffmanFS) {
      case 0:
      case 1:
        tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
        break;

      case 3:
        tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
        customIndex++;
        break;

      default:
        throw new Jbig2Error("invalid Huffman FS selector");
    }

    switch (textRegion.huffmanDS) {
      case 0:
      case 1:
      case 2:
        tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
        break;

      case 3:
        tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
        customIndex++;
        break;

      default:
        throw new Jbig2Error("invalid Huffman DS selector");
    }

    switch (textRegion.huffmanDT) {
      case 0:
      case 1:
      case 2:
        tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
        break;

      case 3:
        tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
        customIndex++;
        break;

      default:
        throw new Jbig2Error("invalid Huffman DT selector");
    }

    if (textRegion.refinement) {
      throw new Jbig2Error("refinement with Huffman is not supported");
    }

    return {
      symbolIDTable: symbolIDTable,
      tableFirstS: tableFirstS,
      tableDeltaS: tableDeltaS,
      tableDeltaT: tableDeltaT
    };
  }

  function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
    var customIndex = 0,
        tableDeltaHeight,
        tableDeltaWidth;

    switch (dictionary.huffmanDHSelector) {
      case 0:
      case 1:
        tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
        break;

      case 3:
        tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
        customIndex++;
        break;

      default:
        throw new Jbig2Error("invalid Huffman DH selector");
    }

    switch (dictionary.huffmanDWSelector) {
      case 0:
      case 1:
        tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
        break;

      case 3:
        tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
        customIndex++;
        break;

      default:
        throw new Jbig2Error("invalid Huffman DW selector");
    }

    var tableBitmapSize, tableAggregateInstances;

    if (dictionary.bitmapSizeSelector) {
      tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
    } else {
      tableBitmapSize = getStandardTable(1);
    }

    if (dictionary.aggregationInstancesSelector) {
      tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
    } else {
      tableAggregateInstances = getStandardTable(1);
    }

    return {
      tableDeltaHeight: tableDeltaHeight,
      tableDeltaWidth: tableDeltaWidth,
      tableBitmapSize: tableBitmapSize,
      tableAggregateInstances: tableAggregateInstances
    };
  }

  function readUncompressedBitmap(reader, width, height) {
    var bitmap = [];

    for (var y = 0; y < height; y++) {
      var row = new Uint8Array(width);
      bitmap.push(row);

      for (var x = 0; x < width; x++) {
        row[x] = reader.readBit();
      }

      reader.byteAlign();
    }

    return bitmap;
  }

  function decodeMMRBitmap(input, width, height, endOfBlock) {
    var params = {
      K: -1,
      Columns: width,
      Rows: height,
      BlackIs1: true,
      EndOfBlock: endOfBlock
    };
    var decoder = new _ccitt.CCITTFaxDecoder(input, params);
    var bitmap = [];
    var currentByte,
        eof = false;

    for (var y = 0; y < height; y++) {
      var row = new Uint8Array(width);
      bitmap.push(row);
      var shift = -1;

      for (var x = 0; x < width; x++) {
        if (shift < 0) {
          currentByte = decoder.readNextChar();

          if (currentByte === -1) {
            currentByte = 0;
            eof = true;
          }

          shift = 7;
        }

        row[x] = currentByte >> shift & 1;
        shift--;
      }
    }

    if (endOfBlock && !eof) {
      var lookForEOFLimit = 5;

      for (var i = 0; i < lookForEOFLimit; i++) {
        if (decoder.readNextChar() === -1) {
          break;
        }
      }
    }

    return bitmap;
  }

  function Jbig2Image() {}

  Jbig2Image.prototype = {
    parseChunks: function parseChunks(chunks) {
      return parseJbig2Chunks(chunks);
    },
    parse: function parse(data) {
      var _parseJbig = parseJbig2(data),
          imgData = _parseJbig.imgData,
          width = _parseJbig.width,
          height = _parseJbig.height;

      this.width = width;
      this.height = height;
      return imgData;
    }
  };
  return Jbig2Image;
}();

exports.Jbig2Image = Jbig2Image;

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ArithmeticDecoder = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var QeTable = [{
  qe: 0x5601,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 0x3401,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x5101,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x3401,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2801,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x2201,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 0x1401,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 0x1201,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 0x1101,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 0x09c1,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x08a1,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 0x0441,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 0x02a1,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 0x0141,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 0x0111,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 0x0085,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 0x0049,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 0x0025,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 0x0015,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 0x0009,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 0x0005,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 0x0001,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];

var ArithmeticDecoder = /*#__PURE__*/function () {
  function ArithmeticDecoder(data, start, end) {
    _classCallCheck(this, ArithmeticDecoder);

    this.data = data;
    this.bp = start;
    this.dataEnd = end;
    this.chigh = data[start];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 0xffff | this.clow >> 9 & 0x7f;
    this.clow = this.clow << 7 & 0xffff;
    this.ct -= 7;
    this.a = 0x8000;
  }

  _createClass(ArithmeticDecoder, [{
    key: "byteIn",
    value: function byteIn() {
      var data = this.data;
      var bp = this.bp;

      if (data[bp] === 0xff) {
        if (data[bp + 1] > 0x8f) {
          this.clow += 0xff00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += data[bp] << 9;
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xff00;
        this.ct = 8;
        this.bp = bp;
      }

      if (this.clow > 0xffff) {
        this.chigh += this.clow >> 16;
        this.clow &= 0xffff;
      }
    }
  }, {
    key: "readBit",
    value: function readBit(contexts, pos) {
      var cx_index = contexts[pos] >> 1,
          cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;

          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }

          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;

        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }

        if (a < qeIcx) {
          d = 1 ^ cx_mps;

          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }

          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }

      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = this.chigh << 1 & 0xffff | this.clow >> 15 & 1;
        this.clow = this.clow << 1 & 0xffff;
        this.ct--;
      } while ((a & 0x8000) === 0);

      this.a = a;
      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  }]);

  return ArithmeticDecoder;
}();

exports.ArithmeticDecoder = ArithmeticDecoder;

/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegStream = void 0;

var _stream = __w_pdfjs_require__(142);

var _primitives = __w_pdfjs_require__(135);

var _jpg = __w_pdfjs_require__(149);

var _util = __w_pdfjs_require__(4);

var JpegStream = function JpegStreamClosure() {
  function JpegStream(stream, maybeLength, dict, params) {
    var ch;

    while ((ch = stream.getByte()) !== -1) {
      if (ch === 0xff) {
        stream.skip(-1);
        break;
      }
    }

    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;

    _stream.DecodeStream.call(this, maybeLength);
  }

  JpegStream.prototype = Object.create(_stream.DecodeStream.prototype);
  Object.defineProperty(JpegStream.prototype, "bytes", {
    get: function JpegStream_bytes() {
      return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });

  JpegStream.prototype.ensureBuffer = function (requested) {};

  JpegStream.prototype.readBlock = function () {
    if (this.eof) {
      return;
    }

    var jpegOptions = {
      decodeTransform: undefined,
      colorTransform: undefined
    };
    var decodeArr = this.dict.getArray("Decode", "D");

    if (this.forceRGB && Array.isArray(decodeArr)) {
      var bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
      var decodeArrLength = decodeArr.length;
      var transform = new Int32Array(decodeArrLength);
      var transformNeeded = false;
      var maxValue = (1 << bitsPerComponent) - 1;

      for (var i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;

        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }

      if (transformNeeded) {
        jpegOptions.decodeTransform = transform;
      }
    }

    if ((0, _primitives.isDict)(this.params)) {
      var colorTransform = this.params.get("ColorTransform");

      if (Number.isInteger(colorTransform)) {
        jpegOptions.colorTransform = colorTransform;
      }
    }

    var jpegImage = new _jpg.JpegImage(jpegOptions);
    jpegImage.parse(this.bytes);
    var data = jpegImage.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGB: this.forceRGB,
      isSourcePDF: true
    });
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  };

  return JpegStream;
}();

exports.JpegStream = JpegStream;

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegImage = void 0;

var _util = __w_pdfjs_require__(4);

var _core_utils = __w_pdfjs_require__(138);

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var JpegError = /*#__PURE__*/function (_BaseException) {
  _inherits(JpegError, _BaseException);

  var _super = _createSuper(JpegError);

  function JpegError(msg) {
    _classCallCheck(this, JpegError);

    return _super.call(this, "JPEG error: ".concat(msg));
  }

  return JpegError;
}(_util.BaseException);

var DNLMarkerError = /*#__PURE__*/function (_BaseException2) {
  _inherits(DNLMarkerError, _BaseException2);

  var _super2 = _createSuper(DNLMarkerError);

  function DNLMarkerError(message, scanLines) {
    var _this;

    _classCallCheck(this, DNLMarkerError);

    _this = _super2.call(this, message);
    _this.scanLines = scanLines;
    return _this;
  }

  return DNLMarkerError;
}(_util.BaseException);

var EOIMarkerError = /*#__PURE__*/function (_BaseException3) {
  _inherits(EOIMarkerError, _BaseException3);

  var _super3 = _createSuper(EOIMarkerError);

  function EOIMarkerError() {
    _classCallCheck(this, EOIMarkerError);

    return _super3.apply(this, arguments);
  }

  return EOIMarkerError;
}(_util.BaseException);

var JpegImage = function JpegImageClosure() {
  var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
  var dctCos1 = 4017;
  var dctSin1 = 799;
  var dctCos3 = 3406;
  var dctSin3 = 2276;
  var dctCos6 = 1567;
  var dctSin6 = 3784;
  var dctSqrt2 = 5793;
  var dctSqrt1d2 = 2896;

  function JpegImage() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$decodeTransform = _ref.decodeTransform,
        decodeTransform = _ref$decodeTransform === void 0 ? null : _ref$decodeTransform,
        _ref$colorTransform = _ref.colorTransform,
        colorTransform = _ref$colorTransform === void 0 ? -1 : _ref$colorTransform;

    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0,
        code = [],
        i,
        j,
        length = 16;

    while (length > 0 && !codeLengths[length - 1]) {
      length--;
    }

    code.push({
      children: [],
      index: 0
    });
    var p = code[0],
        q;

    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];

        while (p.index > 0) {
          p = code.pop();
        }

        p.index++;
        code.push(p);

        while (code.length <= i) {
          code.push(q = {
            children: [],
            index: 0
          });
          p.children[p.index] = q.children;
          p = q;
        }

        k++;
      }

      if (i + 1 < length) {
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }
    }

    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
    var parseDNLMarker = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var startOffset = offset;
    var bitsData = 0,
        bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return bitsData >> bitsCount & 1;
      }

      bitsData = data[offset++];

      if (bitsData === 0xff) {
        var nextByte = data[offset++];

        if (nextByte) {
          if (nextByte === 0xdc && parseDNLMarker) {
            offset += 2;
            var scanLines = (0, _core_utils.readUint16)(data, offset);
            offset += 2;

            if (scanLines > 0 && scanLines !== frame.scanLines) {
              throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
            }
          } else if (nextByte === 0xd9) {
            if (parseDNLMarker) {
              var maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);

              if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {
                throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, " + "possibly caused by incorrect `scanLines` parameter", maybeScanLines);
              }
            }

            throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
          }

          throw new JpegError("unexpected marker ".concat((bitsData << 8 | nextByte).toString(16)));
        }
      }

      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;

      while (true) {
        node = node[readBit()];

        switch (_typeof(node)) {
          case "number":
            return node;

          case "object":
            continue;
        }

        throw new JpegError("invalid huffman sequence");
      }
    }

    function receive(length) {
      var n = 0;

      while (length > 0) {
        n = n << 1 | readBit();
        length--;
      }

      return n;
    }

    function receiveAndExtend(length) {
      if (length === 1) {
        return readBit() === 1 ? 1 : -1;
      }

      var n = receive(length);

      if (n >= 1 << length - 1) {
        return n;
      }

      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, blockOffset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[blockOffset] = component.pred += diff;
      var k = 1;

      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;

        if (s === 0) {
          if (r < 15) {
            break;
          }

          k += 16;
          continue;
        }

        k += r;
        var z = dctZigZag[k];
        component.blockData[blockOffset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, blockOffset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
      component.blockData[blockOffset] = component.pred += diff;
    }

    function decodeDCSuccessive(component, blockOffset) {
      component.blockData[blockOffset] |= readBit() << successive;
    }

    var eobrun = 0;

    function decodeACFirst(component, blockOffset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }

      var k = spectralStart,
          e = spectralEnd;

      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;

        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }

          k += 16;
          continue;
        }

        k += r;
        var z = dctZigZag[k];
        component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0,
        successiveACNextValue;

    function decodeACSuccessive(component, blockOffset) {
      var k = spectralStart;
      var e = spectralEnd;
      var r = 0;
      var s;
      var rs;

      while (k <= e) {
        var offsetZ = blockOffset + dctZigZag[k];
        var sign = component.blockData[offsetZ] < 0 ? -1 : 1;

        switch (successiveACState) {
          case 0:
            rs = decodeHuffman(component.huffmanTableAC);
            s = rs & 15;
            r = rs >> 4;

            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1) {
                throw new JpegError("invalid ACn encoding");
              }

              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }

            continue;

          case 1:
          case 2:
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            } else {
              r--;

              if (r === 0) {
                successiveACState = successiveACState === 2 ? 3 : 0;
              }
            }

            break;

          case 3:
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            } else {
              component.blockData[offsetZ] = successiveACNextValue << successive;
              successiveACState = 0;
            }

            break;

          case 4:
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            }

            break;
        }

        k++;
      }

      if (successiveACState === 4) {
        eobrun--;

        if (eobrun === 0) {
          successiveACState = 0;
        }
      }
    }

    var blockRow = 0;

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = mcu / mcusPerLine | 0;
      var mcuCol = mcu % mcusPerLine;
      blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, blockOffset);
    }

    function decodeBlock(component, decode, mcu) {
      blockRow = mcu / component.blocksPerLine | 0;
      var blockCol = mcu % component.blocksPerLine;
      var blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, blockOffset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;

    if (progressive) {
      if (spectralStart === 0) {
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      } else {
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      }
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0,
        fileMarker;
    var mcuExpected;

    if (componentsLength === 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }

    var h, v;

    while (mcu <= mcuExpected) {
      var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;

      if (mcuToRead > 0) {
        for (i = 0; i < componentsLength; i++) {
          components[i].pred = 0;
        }

        eobrun = 0;

        if (componentsLength === 1) {
          component = components[0];

          for (n = 0; n < mcuToRead; n++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n = 0; n < mcuToRead; n++) {
            for (i = 0; i < componentsLength; i++) {
              component = components[i];
              h = component.h;
              v = component.v;

              for (j = 0; j < v; j++) {
                for (k = 0; k < h; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }

            mcu++;
          }
        }
      }

      bitsCount = 0;
      fileMarker = findNextFileMarker(data, offset);

      if (!fileMarker) {
        break;
      }

      if (fileMarker.invalid) {
        var partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
        (0, _util.warn)("decodeScan - ".concat(partialMsg, " MCU data, current marker is: ").concat(fileMarker.invalid));
        offset = fileMarker.offset;
      }

      if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable,
        blockData = component.blockData;
    var v0, v1, v2, v3, v4, v5, v6, v7;
    var p0, p1, p2, p3, p4, p5, p6, p7;
    var t;

    if (!qt) {
      throw new JpegError("missing required Quantization Table.");
    }

    for (var row = 0; row < 64; row += 8) {
      p0 = blockData[blockBufferOffset + row];
      p1 = blockData[blockBufferOffset + row + 1];
      p2 = blockData[blockBufferOffset + row + 2];
      p3 = blockData[blockBufferOffset + row + 3];
      p4 = blockData[blockBufferOffset + row + 4];
      p5 = blockData[blockBufferOffset + row + 5];
      p6 = blockData[blockBufferOffset + row + 6];
      p7 = blockData[blockBufferOffset + row + 7];
      p0 *= qt[row];

      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 512 >> 10;
        p[row] = t;
        p[row + 1] = t;
        p[row + 2] = t;
        p[row + 3] = t;
        p[row + 4] = t;
        p[row + 5] = t;
        p[row + 6] = t;
        p[row + 7] = t;
        continue;
      }

      p1 *= qt[row + 1];
      p2 *= qt[row + 2];
      p3 *= qt[row + 3];
      p4 *= qt[row + 4];
      p5 *= qt[row + 5];
      p6 *= qt[row + 6];
      p7 *= qt[row + 7];
      v0 = dctSqrt2 * p0 + 128 >> 8;
      v1 = dctSqrt2 * p4 + 128 >> 8;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
      v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
      v5 = p3 << 4;
      v6 = p5 << 4;
      v0 = v0 + v1 + 1 >> 1;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5;
      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t;
      p[row] = v0 + v7;
      p[row + 7] = v0 - v7;
      p[row + 1] = v1 + v6;
      p[row + 6] = v1 - v6;
      p[row + 2] = v2 + v5;
      p[row + 5] = v2 - v5;
      p[row + 3] = v3 + v4;
      p[row + 4] = v3 - v4;
    }

    for (var col = 0; col < 8; ++col) {
      p0 = p[col];
      p1 = p[col + 8];
      p2 = p[col + 16];
      p3 = p[col + 24];
      p4 = p[col + 32];
      p5 = p[col + 40];
      p6 = p[col + 48];
      p7 = p[col + 56];

      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 8192 >> 14;

        if (t < -2040) {
          t = 0;
        } else if (t >= 2024) {
          t = 255;
        } else {
          t = t + 2056 >> 4;
        }

        blockData[blockBufferOffset + col] = t;
        blockData[blockBufferOffset + col + 8] = t;
        blockData[blockBufferOffset + col + 16] = t;
        blockData[blockBufferOffset + col + 24] = t;
        blockData[blockBufferOffset + col + 32] = t;
        blockData[blockBufferOffset + col + 40] = t;
        blockData[blockBufferOffset + col + 48] = t;
        blockData[blockBufferOffset + col + 56] = t;
        continue;
      }

      v0 = dctSqrt2 * p0 + 2048 >> 12;
      v1 = dctSqrt2 * p4 + 2048 >> 12;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
      v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
      v5 = p3;
      v6 = p5;
      v0 = (v0 + v1 + 1 >> 1) + 4112;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5;
      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t;
      p0 = v0 + v7;
      p7 = v0 - v7;
      p1 = v1 + v6;
      p6 = v1 - v6;
      p2 = v2 + v5;
      p5 = v2 - v5;
      p3 = v3 + v4;
      p4 = v3 - v4;

      if (p0 < 16) {
        p0 = 0;
      } else if (p0 >= 4080) {
        p0 = 255;
      } else {
        p0 >>= 4;
      }

      if (p1 < 16) {
        p1 = 0;
      } else if (p1 >= 4080) {
        p1 = 255;
      } else {
        p1 >>= 4;
      }

      if (p2 < 16) {
        p2 = 0;
      } else if (p2 >= 4080) {
        p2 = 255;
      } else {
        p2 >>= 4;
      }

      if (p3 < 16) {
        p3 = 0;
      } else if (p3 >= 4080) {
        p3 = 255;
      } else {
        p3 >>= 4;
      }

      if (p4 < 16) {
        p4 = 0;
      } else if (p4 >= 4080) {
        p4 = 255;
      } else {
        p4 >>= 4;
      }

      if (p5 < 16) {
        p5 = 0;
      } else if (p5 >= 4080) {
        p5 = 255;
      } else {
        p5 >>= 4;
      }

      if (p6 < 16) {
        p6 = 0;
      } else if (p6 >= 4080) {
        p6 = 255;
      } else {
        p6 >>= 4;
      }

      if (p7 < 16) {
        p7 = 0;
      } else if (p7 >= 4080) {
        p7 = 255;
      } else {
        p7 >>= 4;
      }

      blockData[blockBufferOffset + col] = p0;
      blockData[blockBufferOffset + col + 8] = p1;
      blockData[blockBufferOffset + col + 16] = p2;
      blockData[blockBufferOffset + col + 24] = p3;
      blockData[blockBufferOffset + col + 32] = p4;
      blockData[blockBufferOffset + col + 40] = p5;
      blockData[blockBufferOffset + col + 48] = p6;
      blockData[blockBufferOffset + col + 56] = p7;
    }
  }

  function buildComponentData(frame, component) {
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var computationBuffer = new Int16Array(64);

    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }

    return component.blockData;
  }

  function findNextFileMarker(data, currentPos) {
    var startPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentPos;
    var maxPos = data.length - 1;
    var newPos = startPos < currentPos ? startPos : currentPos;

    if (currentPos >= maxPos) {
      return null;
    }

    var currentMarker = (0, _core_utils.readUint16)(data, currentPos);

    if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
      return {
        invalid: null,
        marker: currentMarker,
        offset: currentPos
      };
    }

    var newMarker = (0, _core_utils.readUint16)(data, newPos);

    while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
      if (++newPos >= maxPos) {
        return null;
      }

      newMarker = (0, _core_utils.readUint16)(data, newPos);
    }

    return {
      invalid: currentMarker.toString(16),
      marker: newMarker,
      offset: newPos
    };
  }

  JpegImage.prototype = {
    parse: function parse(data) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$dnlScanLines = _ref2.dnlScanLines,
          dnlScanLines = _ref2$dnlScanLines === void 0 ? null : _ref2$dnlScanLines;

      function readDataBlock() {
        var length = (0, _core_utils.readUint16)(data, offset);
        offset += 2;
        var endOffset = offset + length - 2;
        var fileMarker = findNextFileMarker(data, endOffset, offset);

        if (fileMarker && fileMarker.invalid) {
          (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker.invalid);
          endOffset = fileMarker.offset;
        }

        var array = data.subarray(offset, endOffset);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);

        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;
          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }

        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0;
      var jfif = null;
      var adobe = null;
      var frame, resetInterval;
      var numSOSMarkers = 0;
      var quantizationTables = [];
      var huffmanTablesAC = [],
          huffmanTablesDC = [];
      var fileMarker = (0, _core_utils.readUint16)(data, offset);
      offset += 2;

      if (fileMarker !== 0xffd8) {
        throw new JpegError("SOI not found");
      }

      fileMarker = (0, _core_utils.readUint16)(data, offset);
      offset += 2;

      markerLoop: while (fileMarker !== 0xffd9) {
        var i, j, l;

        switch (fileMarker) {
          case 0xffe0:
          case 0xffe1:
          case 0xffe2:
          case 0xffe3:
          case 0xffe4:
          case 0xffe5:
          case 0xffe6:
          case 0xffe7:
          case 0xffe8:
          case 0xffe9:
          case 0xffea:
          case 0xffeb:
          case 0xffec:
          case 0xffed:
          case 0xffee:
          case 0xffef:
          case 0xfffe:
            var appData = readDataBlock();

            if (fileMarker === 0xffe0) {
              if (appData[0] === 0x4a && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
                jfif = {
                  version: {
                    major: appData[5],
                    minor: appData[6]
                  },
                  densityUnits: appData[7],
                  xDensity: appData[8] << 8 | appData[9],
                  yDensity: appData[10] << 8 | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }

            if (fileMarker === 0xffee) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6f && appData[3] === 0x62 && appData[4] === 0x65) {
                adobe = {
                  version: appData[5] << 8 | appData[6],
                  flags0: appData[7] << 8 | appData[8],
                  flags1: appData[9] << 8 | appData[10],
                  transformCode: appData[11]
                };
              }
            }

            break;

          case 0xffdb:
            var quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
            offset += 2;
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            var z;

            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Uint16Array(64);

              if (quantizationTableSpec >> 4 === 0) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if (quantizationTableSpec >> 4 === 1) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                }
              } else {
                throw new JpegError("DQT - invalid table spec");
              }

              quantizationTables[quantizationTableSpec & 15] = tableData;
            }

            break;

          case 0xffc0:
          case 0xffc1:
          case 0xffc2:
            if (frame) {
              throw new JpegError("Only single frame JPEGs supported");
            }

            offset += 2;
            frame = {};
            frame.extended = fileMarker === 0xffc1;
            frame.progressive = fileMarker === 0xffc2;
            frame.precision = data[offset++];
            var sofScanLines = (0, _core_utils.readUint16)(data, offset);
            offset += 2;
            frame.scanLines = dnlScanLines || sofScanLines;
            frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
            offset += 2;
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++],
                componentId;
            var maxH = 0,
                maxV = 0;

            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;

              if (maxH < h) {
                maxH = h;
              }

              if (maxV < v) {
                maxV = v;
              }

              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationId: qId,
                quantizationTable: null
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }

            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xffc4:
            var huffmanLength = (0, _core_utils.readUint16)(data, offset);
            offset += 2;

            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;

              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += codeLengths[j] = data[offset];
              }

              var huffmanValues = new Uint8Array(codeLengthSum);

              for (j = 0; j < codeLengthSum; j++, offset++) {
                huffmanValues[j] = data[offset];
              }

              i += 17 + codeLengthSum;
              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            }

            break;

          case 0xffdd:
            offset += 2;
            resetInterval = (0, _core_utils.readUint16)(data, offset);
            offset += 2;
            break;

          case 0xffda:
            var parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
            offset += 2;
            var selectorsCount = data[offset++];
            var components = [],
                component;

            for (i = 0; i < selectorsCount; i++) {
              var index = data[offset++];
              var componentIndex = frame.componentIds[index];
              component = frame.components[componentIndex];
              component.index = index;
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }

            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];

            try {
              var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
              offset += processed;
            } catch (ex) {
              if (ex instanceof DNLMarkerError) {
                (0, _util.warn)("".concat(ex.message, " -- attempting to re-parse the JPEG image."));
                return this.parse(data, {
                  dnlScanLines: ex.scanLines
                });
              } else if (ex instanceof EOIMarkerError) {
                (0, _util.warn)("".concat(ex.message, " -- ignoring the rest of the image data."));
                break markerLoop;
              }

              throw ex;
            }

            break;

          case 0xffdc:
            offset += 4;
            break;

          case 0xffff:
            if (data[offset] !== 0xff) {
              offset--;
            }

            break;

          default:
            var nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);

            if (nextFileMarker && nextFileMarker.invalid) {
              (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
              offset = nextFileMarker.offset;
              break;
            }

            if (!nextFileMarker || offset >= data.length - 1) {
              (0, _util.warn)("JpegImage.parse - reached the end of the image data " + "without finding an EOI marker (0xFFD9).");
              break markerLoop;
            }

            throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
        }

        fileMarker = (0, _core_utils.readUint16)(data, offset);
        offset += 2;
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];

      for (i = 0; i < frame.components.length; i++) {
        component = frame.components[i];
        var quantizationTable = quantizationTables[component.quantizationId];

        if (quantizationTable) {
          component.quantizationTable = quantizationTable;
        }

        this.components.push({
          index: component.index,
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn
        });
      }

      this.numComponents = this.components.length;
      return undefined;
    },
    _getLinearizedBlockData: function _getLinearizedBlockData(width, height) {
      var isSourcePDF = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var scaleX = this.width / width,
          scaleY = this.height / height;
      var component, componentScaleX, componentScaleY, blocksPerScanline;
      var x, y, i, j, k;
      var index;
      var offset = 0;
      var output;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8ClampedArray(dataLength);
      var xScaleBlockOffset = new Uint32Array(width);
      var mask3LSB = 0xfffffff8;
      var lastComponentScaleX;

      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;
        output = component.output;
        blocksPerScanline = component.blocksPerLine + 1 << 3;

        if (componentScaleX !== lastComponentScaleX) {
          for (x = 0; x < width; x++) {
            j = 0 | x * componentScaleX;
            xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
          }

          lastComponentScaleX = componentScaleX;
        }

        for (y = 0; y < height; y++) {
          j = 0 | y * componentScaleY;
          index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;

          for (x = 0; x < width; x++) {
            data[offset] = output[index + xScaleBlockOffset[x]];
            offset += numComponents;
          }
        }
      }

      var transform = this._decodeTransform;

      if (!isSourcePDF && numComponents === 4 && !transform) {
        transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
      }

      if (transform) {
        for (i = 0; i < dataLength;) {
          for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
            data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
          }
        }
      }

      return data;
    },

    get _isColorConversionNeeded() {
      if (this.adobe) {
        return !!this.adobe.transformCode;
      }

      if (this.numComponents === 3) {
        if (this._colorTransform === 0) {
          return false;
        } else if (this.components[0].index === 0x52 && this.components[1].index === 0x47 && this.components[2].index === 0x42) {
          return false;
        }

        return true;
      }

      if (this._colorTransform === 1) {
        return true;
      }

      return false;
    },

    _convertYccToRgb: function convertYccToRgb(data) {
      var Y, Cb, Cr;

      for (var i = 0, length = data.length; i < length; i += 3) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = Y - 179.456 + 1.402 * Cr;
        data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
        data[i + 2] = Y - 226.816 + 1.772 * Cb;
      }

      return data;
    },
    _convertYcckToRgb: function convertYcckToRgb(data) {
      var Y, Cb, Cr, k;
      var offset = 0;

      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        k = data[i + 3];
        data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
        data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
        data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
      }

      return data.subarray(0, offset);
    },
    _convertYcckToCmyk: function convertYcckToCmyk(data) {
      var Y, Cb, Cr;

      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = 434.456 - Y - 1.402 * Cr;
        data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
        data[i + 2] = 481.816 - Y - 1.772 * Cb;
      }

      return data;
    },
    _convertCmykToRgb: function convertCmykToRgb(data) {
      var c, m, y, k;
      var offset = 0;

      for (var i = 0, length = data.length; i < length; i += 4) {
        c = data[i];
        m = data[i + 1];
        y = data[i + 2];
        k = data[i + 3];
        data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);
        data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.00031891311758832814 * k + 0.7364883807733168);
        data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
      }

      return data.subarray(0, offset);
    },
    getData: function getData(_ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          _ref3$forceRGB = _ref3.forceRGB,
          forceRGB = _ref3$forceRGB === void 0 ? false : _ref3$forceRGB,
          _ref3$isSourcePDF = _ref3.isSourcePDF,
          isSourcePDF = _ref3$isSourcePDF === void 0 ? false : _ref3$isSourcePDF;

      if (this.numComponents > 4) {
        throw new JpegError("Unsupported color mode");
      }

      var data = this._getLinearizedBlockData(width, height, isSourcePDF);

      if (this.numComponents === 1 && forceRGB) {
        var dataLength = data.length;
        var rgbData = new Uint8ClampedArray(dataLength * 3);
        var offset = 0;

        for (var i = 0; i < dataLength; i++) {
          var grayColor = data[i];
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
        }

        return rgbData;
      } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
        return this._convertYccToRgb(data);
      } else if (this.numComponents === 4) {
        if (this._isColorConversionNeeded) {
          if (forceRGB) {
            return this._convertYcckToRgb(data);
          }

          return this._convertYcckToCmyk(data);
        } else if (forceRGB) {
          return this._convertCmykToRgb(data);
        }
      }

      return data;
    }
  };
  return JpegImage;
}();

exports.JpegImage = JpegImage;

/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxStream = void 0;

var _stream = __w_pdfjs_require__(142);

var _jpx = __w_pdfjs_require__(151);

var _util = __w_pdfjs_require__(4);

var JpxStream = function JpxStreamClosure() {
  function JpxStream(stream, maybeLength, dict, params) {
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;

    _stream.DecodeStream.call(this, maybeLength);
  }

  JpxStream.prototype = Object.create(_stream.DecodeStream.prototype);
  Object.defineProperty(JpxStream.prototype, "bytes", {
    get: function JpxStream_bytes() {
      return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });

  JpxStream.prototype.ensureBuffer = function (requested) {};

  JpxStream.prototype.readBlock = function () {
    if (this.eof) {
      return;
    }

    var jpxImage = new _jpx.JpxImage();
    jpxImage.parse(this.bytes);
    var width = jpxImage.width;
    var height = jpxImage.height;
    var componentsCount = jpxImage.componentsCount;
    var tileCount = jpxImage.tiles.length;

    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      var data = new Uint8ClampedArray(width * height * componentsCount);

      for (var k = 0; k < tileCount; k++) {
        var tileComponents = jpxImage.tiles[k];
        var tileWidth = tileComponents.width;
        var tileHeight = tileComponents.height;
        var tileLeft = tileComponents.left;
        var tileTop = tileComponents.top;
        var src = tileComponents.items;
        var srcPosition = 0;
        var dataPosition = (width * tileTop + tileLeft) * componentsCount;
        var imgRowSize = width * componentsCount;
        var tileRowSize = tileWidth * componentsCount;

        for (var j = 0; j < tileHeight; j++) {
          var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }

      this.buffer = data;
    }

    this.bufferLength = this.buffer.length;
    this.eof = true;
  };

  return JpxStream;
}();

exports.JpxStream = JpxStream;

/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxImage = void 0;

var _util = __w_pdfjs_require__(4);

var _core_utils = __w_pdfjs_require__(138);

var _arithmetic_decoder = __w_pdfjs_require__(147);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var JpxError = /*#__PURE__*/function (_BaseException) {
  _inherits(JpxError, _BaseException);

  var _super = _createSuper(JpxError);

  function JpxError(msg) {
    _classCallCheck(this, JpxError);

    return _super.call(this, "JPX error: ".concat(msg));
  }

  return JpxError;
}(_util.BaseException);

var JpxImage = function JpxImageClosure() {
  var SubbandsGainLog2 = {
    LL: 0,
    LH: 1,
    HL: 1,
    HH: 2
  };

  function JpxImage() {
    this.failOnCorruptedImage = false;
  }

  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {
      var head = (0, _core_utils.readUint16)(data, 0);

      if (head === 0xff4f) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0,
          length = data.length;

      while (position < length) {
        var headerSize = 8;
        var lbox = (0, _core_utils.readUint32)(data, position);
        var tbox = (0, _core_utils.readUint32)(data, position + 4);
        position += headerSize;

        if (lbox === 1) {
          lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
          position += 8;
          headerSize += 8;
        }

        if (lbox === 0) {
          lbox = length - position + headerSize;
        }

        if (lbox < headerSize) {
          throw new JpxError("Invalid box field size");
        }

        var dataLength = lbox - headerSize;
        var jumpDataLength = true;

        switch (tbox) {
          case 0x6a703268:
            jumpDataLength = false;
            break;

          case 0x636f6c72:
            var method = data[position];

            if (method === 1) {
              var colorspace = (0, _core_utils.readUint32)(data, position + 3);

              switch (colorspace) {
                case 16:
                case 17:
                case 18:
                  break;

                default:
                  (0, _util.warn)("Unknown colorspace " + colorspace);
                  break;
              }
            } else if (method === 2) {
              (0, _util.info)("ICC profile not supported");
            }

            break;

          case 0x6a703263:
            this.parseCodestream(data, position, position + dataLength);
            break;

          case 0x6a502020:
            if ((0, _core_utils.readUint32)(data, position) !== 0x0d0a870a) {
              (0, _util.warn)("Invalid JP2 signature");
            }

            break;

          case 0x6a501a1a:
          case 0x66747970:
          case 0x72726571:
          case 0x72657320:
          case 0x69686472:
            break;

          default:
            var headerType = String.fromCharCode(tbox >> 24 & 0xff, tbox >> 16 & 0xff, tbox >> 8 & 0xff, tbox & 0xff);
            (0, _util.warn)("Unsupported header type " + tbox + " (" + headerType + ")");
            break;
        }

        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();

      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = oldByte << 8 | newByte;

        if (code === 0xff51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0;
          var Ysiz = stream.getInt32() >>> 0;
          var XOsiz = stream.getInt32() >>> 0;
          var YOsiz = stream.getInt32() >>> 0;
          stream.skip(16);
          var Csiz = stream.getUint16();
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          this.bitsPerComponent = 8;
          return;
        }
      }

      throw new JpxError("No size marker found in JPX stream");
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      var doNotRecover = false;

      try {
        var position = start;

        while (position + 1 < end) {
          var code = (0, _core_utils.readUint16)(data, position);
          position += 2;
          var length = 0,
              j,
              sqcd,
              spqcds,
              spqcdSize,
              scalarExpounded,
              tile;

          switch (code) {
            case 0xff4f:
              context.mainHeader = true;
              break;

            case 0xffd9:
              break;

            case 0xff51:
              length = (0, _core_utils.readUint16)(data, position);
              var siz = {};
              siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
              siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
              siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
              siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
              siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
              siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
              siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
              siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
              var componentsCount = (0, _core_utils.readUint16)(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;

              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7f) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 2]
                };
                j += 3;
                calculateComponentDimensions(component, siz);
                components.push(component);
              }

              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;

            case 0xff5c:
              length = (0, _core_utils.readUint16)(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];

              switch (sqcd & 0x1f) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;

                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;

                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;

                default:
                  throw new Error("Invalid SQcd value " + sqcd);
              }

              qcd.noQuantization = spqcdSize === 8;
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];

              while (j < length + position) {
                var spqcd = {};

                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                  j += 2;
                }

                spqcds.push(spqcd);
              }

              qcd.SPqcds = spqcds;

              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }

              break;

            case 0xff5d:
              length = (0, _core_utils.readUint16)(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;

              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = (0, _core_utils.readUint16)(data, j);
                j += 2;
              }

              sqcd = data[j++];

              switch (sqcd & 0x1f) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;

                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;

                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;

                default:
                  throw new Error("Invalid SQcd value " + sqcd);
              }

              qcc.noQuantization = spqcdSize === 8;
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];

              while (j < length + position) {
                spqcd = {};

                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                  j += 2;
                }

                spqcds.push(spqcd);
              }

              qcc.SPqcds = spqcds;

              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }

              break;

            case 0xff52:
              length = (0, _core_utils.readUint16)(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = (0, _core_utils.readUint16)(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];
              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xf) + 2;
              cod.ycb = (data[j++] & 0xf) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticallyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];

              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];

                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xf,
                    PPy: precinctsSize >> 4
                  });
                }

                cod.precinctsSizes = precinctsSizes;
              }

              var unsupported = [];

              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push("selectiveArithmeticCodingBypass");
              }

              if (cod.resetContextProbabilities) {
                unsupported.push("resetContextProbabilities");
              }

              if (cod.terminationOnEachCodingPass) {
                unsupported.push("terminationOnEachCodingPass");
              }

              if (cod.verticallyStripe) {
                unsupported.push("verticallyStripe");
              }

              if (cod.predictableTermination) {
                unsupported.push("predictableTermination");
              }

              if (unsupported.length > 0) {
                doNotRecover = true;
                (0, _util.warn)("JPX: Unsupported COD options (".concat(unsupported.join(", "), ")."));
              }

              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }

              break;

            case 0xff90:
              length = (0, _core_utils.readUint16)(data, position);
              tile = {};
              tile.index = (0, _core_utils.readUint16)(data, position + 2);
              tile.length = (0, _core_utils.readUint32)(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];
              context.mainHeader = false;

              if (tile.partIndex === 0) {
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0);
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0);
              }

              context.currentTile = tile;
              break;

            case 0xff93:
              tile = context.currentTile;

              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;

            case 0xff53:
              (0, _util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");

            case 0xff55:
            case 0xff57:
            case 0xff58:
            case 0xff64:
              length = (0, _core_utils.readUint16)(data, position);
              break;

            default:
              throw new Error("Unknown codestream code: " + code.toString(16));
          }

          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw new JpxError(e.message);
        } else {
          (0, _util.warn)("JPX: Trying to recover from: \"".concat(e.message, "\"."));
        }
      }

      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };

  function calculateComponentDimensions(component, siz) {
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }

  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    var tile,
        tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);

    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }

    context.tiles = tiles;
    var componentsCount = siz.Csiz;

    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];

      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }

  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};

    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }

    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
    return result;
  }

  function buildPrecincts(context, resolution, dimensions) {
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
    var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
    var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
    var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
    var numprecincts = numprecinctswide * numprecinctshigh;
    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }

  function buildCodeblocks(context, subband, dimensions) {
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
    var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;

    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };
        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + pj * precinctParameters.numprecinctswide;
        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }

        codeblocks.push(codeblock);
        var precinct = precincts[precinctNumber];

        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }

          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }

        codeblock.precinct = precinct;
      }
    }

    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }

  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    var subbands = resolution.subbands;

    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;

      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];

        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }

        precinctCodeblocks.push(codeblock);
      }
    }

    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }

  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;

    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0,
        r = 0,
        i = 0,
        k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];

            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;

            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }

            k = 0;
          }

          i = 0;
        }

        r = 0;
      }

      throw new JpxError("Out of packets");
    };
  }

  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;

    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0,
        l = 0,
        i = 0,
        k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];

            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;

            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }

            k = 0;
          }

          i = 0;
        }

        l = 0;
      }

      throw new JpxError("Out of packets");
    };
  }

  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;

    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
    }

    var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);

    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;

      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;

        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
        }
      }

      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }

    l = 0;
    r = 0;
    c = 0;
    p = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var _component = tile.components[c];

            if (r > _component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = _component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;

            if (p >= numprecincts) {
              continue;
            }

            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }

            l = 0;
          }

          c = 0;
        }

        p = 0;
      }

      throw new JpxError("Out of packets");
    };
  }

  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0,
        r = 0,
        c = 0,
        px = 0,
        py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;

            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);

              if (k === null) {
                continue;
              }

              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }

              l = 0;
            }

            r = 0;
          }

          c = 0;
        }

        px = 0;
      }

      throw new JpxError("Out of packets");
    };
  }

  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0,
        r = 0,
        c = 0,
        px = 0,
        py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;

        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);

              if (k === null) {
                continue;
              }

              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }

              l = 0;
            }

            r = 0;
          }

          px = 0;
        }

        py = 0;
      }

      throw new JpxError("Out of packets");
    };
  }

  function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;

    if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
      return null;
    }

    var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
    return posX / sizeInImageScale.height + startPrecinctRowIndex;
  }

  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);

    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;

      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
        minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }

      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }

    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }

  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;

    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      var resolutions = [];
      var subbands = [];

      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << decompositionLevelsCount - r;
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);
        var subband;

        if (r === 0) {
          subband = {};
          subband.type = "LL";
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << decompositionLevelsCount - r + 1;
          var resolutionSubbands = [];
          subband = {};
          subband.type = "HL";
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          subband = {};
          subband.type = "LH";
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          subband = {};
          subband.type = "HH";
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          resolution.subbands = resolutionSubbands;
        }
      }

      component.resolutions = resolutions;
      component.subbands = subbands;
    }

    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;

    switch (progressionOrder) {
      case 0:
        tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
        break;

      case 1:
        tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
        break;

      case 2:
        tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
        break;

      case 3:
        tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
        break;

      case 4:
        tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
        break;

      default:
        throw new JpxError("Unsupported progression order ".concat(progressionOrder));
    }
  }

  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer,
        bufferSize = 0,
        skipNextBit = false;

    function readBits(count) {
      while (bufferSize < count) {
        var b = data[offset + position];
        position++;

        if (skipNextBit) {
          buffer = buffer << 7 | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = buffer << 8 | b;
          bufferSize += 8;
        }

        if (b === 0xff) {
          skipNextBit = true;
        }
      }

      bufferSize -= count;
      return buffer >>> bufferSize & (1 << count) - 1;
    }

    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xff && data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xff && data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }

      return false;
    }

    function skipBytes(count) {
      position += count;
    }

    function alignToByte() {
      bufferSize = 0;

      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }

    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }

      if (readBits(1) === 0) {
        return 2;
      }

      var value = readBits(2);

      if (value < 3) {
        return value + 3;
      }

      value = readBits(5);

      if (value < 31) {
        return value + 6;
      }

      value = readBits(7);
      return value + 37;
    }

    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;

    while (position < dataLength) {
      alignToByte();

      if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
        skipBytes(4);
      }

      var packet = packetsIterator.nextPacket();

      if (!readBits(1)) {
        continue;
      }

      var layerNumber = packet.layerNumber;
      var queue = [],
          codeblock;

      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
        codeblock = packet.codeblocks[i];
        var precinct = codeblock.precinct;
        var codeblockColumn = codeblock.cbx - precinct.cbxMin;
        var codeblockRow = codeblock.cby - precinct.cbyMin;
        var codeblockIncluded = false;
        var firstTimeInclusion = false;
        var valueReady;

        if (codeblock.included !== undefined) {
          codeblockIncluded = !!readBits(1);
        } else {
          precinct = codeblock.precinct;
          var inclusionTree, zeroBitPlanesTree;

          if (precinct.inclusionTree !== undefined) {
            inclusionTree = precinct.inclusionTree;
          } else {
            var width = precinct.cbxMax - precinct.cbxMin + 1;
            var height = precinct.cbyMax - precinct.cbyMin + 1;
            inclusionTree = new InclusionTree(width, height, layerNumber);
            zeroBitPlanesTree = new TagTree(width, height);
            precinct.inclusionTree = inclusionTree;
            precinct.zeroBitPlanesTree = zeroBitPlanesTree;
          }

          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
            while (true) {
              if (readBits(1)) {
                valueReady = !inclusionTree.nextLevel();

                if (valueReady) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                }
              } else {
                inclusionTree.incrementValue(layerNumber);
                break;
              }
            }
          }
        }

        if (!codeblockIncluded) {
          continue;
        }

        if (firstTimeInclusion) {
          zeroBitPlanesTree = precinct.zeroBitPlanesTree;
          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);

          while (true) {
            if (readBits(1)) {
              valueReady = !zeroBitPlanesTree.nextLevel();

              if (valueReady) {
                break;
              }
            } else {
              zeroBitPlanesTree.incrementValue();
            }
          }

          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
        }

        var codingpasses = readCodingpasses();

        while (readBits(1)) {
          codeblock.Lblock++;
        }

        var codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
        var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
        var codedDataLength = readBits(bits);
        queue.push({
          codeblock: codeblock,
          codingpasses: codingpasses,
          dataLength: codedDataLength
        });
      }

      alignToByte();

      if (ephMarkerUsed) {
        skipMarkerIfEqual(0x92);
      }

      while (queue.length > 0) {
        var packetItem = queue.shift();
        codeblock = packetItem.codeblock;

        if (codeblock.data === undefined) {
          codeblock.data = [];
        }

        codeblock.data.push({
          data: data,
          start: offset + position,
          end: offset + position + packetItem.dataLength,
          codingpasses: packetItem.codingpasses
        });
        position += packetItem.dataLength;
      }
    }

    return position;
  }

  function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === "H" ? 1 : 0;
    var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;

      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }

      if (codeblock.data === undefined) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2;
      var data = codeblock.data,
          totalLength = 0,
          codingpasses = 0;
      var j, jj, dataItem;

      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }

      var encodedData = new Uint8Array(totalLength);
      var position = 0;

      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }

      var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropagationPass();
            break;

          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;

          case 2:
            bitModel.runCleanupPass();

            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }

            break;
        }

        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      var interleave = subband.type !== "LL";

      for (j = 0; j < blockHeight; j++) {
        var row = offset / width | 0;
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;

        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];

          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;

            if (sign[position] !== 0) {
              n = -n;
            }

            nb = bitsDecoded[position];
            var pos = interleave ? levelOffset + (offset << 1) : offset;

            if (reversible && nb >= mb) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << mb - nb);
            }
          }

          offset++;
          position++;
        }

        offset += width - blockWidth;
      }
    }
  }

  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;
    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
    var subbandCoefficients = [];
    var b = 0;

    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];
      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      var coefficients = new Float32Array(width * height);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;

        if (!scalarExpounded) {
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];
        var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);
        var mb = guardBits + epsilon - 1;
        copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
      }

      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }

    var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }

  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];

    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;

      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }

      var tile0 = transformedTiles[0];
      var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };
      var shift, offset;
      var pos = 0,
          j,
          jj,
          y0,
          y1,
          y2;

      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;

        if (!component0.codingStyleParameters.reversibleTransformation) {
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            out[pos++] = y0 + 1.402 * y2 >> shift;
            out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
            out[pos++] = y0 + 1.772 * y1 >> shift;
          }
        } else {
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            var g = y0 - (y2 + y1 >> 2);
            out[pos++] = g + y2 >> shift;
            out[pos++] = g >> shift;
            out[pos++] = g + y1 >> shift;
          }
        }

        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            out[pos] = y3items[j] + offset >> shift;
          }
        }
      } else {
        for (c = 0; c < componentsCount; c++) {
          var items = transformedTiles[c].items;
          shift = components[c].precision - 8;
          offset = (128 << shift) + 0.5;

          for (pos = c, j = 0, jj = items.length; j < jj; j++) {
            out[pos] = items[j] + offset >> shift;
            pos += componentsCount;
          }
        }
      }

      resultImages.push(result);
    }

    return resultImages;
  }

  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];

    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;
      component.codingStyleParameters = codOrCoc;
    }

    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  var TagTree = function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
      this.levels = [];

      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }

    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0,
            value = 0,
            level;

        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;

          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }

          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;

        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  }();

  var InclusionTree = function InclusionTreeClosure() {
    function InclusionTree(width, height, defaultValue) {
      var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
      this.levels = [];

      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);

        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = defaultValue;
        }

        var level = {
          width: width,
          height: height,
          items: items
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }

    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        var currentLevel = 0;

        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;
          var value = level.items[index];

          if (value === 0xff) {
            break;
          }

          if (value > stopValue) {
            this.currentLevel = currentLevel;
            this.propagateValues();
            return false;
          }

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        this.currentLevel = currentLevel - 1;
        return true;
      },
      incrementValue: function InclusionTree_incrementValue(stopValue) {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = stopValue + 1;
        this.propagateValues();
      },
      propagateValues: function InclusionTree_propagateValues() {
        var levelIndex = this.currentLevel;
        var level = this.levels[levelIndex];
        var currentValue = level.items[level.index];

        while (--levelIndex >= 0) {
          level = this.levels[levelIndex];
          level.items[level.index] = currentValue;
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        level.items[level.index] = 0xff;
        currentLevel--;

        if (currentLevel < 0) {
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return InclusionTree;
  }();

  var BitModel = function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
    var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
    var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;
      var contextLabelTable;

      if (subband === "HH") {
        contextLabelTable = HHContextLabel;
      } else if (subband === "HL") {
        contextLabelTable = HLContextLabel;
      } else {
        contextLabelTable = LLAndLHContextsLabel;
      }

      this.contextLabelTable = contextLabelTable;
      var coefficientCount = width * height;
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      var coefficentsMagnitude;

      if (mb > 14) {
        coefficentsMagnitude = new Uint32Array(coefficientCount);
      } else if (mb > 6) {
        coefficentsMagnitude = new Uint16Array(coefficientCount);
      } else {
        coefficentsMagnitude = new Uint8Array(coefficientCount);
      }

      this.coefficentsMagnitude = coefficentsMagnitude;
      this.processingFlags = new Uint8Array(coefficientCount);
      var bitsDecoded = new Uint8Array(coefficientCount);

      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }

      this.bitsDecoded = bitsDecoded;
      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        this.contexts = new Int8Array(19);
        this.contexts[0] = 4 << 1 | 0;
        this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
        this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
      },
      setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width,
            height = this.height;
        var left = column > 0;
        var right = column + 1 < width;
        var i;

        if (row > 0) {
          i = index - width;

          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }

          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }

          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;

          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }

          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }

          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }

        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }

        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;

            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;

              if (i >= height) {
                break;
              }

              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);

              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }

              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;
        significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;

        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];

          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }

        var horizontalContribution = 3 * contribution;
        significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;

        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];

          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }

        return decoded;
      },
      runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);

          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {
              if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;

              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                var significance = neighborsSignificance[index] & 127;
                contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;

        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;

          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
            var i1 = 0,
                index = index0;
            var i = i0,
                sign;

            if (allEmpty) {
              var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);

              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue;
              }

              i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);

              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
              index = index0;

              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }

            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);

              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }

              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);

        if (symbol !== 0xa) {
          throw new JpxError("Invalid segmentation symbol");
        }
      }
    };
    return BitModel;
  }();

  var Transform = function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate = function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];

      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }

      return ll;
    };

    Transform.prototype.extend = function extend(buffer, offset, size) {
      var i1 = offset - 1,
          j1 = offset + 1;
      var i2 = offset + size - 2,
          j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };

    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
      var llWidth = ll.width,
          llHeight = ll.height,
          llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;

        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }

      llItems = ll.items = null;
      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      if (width === 1) {
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);
          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);
          items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
        }
      }

      var numBuffers = 16;
      var colBuffers = [];

      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }

      var b,
          currentBuffer = 0;
      ll = bufferPadding + height;

      if (height === 1) {
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);

            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }

            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          if (currentBuffer === 0) {
            k = u - numBuffers + 1;

            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        width: width,
        height: height,
        items: items
      };
    };

    return Transform;
  }();

  var IrreversibleTransform = function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);

    IrreversibleTransform.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;
      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;
      j = offset - 3;

      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      j = offset - 2;
      current = delta * x[j - 1];

      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;

        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      j = offset - 1;
      current = gamma * x[j - 1];

      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;

        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      j = offset;
      current = beta * x[j - 1];

      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;

        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];

        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;

          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  }();

  var ReversibleTransform = function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);

    ReversibleTransform.prototype.filter = function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += x[j - 1] + x[j + 1] >> 1;
      }
    };

    return ReversibleTransform;
  }();

  return JpxImage;
}();

exports.JpxImage = JpxImage;

/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.calculateSHA512 = exports.calculateSHA384 = exports.calculateSHA256 = exports.calculateMD5 = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = void 0;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _stream = __w_pdfjs_require__(142);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ARCFourCipher = function ARCFourCipherClosure() {
  function ARCFourCipher(key) {
    this.a = 0;
    this.b = 0;
    var s = new Uint8Array(256);
    var i,
        j = 0,
        tmp,
        keyLength = key.length;

    for (i = 0; i < 256; ++i) {
      s[i] = i;
    }

    for (i = 0; i < 256; ++i) {
      tmp = s[i];
      j = j + tmp + key[i % keyLength] & 0xff;
      s[i] = s[j];
      s[j] = tmp;
    }

    this.s = s;
  }

  ARCFourCipher.prototype = {
    encryptBlock: function ARCFourCipher_encryptBlock(data) {
      var i,
          n = data.length,
          tmp,
          tmp2;
      var a = this.a,
          b = this.b,
          s = this.s;
      var output = new Uint8Array(n);

      for (i = 0; i < n; ++i) {
        a = a + 1 & 0xff;
        tmp = s[a];
        b = b + tmp & 0xff;
        tmp2 = s[b];
        s[a] = tmp2;
        s[b] = tmp;
        output[i] = data[i] ^ s[tmp + tmp2 & 0xff];
      }

      this.a = a;
      this.b = b;
      return output;
    }
  };
  ARCFourCipher.prototype.decryptBlock = ARCFourCipher.prototype.encryptBlock;
  ARCFourCipher.prototype.encrypt = ARCFourCipher.prototype.encryptBlock;
  return ARCFourCipher;
}();

exports.ARCFourCipher = ARCFourCipher;

var calculateMD5 = function calculateMD5Closure() {
  var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);

  function hash(data, offset, length) {
    var h0 = 1732584193,
        h1 = -271733879,
        h2 = -1732584194,
        h3 = 271733878;
    var paddedLength = length + 72 & ~63;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    n = paddedLength - 8;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = length << 3 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    var w = new Int32Array(16);

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }

      var a = h0,
          b = h1,
          c = h2,
          d = h3,
          f,
          g;

      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }

        var tmp = d,
            rotateArg = a + f + k[j] + w[g] | 0,
            rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }

      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }

    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
  }

  return hash;
}();

exports.calculateMD5 = calculateMD5;

var Word64 = function Word64Closure() {
  function Word64(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }

  Word64.prototype = {
    and: function Word64_and(word) {
      this.high &= word.high;
      this.low &= word.low;
    },
    xor: function Word64_xor(word) {
      this.high ^= word.high;
      this.low ^= word.low;
    },
    or: function Word64_or(word) {
      this.high |= word.high;
      this.low |= word.low;
    },
    shiftRight: function Word64_shiftRight(places) {
      if (places >= 32) {
        this.low = this.high >>> places - 32 | 0;
        this.high = 0;
      } else {
        this.low = this.low >>> places | this.high << 32 - places;
        this.high = this.high >>> places | 0;
      }
    },
    shiftLeft: function Word64_shiftLeft(places) {
      if (places >= 32) {
        this.high = this.low << places - 32;
        this.low = 0;
      } else {
        this.high = this.high << places | this.low >>> 32 - places;
        this.low = this.low << places;
      }
    },
    rotateRight: function Word64_rotateRight(places) {
      var low, high;

      if (places & 32) {
        high = this.low;
        low = this.high;
      } else {
        low = this.low;
        high = this.high;
      }

      places &= 31;
      this.low = low >>> places | high << 32 - places;
      this.high = high >>> places | low << 32 - places;
    },
    not: function Word64_not() {
      this.high = ~this.high;
      this.low = ~this.low;
    },
    add: function Word64_add(word) {
      var lowAdd = (this.low >>> 0) + (word.low >>> 0);
      var highAdd = (this.high >>> 0) + (word.high >>> 0);

      if (lowAdd > 0xffffffff) {
        highAdd += 1;
      }

      this.low = lowAdd | 0;
      this.high = highAdd | 0;
    },
    copyTo: function Word64_copyTo(bytes, offset) {
      bytes[offset] = this.high >>> 24 & 0xff;
      bytes[offset + 1] = this.high >> 16 & 0xff;
      bytes[offset + 2] = this.high >> 8 & 0xff;
      bytes[offset + 3] = this.high & 0xff;
      bytes[offset + 4] = this.low >>> 24 & 0xff;
      bytes[offset + 5] = this.low >> 16 & 0xff;
      bytes[offset + 6] = this.low >> 8 & 0xff;
      bytes[offset + 7] = this.low & 0xff;
    },
    assign: function Word64_assign(word) {
      this.high = word.high;
      this.low = word.low;
    }
  };
  return Word64;
}();

var calculateSHA256 = function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }

  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }

  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }

  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }

  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }

  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }

  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }

  var k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

  function hash(data, offset, length) {
    var h0 = 0x6a09e667,
        h1 = 0xbb67ae85,
        h2 = 0x3c6ef372,
        h3 = 0xa54ff53a,
        h4 = 0x510e527f,
        h5 = 0x9b05688c,
        h6 = 0x1f83d9ab,
        h7 = 0x5be0cd19;
    var paddedLength = Math.ceil((length + 9) / 64) * 64;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    n = paddedLength - 8;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    var w = new Uint32Array(64);

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }

      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }

      var a = h0,
          b = h1,
          c = h2,
          d = h3,
          e = h4,
          f = h5,
          g = h6,
          h = h7,
          t1,
          t2;

      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }

      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }

    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
  }

  return hash;
}();

exports.calculateSHA256 = calculateSHA256;

var calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }

  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }

  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }

  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }

  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }

  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }

  var k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];

  function hash(data, offset, length, mode384) {
    mode384 = !!mode384;
    var h0, h1, h2, h3, h4, h5, h6, h7;

    if (!mode384) {
      h0 = new Word64(0x6a09e667, 0xf3bcc908);
      h1 = new Word64(0xbb67ae85, 0x84caa73b);
      h2 = new Word64(0x3c6ef372, 0xfe94f82b);
      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
      h4 = new Word64(0x510e527f, 0xade682d1);
      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
      h7 = new Word64(0x5be0cd19, 0x137e2179);
    } else {
      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
      h1 = new Word64(0x629a292a, 0x367cd507);
      h2 = new Word64(0x9159015a, 0x3070dd17);
      h3 = new Word64(0x152fecd8, 0xf70e5939);
      h4 = new Word64(0x67332667, 0xffc00b31);
      h5 = new Word64(0x8eb44a87, 0x68581511);
      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
      h7 = new Word64(0x47b5481d, 0xbefa4fa4);
    }

    var paddedLength = Math.ceil((length + 17) / 128) * 128;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    n = paddedLength - 16;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    var w = new Array(80);

    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }

    var a = new Word64(0, 0),
        b = new Word64(0, 0),
        c = new Word64(0, 0);
    var d = new Word64(0, 0),
        e = new Word64(0, 0),
        f = new Word64(0, 0);
    var g = new Word64(0, 0),
        h = new Word64(0, 0);
    var t1 = new Word64(0, 0),
        t2 = new Word64(0, 0);
    var tmp1 = new Word64(0, 0),
        tmp2 = new Word64(0, 0),
        tmp3;

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }

      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }

      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);

      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }

      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }

    var result;

    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }

    return result;
  }

  return hash;
}();

exports.calculateSHA512 = calculateSHA512;

var calculateSHA384 = function calculateSHA384Closure() {
  function hash(data, offset, length) {
    return calculateSHA512(data, offset, length, true);
  }

  return hash;
}();

exports.calculateSHA384 = calculateSHA384;

var NullCipher = function NullCipherClosure() {
  function NullCipher() {}

  NullCipher.prototype = {
    decryptBlock: function NullCipher_decryptBlock(data) {
      return data;
    },
    encrypt: function NullCipher_encrypt(data) {
      return data;
    }
  };
  return NullCipher;
}();

var AESBaseCipher = /*#__PURE__*/function () {
  function AESBaseCipher() {
    _classCallCheck(this, AESBaseCipher);

    if (this.constructor === AESBaseCipher) {
      (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
    }

    this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
    this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
    this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
    this._mixCol = new Uint8Array(256);

    for (var i = 0; i < 256; i++) {
      if (i < 128) {
        this._mixCol[i] = i << 1;
      } else {
        this._mixCol[i] = i << 1 ^ 0x1b;
      }
    }

    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }

  _createClass(AESBaseCipher, [{
    key: "_expandKey",
    value: function _expandKey(cipherKey) {
      (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
    }
  }, {
    key: "_decrypt",
    value: function _decrypt(input, key) {
      var t, u, v;
      var state = new Uint8Array(16);
      state.set(input);

      for (var j = 0, k = this._keySize; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }

      for (var i = this._cyclesOfRepetition - 1; i >= 1; --i) {
        t = state[13];
        state[13] = state[9];
        state[9] = state[5];
        state[5] = state[1];
        state[1] = t;
        t = state[14];
        u = state[10];
        state[14] = state[6];
        state[10] = state[2];
        state[6] = t;
        state[2] = u;
        t = state[15];
        u = state[11];
        v = state[7];
        state[15] = state[3];
        state[11] = t;
        state[7] = u;
        state[3] = v;

        for (var _j = 0; _j < 16; ++_j) {
          state[_j] = this._inv_s[state[_j]];
        }

        for (var _j2 = 0, _k = i * 16; _j2 < 16; ++_j2, ++_k) {
          state[_j2] ^= key[_k];
        }

        for (var _j3 = 0; _j3 < 16; _j3 += 4) {
          var s0 = this._mix[state[_j3]];
          var s1 = this._mix[state[_j3 + 1]];
          var s2 = this._mix[state[_j3 + 2]];
          var s3 = this._mix[state[_j3 + 3]];
          t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
          state[_j3] = t >>> 24 & 0xff;
          state[_j3 + 1] = t >> 16 & 0xff;
          state[_j3 + 2] = t >> 8 & 0xff;
          state[_j3 + 3] = t & 0xff;
        }
      }

      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;

      for (var _j4 = 0; _j4 < 16; ++_j4) {
        state[_j4] = this._inv_s[state[_j4]];
        state[_j4] ^= key[_j4];
      }

      return state;
    }
  }, {
    key: "_encrypt",
    value: function _encrypt(input, key) {
      var s = this._s;
      var t, u, v;
      var state = new Uint8Array(16);
      state.set(input);

      for (var j = 0; j < 16; ++j) {
        state[j] ^= key[j];
      }

      for (var i = 1; i < this._cyclesOfRepetition; i++) {
        for (var _j5 = 0; _j5 < 16; ++_j5) {
          state[_j5] = s[state[_j5]];
        }

        v = state[1];
        state[1] = state[5];
        state[5] = state[9];
        state[9] = state[13];
        state[13] = v;
        v = state[2];
        u = state[6];
        state[2] = state[10];
        state[6] = state[14];
        state[10] = v;
        state[14] = u;
        v = state[3];
        u = state[7];
        t = state[11];
        state[3] = state[15];
        state[7] = v;
        state[11] = u;
        state[15] = t;

        for (var _j6 = 0; _j6 < 16; _j6 += 4) {
          var s0 = state[_j6 + 0];
          var s1 = state[_j6 + 1];
          var s2 = state[_j6 + 2];
          var s3 = state[_j6 + 3];
          t = s0 ^ s1 ^ s2 ^ s3;
          state[_j6 + 0] ^= t ^ this._mixCol[s0 ^ s1];
          state[_j6 + 1] ^= t ^ this._mixCol[s1 ^ s2];
          state[_j6 + 2] ^= t ^ this._mixCol[s2 ^ s3];
          state[_j6 + 3] ^= t ^ this._mixCol[s3 ^ s0];
        }

        for (var _j7 = 0, k = i * 16; _j7 < 16; ++_j7, ++k) {
          state[_j7] ^= key[k];
        }
      }

      for (var _j8 = 0; _j8 < 16; ++_j8) {
        state[_j8] = s[state[_j8]];
      }

      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;

      for (var _j9 = 0, _k2 = this._keySize; _j9 < 16; ++_j9, ++_k2) {
        state[_j9] ^= key[_k2];
      }

      return state;
    }
  }, {
    key: "_decryptBlock2",
    value: function _decryptBlock2(data, finalize) {
      var sourceLength = data.length;
      var buffer = this.buffer,
          bufferLength = this.bufferPosition;
      var result = [];
      var iv = this.iv;

      for (var i = 0; i < sourceLength; ++i) {
        buffer[bufferLength] = data[i];
        ++bufferLength;

        if (bufferLength < 16) {
          continue;
        }

        var plain = this._decrypt(buffer, this._key);

        for (var j = 0; j < 16; ++j) {
          plain[j] ^= iv[j];
        }

        iv = buffer;
        result.push(plain);
        buffer = new Uint8Array(16);
        bufferLength = 0;
      }

      this.buffer = buffer;
      this.bufferLength = bufferLength;
      this.iv = iv;

      if (result.length === 0) {
        return new Uint8Array(0);
      }

      var outputLength = 16 * result.length;

      if (finalize) {
        var lastBlock = result[result.length - 1];
        var psLen = lastBlock[15];

        if (psLen <= 16) {
          for (var _i = 15, ii = 16 - psLen; _i >= ii; --_i) {
            if (lastBlock[_i] !== psLen) {
              psLen = 0;
              break;
            }
          }

          outputLength -= psLen;
          result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
        }
      }

      var output = new Uint8Array(outputLength);

      for (var _i2 = 0, _j10 = 0, _ii = result.length; _i2 < _ii; ++_i2, _j10 += 16) {
        output.set(result[_i2], _j10);
      }

      return output;
    }
  }, {
    key: "decryptBlock",
    value: function decryptBlock(data, finalize) {
      var iv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var sourceLength = data.length;
      var buffer = this.buffer;
      var bufferLength = this.bufferPosition;

      if (iv) {
        this.iv = iv;
      } else {
        for (var i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
          buffer[bufferLength] = data[i];
        }

        if (bufferLength < 16) {
          this.bufferLength = bufferLength;
          return new Uint8Array(0);
        }

        this.iv = buffer;
        data = data.subarray(16);
      }

      this.buffer = new Uint8Array(16);
      this.bufferLength = 0;
      this.decryptBlock = this._decryptBlock2;
      return this.decryptBlock(data, finalize);
    }
  }, {
    key: "encrypt",
    value: function encrypt(data, iv) {
      var sourceLength = data.length;
      var buffer = this.buffer,
          bufferLength = this.bufferPosition;
      var result = [];

      if (!iv) {
        iv = new Uint8Array(16);
      }

      for (var i = 0; i < sourceLength; ++i) {
        buffer[bufferLength] = data[i];
        ++bufferLength;

        if (bufferLength < 16) {
          continue;
        }

        for (var j = 0; j < 16; ++j) {
          buffer[j] ^= iv[j];
        }

        var cipher = this._encrypt(buffer, this._key);

        iv = cipher;
        result.push(cipher);
        buffer = new Uint8Array(16);
        bufferLength = 0;
      }

      this.buffer = buffer;
      this.bufferLength = bufferLength;
      this.iv = iv;

      if (result.length === 0) {
        return new Uint8Array(0);
      }

      var outputLength = 16 * result.length;
      var output = new Uint8Array(outputLength);

      for (var _i3 = 0, _j11 = 0, ii = result.length; _i3 < ii; ++_i3, _j11 += 16) {
        output.set(result[_i3], _j11);
      }

      return output;
    }
  }]);

  return AESBaseCipher;
}();

var AES128Cipher = /*#__PURE__*/function (_AESBaseCipher) {
  _inherits(AES128Cipher, _AESBaseCipher);

  var _super = _createSuper(AES128Cipher);

  function AES128Cipher(key) {
    var _this;

    _classCallCheck(this, AES128Cipher);

    _this = _super.call(this);
    _this._cyclesOfRepetition = 10;
    _this._keySize = 160;
    _this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
    _this._key = _this._expandKey(key);
    return _this;
  }

  _createClass(AES128Cipher, [{
    key: "_expandKey",
    value: function _expandKey(cipherKey) {
      var b = 176;
      var s = this._s;
      var rcon = this._rcon;
      var result = new Uint8Array(b);
      result.set(cipherKey);

      for (var j = 16, i = 1; j < b; ++i) {
        var t1 = result[j - 3];
        var t2 = result[j - 2];
        var t3 = result[j - 1];
        var t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 = t1 ^ rcon[i];

        for (var n = 0; n < 4; ++n) {
          result[j] = t1 ^= result[j - 16];
          j++;
          result[j] = t2 ^= result[j - 16];
          j++;
          result[j] = t3 ^= result[j - 16];
          j++;
          result[j] = t4 ^= result[j - 16];
          j++;
        }
      }

      return result;
    }
  }]);

  return AES128Cipher;
}(AESBaseCipher);

exports.AES128Cipher = AES128Cipher;

var AES256Cipher = /*#__PURE__*/function (_AESBaseCipher2) {
  _inherits(AES256Cipher, _AESBaseCipher2);

  var _super2 = _createSuper(AES256Cipher);

  function AES256Cipher(key) {
    var _this2;

    _classCallCheck(this, AES256Cipher);

    _this2 = _super2.call(this);
    _this2._cyclesOfRepetition = 14;
    _this2._keySize = 224;
    _this2._key = _this2._expandKey(key);
    return _this2;
  }

  _createClass(AES256Cipher, [{
    key: "_expandKey",
    value: function _expandKey(cipherKey) {
      var b = 240;
      var s = this._s;
      var result = new Uint8Array(b);
      result.set(cipherKey);
      var r = 1;
      var t1, t2, t3, t4;

      for (var j = 32, i = 1; j < b; ++i) {
        if (j % 32 === 16) {
          t1 = s[t1];
          t2 = s[t2];
          t3 = s[t3];
          t4 = s[t4];
        } else if (j % 32 === 0) {
          t1 = result[j - 3];
          t2 = result[j - 2];
          t3 = result[j - 1];
          t4 = result[j - 4];
          t1 = s[t1];
          t2 = s[t2];
          t3 = s[t3];
          t4 = s[t4];
          t1 = t1 ^ r;

          if ((r <<= 1) >= 256) {
            r = (r ^ 0x1b) & 0xff;
          }
        }

        for (var n = 0; n < 4; ++n) {
          result[j] = t1 ^= result[j - 32];
          j++;
          result[j] = t2 ^= result[j - 32];
          j++;
          result[j] = t3 ^= result[j - 32];
          j++;
          result[j] = t4 ^= result[j - 32];
          j++;
        }
      }

      return result;
    }
  }]);

  return AES256Cipher;
}(AESBaseCipher);

exports.AES256Cipher = AES256Cipher;

var PDF17 = function PDF17Closure() {
  function compareByteArrays(array1, array2) {
    if (array1.length !== array2.length) {
      return false;
    }

    for (var i = 0; i < array1.length; i++) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }

    return true;
  }

  function PDF17() {}

  PDF17.prototype = {
    checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      var result = calculateSHA256(hashData, 0, hashData.length);
      return compareByteArrays(result, ownerPassword);
    },
    checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      var result = calculateSHA256(hashData, 0, hashData.length);
      return compareByteArrays(result, userPassword);
    },
    getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      var key = calculateSHA256(hashData, 0, hashData.length);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    },
    getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      var key = calculateSHA256(hashData, 0, hashData.length);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }
  };
  return PDF17;
}();

exports.PDF17 = PDF17;

var PDF20 = function PDF20Closure() {
  function concatArrays(array1, array2) {
    var t = new Uint8Array(array1.length + array2.length);
    t.set(array1, 0);
    t.set(array2, array1.length);
    return t;
  }

  function calculatePDF20Hash(password, input, userBytes) {
    var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    var e = [0];
    var i = 0;

    while (i < 64 || e[e.length - 1] > i - 32) {
      var arrayLength = password.length + k.length + userBytes.length;
      var k1 = new Uint8Array(arrayLength * 64);
      var array = concatArrays(password, k);
      array = concatArrays(array, userBytes);

      for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
        k1.set(array, pos);
      }

      var cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      var remainder = 0;

      for (var z = 0; z < 16; z++) {
        remainder *= 256 % 3;
        remainder %= 3;
        remainder += (e[z] >>> 0) % 3;
        remainder %= 3;
      }

      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }

      i++;
    }

    return k.subarray(0, 32);
  }

  function PDF20() {}

  function compareByteArrays(array1, array2) {
    if (array1.length !== array2.length) {
      return false;
    }

    for (var i = 0; i < array1.length; i++) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }

    return true;
  }

  PDF20.prototype = {
    hash: function PDF20_hash(password, concatBytes, userBytes) {
      return calculatePDF20Hash(password, concatBytes, userBytes);
    },
    checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      var result = calculatePDF20Hash(password, hashData, userBytes);
      return compareByteArrays(result, ownerPassword);
    },
    checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      var result = calculatePDF20Hash(password, hashData, []);
      return compareByteArrays(result, userPassword);
    },
    getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      var key = calculatePDF20Hash(password, hashData, userBytes);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    },
    getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      var key = calculatePDF20Hash(password, hashData, []);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }
  };
  return PDF20;
}();

exports.PDF20 = PDF20;

var CipherTransform = function CipherTransformClosure() {
  function CipherTransform(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }

  CipherTransform.prototype = {
    createStream: function CipherTransform_createStream(stream, length) {
      var cipher = new this.StreamCipherConstructor();
      return new _stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
        return cipher.decryptBlock(data, finalize);
      });
    },
    decryptString: function CipherTransform_decryptString(s) {
      var cipher = new this.StringCipherConstructor();
      var data = (0, _util.stringToBytes)(s);
      data = cipher.decryptBlock(data, true);
      return (0, _util.bytesToString)(data);
    },
    encryptString: function CipherTransform_encryptString(s) {
      var cipher = new this.StringCipherConstructor();

      if (cipher instanceof AESBaseCipher) {
        var strLen = s.length;
        var pad = 16 - strLen % 16;

        if (pad !== 16) {
          s = s.padEnd(16 * Math.ceil(strLen / 16), String.fromCharCode(pad));
        }

        var iv = new Uint8Array(16);

        if (typeof crypto !== "undefined") {
          crypto.getRandomValues(iv);
        } else {
          for (var i = 0; i < 16; i++) {
            iv[i] = Math.floor(256 * Math.random());
          }
        }

        var _data = (0, _util.stringToBytes)(s);

        _data = cipher.encrypt(_data, iv);
        var buf = new Uint8Array(16 + _data.length);
        buf.set(iv);
        buf.set(_data, 16);
        return (0, _util.bytesToString)(buf);
      }

      var data = (0, _util.stringToBytes)(s);
      data = cipher.encrypt(data);
      return (0, _util.bytesToString)(data);
    }
  };
  return CipherTransform;
}();

var CipherTransformFactory = function CipherTransformFactoryClosure() {
  var defaultPasswordBytes = new Uint8Array([0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08, 0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A]);

  function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      var passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }

    var pdfAlgorithm;

    if (revision === 6) {
      pdfAlgorithm = new PDF20();
    } else {
      pdfAlgorithm = new PDF17();
    }

    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }

    return null;
  }

  function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    var hashDataSize = 40 + ownerPassword.length + fileId.length;
    var hashData = new Uint8Array(hashDataSize),
        i = 0,
        j,
        n;

    if (password) {
      n = Math.min(32, password.length);

      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }

    j = 0;

    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }

    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }

    hashData[i++] = flags & 0xff;
    hashData[i++] = flags >> 8 & 0xff;
    hashData[i++] = flags >> 16 & 0xff;
    hashData[i++] = flags >>> 24 & 0xff;

    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }

    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
    }

    var hash = calculateMD5(hashData, 0, i);
    var keyLengthInBytes = keyLength >> 3;

    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }

    var encryptionKey = hash.subarray(0, keyLengthInBytes);
    var cipher, checkData;

    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = defaultPasswordBytes[i];
      }

      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }

      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      var derivedKey = new Uint8Array(n),
          k;

      for (j = 1; j <= 19; ++j) {
        for (k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }

        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }

      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(defaultPasswordBytes);

      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }

    return encryptionKey;
  }

  function decodeUserPassword(password, ownerPassword, revision, keyLength) {
    var hashData = new Uint8Array(32),
        i = 0,
        j,
        n;
    n = Math.min(32, password.length);

    for (; i < n; ++i) {
      hashData[i] = password[i];
    }

    j = 0;

    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }

    var hash = calculateMD5(hashData, 0, i);
    var keyLengthInBytes = keyLength >> 3;

    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }

    var cipher, userPassword;

    if (revision >= 3) {
      userPassword = ownerPassword;
      var derivedKey = new Uint8Array(keyLengthInBytes),
          k;

      for (j = 19; j >= 0; j--) {
        for (k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }

        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }

    return userPassword;
  }

  var identityName = _primitives.Name.get("Identity");

  function CipherTransformFactory(dict, fileId, password) {
    var filter = dict.get("Filter");

    if (!(0, _primitives.isName)(filter, "Standard")) {
      throw new _util.FormatError("unknown encryption method");
    }

    this.dict = dict;
    var algorithm = dict.get("V");

    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
      throw new _util.FormatError("unsupported encryption algorithm");
    }

    this.algorithm = algorithm;
    var keyLength = dict.get("Length");

    if (!keyLength) {
      if (algorithm <= 3) {
        keyLength = 40;
      } else {
        var cfDict = dict.get("CF");
        var streamCryptoName = dict.get("StmF");

        if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
          cfDict.suppressEncryption = true;
          var handlerDict = cfDict.get(streamCryptoName.name);
          keyLength = handlerDict && handlerDict.get("Length") || 128;

          if (keyLength < 40) {
            keyLength <<= 3;
          }
        }
      }
    }

    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
      throw new _util.FormatError("invalid key length");
    }

    var ownerPassword = (0, _util.stringToBytes)(dict.get("O")).subarray(0, 32);
    var userPassword = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 32);
    var flags = dict.get("P");
    var revision = dict.get("R");
    var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
    this.encryptMetadata = encryptMetadata;
    var fileIdBytes = (0, _util.stringToBytes)(fileId);
    var passwordBytes;

    if (password) {
      if (revision === 6) {
        try {
          password = (0, _util.utf8StringToString)(password);
        } catch (ex) {
          (0, _util.warn)("CipherTransformFactory: " + "Unable to convert UTF8 encoded password.");
        }
      }

      passwordBytes = (0, _util.stringToBytes)(password);
    }

    var encryptionKey;

    if (algorithm !== 5) {
      encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    } else {
      var ownerValidationSalt = (0, _util.stringToBytes)(dict.get("O")).subarray(32, 40);
      var ownerKeySalt = (0, _util.stringToBytes)(dict.get("O")).subarray(40, 48);
      var uBytes = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 48);
      var userValidationSalt = (0, _util.stringToBytes)(dict.get("U")).subarray(32, 40);
      var userKeySalt = (0, _util.stringToBytes)(dict.get("U")).subarray(40, 48);
      var ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
      var userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
      var perms = (0, _util.stringToBytes)(dict.get("Perms"));
      encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
    }

    if (!encryptionKey && !password) {
      throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
    } else if (!encryptionKey && password) {
      var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
      encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    }

    if (!encryptionKey) {
      throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
    }

    this.encryptionKey = encryptionKey;

    if (algorithm >= 4) {
      var cf = dict.get("CF");

      if ((0, _primitives.isDict)(cf)) {
        cf.suppressEncryption = true;
      }

      this.cf = cf;
      this.stmf = dict.get("StmF") || identityName;
      this.strf = dict.get("StrF") || identityName;
      this.eff = dict.get("EFF") || this.stmf;
    }
  }

  function buildObjectKey(num, gen, encryptionKey, isAes) {
    var key = new Uint8Array(encryptionKey.length + 9),
        i,
        n;

    for (i = 0, n = encryptionKey.length; i < n; ++i) {
      key[i] = encryptionKey[i];
    }

    key[i++] = num & 0xff;
    key[i++] = num >> 8 & 0xff;
    key[i++] = num >> 16 & 0xff;
    key[i++] = gen & 0xff;
    key[i++] = gen >> 8 & 0xff;

    if (isAes) {
      key[i++] = 0x73;
      key[i++] = 0x41;
      key[i++] = 0x6c;
      key[i++] = 0x54;
    }

    var hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }

  function buildCipherConstructor(cf, name, num, gen, key) {
    if (!(0, _primitives.isName)(name)) {
      throw new _util.FormatError("Invalid crypt filter name.");
    }

    var cryptFilter = cf.get(name.name);
    var cfm;

    if (cryptFilter !== null && cryptFilter !== undefined) {
      cfm = cryptFilter.get("CFM");
    }

    if (!cfm || cfm.name === "None") {
      return function cipherTransformFactoryBuildCipherConstructorNone() {
        return new NullCipher();
      };
    }

    if (cfm.name === "V2") {
      return function cipherTransformFactoryBuildCipherConstructorV2() {
        return new ARCFourCipher(buildObjectKey(num, gen, key, false));
      };
    }

    if (cfm.name === "AESV2") {
      return function cipherTransformFactoryBuildCipherConstructorAESV2() {
        return new AES128Cipher(buildObjectKey(num, gen, key, true));
      };
    }

    if (cfm.name === "AESV3") {
      return function cipherTransformFactoryBuildCipherConstructorAESV3() {
        return new AES256Cipher(key);
      };
    }

    throw new _util.FormatError("Unknown crypto method");
  }

  CipherTransformFactory.prototype = {
    createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
      if (this.algorithm === 4 || this.algorithm === 5) {
        return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
      }

      var key = buildObjectKey(num, gen, this.encryptionKey, false);

      var cipherConstructor = function buildCipherCipherConstructor() {
        return new ARCFourCipher(key);
      };

      return new CipherTransform(cipherConstructor, cipherConstructor);
    }
  };
  return CipherTransformFactory;
}();

exports.CipherTransformFactory = CipherTransformFactory;

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorSpace = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
  var COMPONENTS = 3;
  alpha01 = alpha01 !== 1 ? 0 : alpha01;
  var xRatio = w1 / w2;
  var yRatio = h1 / h2;
  var newIndex = 0,
      oldIndex;
  var xScaled = new Uint16Array(w2);
  var w1Scanline = w1 * COMPONENTS;

  for (var i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
  }

  for (var _i = 0; _i < h2; _i++) {
    var py = Math.floor(_i * yRatio) * w1Scanline;

    for (var j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      newIndex += alpha01;
    }
  }
}

var ColorSpace = /*#__PURE__*/function () {
  function ColorSpace(name, numComps) {
    _classCallCheck(this, ColorSpace);

    if (this.constructor === ColorSpace) {
      (0, _util.unreachable)("Cannot initialize ColorSpace.");
    }

    this.name = name;
    this.numComps = numComps;
  }

  _createClass(ColorSpace, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var rgb = new Uint8ClampedArray(3);
      this.getRgbItem(src, srcOffset, rgb, 0);
      return rgb;
    }
  }, {
    key: "getRgbItem",
    value: function getRgbItem(src, srcOffset, dest, destOffset) {
      (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha01) {
      (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
    }
  }, {
    key: "isPassthrough",
    value: function isPassthrough(bits) {
      return false;
    }
  }, {
    key: "isDefaultDecode",
    value: function isDefaultDecode(decodeMap, bpc) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    }
  }, {
    key: "fillRgb",
    value: function fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
      var count = originalWidth * originalHeight;
      var rgbBuf = null;
      var numComponentColors = 1 << bpc;
      var needsResizing = originalHeight !== height || originalWidth !== width;

      if (this.isPassthrough(bpc)) {
        rgbBuf = comps;
      } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
        var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);

        for (var i = 0; i < numComponentColors; i++) {
          allColors[i] = i;
        }

        var colorMap = new Uint8ClampedArray(numComponentColors * 3);
        this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);

        if (!needsResizing) {
          var destPos = 0;

          for (var _i2 = 0; _i2 < count; ++_i2) {
            var key = comps[_i2] * 3;
            dest[destPos++] = colorMap[key];
            dest[destPos++] = colorMap[key + 1];
            dest[destPos++] = colorMap[key + 2];
            destPos += alpha01;
          }
        } else {
          rgbBuf = new Uint8Array(count * 3);
          var rgbPos = 0;

          for (var _i3 = 0; _i3 < count; ++_i3) {
            var _key = comps[_i3] * 3;

            rgbBuf[rgbPos++] = colorMap[_key];
            rgbBuf[rgbPos++] = colorMap[_key + 1];
            rgbBuf[rgbPos++] = colorMap[_key + 2];
          }
        }
      } else {
        if (!needsResizing) {
          this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
        } else {
          rgbBuf = new Uint8ClampedArray(count * 3);
          this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
        }
      }

      if (rgbBuf) {
        if (needsResizing) {
          resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
        } else {
          var _destPos = 0,
              _rgbPos = 0;

          for (var _i4 = 0, ii = width * actualHeight; _i4 < ii; _i4++) {
            dest[_destPos++] = rgbBuf[_rgbPos++];
            dest[_destPos++] = rgbBuf[_rgbPos++];
            dest[_destPos++] = rgbBuf[_rgbPos++];
            _destPos += alpha01;
          }
        }
      }
    }
  }, {
    key: "usesZeroToOneRange",
    get: function get() {
      return (0, _util.shadow)(this, "usesZeroToOneRange", true);
    }
  }], [{
    key: "_cache",
    value: function _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
      if (!localColorSpaceCache) {
        throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
      }

      if (!parsedColorSpace) {
        throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
      }

      var csName, csRef;

      if (cacheKey instanceof _primitives.Ref) {
        csRef = cacheKey;
        cacheKey = xref.fetch(cacheKey);
      }

      if (cacheKey instanceof _primitives.Name) {
        csName = cacheKey.name;
      }

      if (csName || csRef) {
        localColorSpaceCache.set(csName, csRef, parsedColorSpace);
      }
    }
  }, {
    key: "getCached",
    value: function getCached(cacheKey, xref, localColorSpaceCache) {
      if (!localColorSpaceCache) {
        throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
      }

      if (cacheKey instanceof _primitives.Ref) {
        var localColorSpace = localColorSpaceCache.getByRef(cacheKey);

        if (localColorSpace) {
          return localColorSpace;
        }

        try {
          cacheKey = xref.fetch(cacheKey);
        } catch (ex) {
          if (ex instanceof _core_utils.MissingDataException) {
            throw ex;
          }
        }
      }

      if (cacheKey instanceof _primitives.Name) {
        var _localColorSpace = localColorSpaceCache.getByName(cacheKey.name);

        if (_localColorSpace) {
          return _localColorSpace;
        }
      }

      return null;
    }
  }, {
    key: "parseAsync",
    value: function () {
      var _parseAsync = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
        var cs, xref, _ref$resources, resources, pdfFunctionFactory, localColorSpaceCache, parsedColorSpace;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cs = _ref.cs, xref = _ref.xref, _ref$resources = _ref.resources, resources = _ref$resources === void 0 ? null : _ref$resources, pdfFunctionFactory = _ref.pdfFunctionFactory, localColorSpaceCache = _ref.localColorSpaceCache;
                parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);

                this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);

                return _context.abrupt("return", parsedColorSpace);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function parseAsync(_x) {
        return _parseAsync.apply(this, arguments);
      }

      return parseAsync;
    }()
  }, {
    key: "parse",
    value: function parse(_ref2) {
      var cs = _ref2.cs,
          xref = _ref2.xref,
          _ref2$resources = _ref2.resources,
          resources = _ref2$resources === void 0 ? null : _ref2$resources,
          pdfFunctionFactory = _ref2.pdfFunctionFactory,
          localColorSpaceCache = _ref2.localColorSpaceCache;
      var cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);

      if (cachedColorSpace) {
        return cachedColorSpace;
      }

      var parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);

      this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);

      return parsedColorSpace;
    }
  }, {
    key: "_parse",
    value: function _parse(cs, xref) {
      var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var pdfFunctionFactory = arguments.length > 3 ? arguments[3] : undefined;
      cs = xref.fetchIfRef(cs);

      if ((0, _primitives.isName)(cs)) {
        switch (cs.name) {
          case "DeviceGray":
          case "G":
            return this.singletons.gray;

          case "DeviceRGB":
          case "RGB":
            return this.singletons.rgb;

          case "DeviceCMYK":
          case "CMYK":
            return this.singletons.cmyk;

          case "Pattern":
            return new PatternCS(null);

          default:
            if ((0, _primitives.isDict)(resources)) {
              var colorSpaces = resources.get("ColorSpace");

              if ((0, _primitives.isDict)(colorSpaces)) {
                var resourcesCS = colorSpaces.get(cs.name);

                if (resourcesCS) {
                  if ((0, _primitives.isName)(resourcesCS)) {
                    return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                  }

                  cs = resourcesCS;
                  break;
                }
              }
            }

            throw new _util.FormatError("Unrecognized ColorSpace: ".concat(cs.name));
        }
      }

      if (Array.isArray(cs)) {
        var mode = xref.fetchIfRef(cs[0]).name;
        var params, numComps, baseCS, whitePoint, blackPoint, gamma;

        switch (mode) {
          case "DeviceGray":
          case "G":
            return this.singletons.gray;

          case "DeviceRGB":
          case "RGB":
            return this.singletons.rgb;

          case "DeviceCMYK":
          case "CMYK":
            return this.singletons.cmyk;

          case "CalGray":
            params = xref.fetchIfRef(cs[1]);
            whitePoint = params.getArray("WhitePoint");
            blackPoint = params.getArray("BlackPoint");
            gamma = params.get("Gamma");
            return new CalGrayCS(whitePoint, blackPoint, gamma);

          case "CalRGB":
            params = xref.fetchIfRef(cs[1]);
            whitePoint = params.getArray("WhitePoint");
            blackPoint = params.getArray("BlackPoint");
            gamma = params.getArray("Gamma");
            var matrix = params.getArray("Matrix");
            return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);

          case "ICCBased":
            var stream = xref.fetchIfRef(cs[1]);
            var dict = stream.dict;
            numComps = dict.get("N");
            var alt = dict.get("Alternate");

            if (alt) {
              var altCS = this._parse(alt, xref, resources, pdfFunctionFactory);

              if (altCS.numComps === numComps) {
                return altCS;
              }

              (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
            }

            if (numComps === 1) {
              return this.singletons.gray;
            } else if (numComps === 3) {
              return this.singletons.rgb;
            } else if (numComps === 4) {
              return this.singletons.cmyk;
            }

            break;

          case "Pattern":
            baseCS = cs[1] || null;

            if (baseCS) {
              baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
            }

            return new PatternCS(baseCS);

          case "Indexed":
          case "I":
            baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
            var hiVal = xref.fetchIfRef(cs[2]) + 1;
            var lookup = xref.fetchIfRef(cs[3]);
            return new IndexedCS(baseCS, hiVal, lookup);

          case "Separation":
          case "DeviceN":
            var name = xref.fetchIfRef(cs[1]);
            numComps = Array.isArray(name) ? name.length : 1;
            baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
            var tintFn = pdfFunctionFactory.create(cs[3]);
            return new AlternateCS(numComps, baseCS, tintFn);

          case "Lab":
            params = xref.fetchIfRef(cs[1]);
            whitePoint = params.getArray("WhitePoint");
            blackPoint = params.getArray("BlackPoint");
            var range = params.getArray("Range");
            return new LabCS(whitePoint, blackPoint, range);

          default:
            throw new _util.FormatError("Unimplemented ColorSpace object: ".concat(mode));
        }
      }

      throw new _util.FormatError("Unrecognized ColorSpace object: ".concat(cs));
    }
  }, {
    key: "isDefaultDecode",
    value: function isDefaultDecode(decode, numComps) {
      if (!Array.isArray(decode)) {
        return true;
      }

      if (numComps * 2 !== decode.length) {
        (0, _util.warn)("The decode map is not the correct length");
        return true;
      }

      for (var i = 0, ii = decode.length; i < ii; i += 2) {
        if (decode[i] !== 0 || decode[i + 1] !== 1) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "singletons",
    get: function get() {
      return (0, _util.shadow)(this, "singletons", {
        get gray() {
          return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
        },

        get rgb() {
          return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
        },

        get cmyk() {
          return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
        }

      });
    }
  }]);

  return ColorSpace;
}();

exports.ColorSpace = ColorSpace;

var AlternateCS = /*#__PURE__*/function (_ColorSpace) {
  _inherits(AlternateCS, _ColorSpace);

  var _super = _createSuper(AlternateCS);

  function AlternateCS(numComps, base, tintFn) {
    var _this;

    _classCallCheck(this, AlternateCS);

    _this = _super.call(this, "Alternate", numComps);
    _this.base = base;
    _this.tintFn = tintFn;
    _this.tmpBuf = new Float32Array(base.numComps);
    return _this;
  }

  _createClass(AlternateCS, [{
    key: "getRgbItem",
    value: function getRgbItem(src, srcOffset, dest, destOffset) {
      var tmpBuf = this.tmpBuf;
      this.tintFn(src, srcOffset, tmpBuf, 0);
      this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var tintFn = this.tintFn;
      var base = this.base;
      var scale = 1 / ((1 << bits) - 1);
      var baseNumComps = base.numComps;
      var usesZeroToOneRange = base.usesZeroToOneRange;
      var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
      var pos = isPassthrough ? destOffset : 0;
      var baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
      var numComps = this.numComps;
      var scaled = new Float32Array(numComps);
      var tinted = new Float32Array(baseNumComps);
      var i, j;

      for (i = 0; i < count; i++) {
        for (j = 0; j < numComps; j++) {
          scaled[j] = src[srcOffset++] * scale;
        }

        tintFn(scaled, 0, tinted, 0);

        if (usesZeroToOneRange) {
          for (j = 0; j < baseNumComps; j++) {
            baseBuf[pos++] = tinted[j] * 255;
          }
        } else {
          base.getRgbItem(tinted, 0, baseBuf, pos);
          pos += baseNumComps;
        }
      }

      if (!isPassthrough) {
        base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
      }
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
    }
  }]);

  return AlternateCS;
}(ColorSpace);

var PatternCS = /*#__PURE__*/function (_ColorSpace2) {
  _inherits(PatternCS, _ColorSpace2);

  var _super2 = _createSuper(PatternCS);

  function PatternCS(baseCS) {
    var _this2;

    _classCallCheck(this, PatternCS);

    _this2 = _super2.call(this, "Pattern", null);
    _this2.base = baseCS;
    return _this2;
  }

  _createClass(PatternCS, [{
    key: "isDefaultDecode",
    value: function isDefaultDecode(decodeMap, bpc) {
      (0, _util.unreachable)("Should not call PatternCS.isDefaultDecode");
    }
  }]);

  return PatternCS;
}(ColorSpace);

var IndexedCS = /*#__PURE__*/function (_ColorSpace3) {
  _inherits(IndexedCS, _ColorSpace3);

  var _super3 = _createSuper(IndexedCS);

  function IndexedCS(base, highVal, lookup) {
    var _this3;

    _classCallCheck(this, IndexedCS);

    _this3 = _super3.call(this, "Indexed", 1);
    _this3.base = base;
    _this3.highVal = highVal;
    var length = base.numComps * highVal;
    _this3.lookup = new Uint8Array(length);

    if ((0, _primitives.isStream)(lookup)) {
      var bytes = lookup.getBytes(length);

      _this3.lookup.set(bytes);
    } else if (typeof lookup === "string") {
      for (var i = 0; i < length; ++i) {
        _this3.lookup[i] = lookup.charCodeAt(i) & 0xff;
      }
    } else {
      throw new _util.FormatError("IndexedCS - unrecognized lookup table: ".concat(lookup));
    }

    return _this3;
  }

  _createClass(IndexedCS, [{
    key: "getRgbItem",
    value: function getRgbItem(src, srcOffset, dest, destOffset) {
      var numComps = this.base.numComps;
      var start = src[srcOffset] * numComps;
      this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var base = this.base;
      var numComps = base.numComps;
      var outputDelta = base.getOutputLength(numComps, alpha01);
      var lookup = this.lookup;

      for (var i = 0; i < count; ++i) {
        var lookupPos = src[srcOffset++] * numComps;
        base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
        destOffset += outputDelta;
      }
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
    }
  }, {
    key: "isDefaultDecode",
    value: function isDefaultDecode(decodeMap, bpc) {
      if (!Array.isArray(decodeMap)) {
        return true;
      }

      if (decodeMap.length !== 2) {
        (0, _util.warn)("Decode map length is not correct");
        return true;
      }

      if (!Number.isInteger(bpc) || bpc < 1) {
        (0, _util.warn)("Bits per component is not correct");
        return true;
      }

      return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
    }
  }]);

  return IndexedCS;
}(ColorSpace);

var DeviceGrayCS = /*#__PURE__*/function (_ColorSpace4) {
  _inherits(DeviceGrayCS, _ColorSpace4);

  var _super4 = _createSuper(DeviceGrayCS);

  function DeviceGrayCS() {
    _classCallCheck(this, DeviceGrayCS);

    return _super4.call(this, "DeviceGray", 1);
  }

  _createClass(DeviceGrayCS, [{
    key: "getRgbItem",
    value: function getRgbItem(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset] * 255;
      dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;

      for (var i = 0; i < count; ++i) {
        var c = scale * src[j++];
        dest[q++] = c;
        dest[q++] = c;
        dest[q++] = c;
        q += alpha01;
      }
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    }
  }]);

  return DeviceGrayCS;
}(ColorSpace);

var DeviceRgbCS = /*#__PURE__*/function (_ColorSpace5) {
  _inherits(DeviceRgbCS, _ColorSpace5);

  var _super5 = _createSuper(DeviceRgbCS);

  function DeviceRgbCS() {
    _classCallCheck(this, DeviceRgbCS);

    return _super5.call(this, "DeviceRGB", 3);
  }

  _createClass(DeviceRgbCS, [{
    key: "getRgbItem",
    value: function getRgbItem(src, srcOffset, dest, destOffset) {
      dest[destOffset] = src[srcOffset] * 255;
      dest[destOffset + 1] = src[srcOffset + 1] * 255;
      dest[destOffset + 2] = src[srcOffset + 2] * 255;
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (bits === 8 && alpha01 === 0) {
        dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
        return;
      }

      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;

      for (var i = 0; i < count; ++i) {
        dest[q++] = scale * src[j++];
        dest[q++] = scale * src[j++];
        dest[q++] = scale * src[j++];
        q += alpha01;
      }
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    }
  }, {
    key: "isPassthrough",
    value: function isPassthrough(bits) {
      return bits === 8;
    }
  }]);

  return DeviceRgbCS;
}(ColorSpace);

var DeviceCmykCS = function DeviceCmykCSClosure() {
  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
    var c = src[srcOffset] * srcScale;
    var m = src[srcOffset + 1] * srcScale;
    var y = src[srcOffset + 2] * srcScale;
    var k = src[srcOffset + 3] * srcScale;
    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
  }

  var DeviceCmykCS = /*#__PURE__*/function (_ColorSpace6) {
    _inherits(DeviceCmykCS, _ColorSpace6);

    var _super6 = _createSuper(DeviceCmykCS);

    function DeviceCmykCS() {
      _classCallCheck(this, DeviceCmykCS);

      return _super6.call(this, "DeviceCMYK", 4);
    }

    _createClass(DeviceCmykCS, [{
      key: "getRgbItem",
      value: function getRgbItem(src, srcOffset, dest, destOffset) {
        convertToRgb(src, srcOffset, 1, dest, destOffset);
      }
    }, {
      key: "getRgbBuffer",
      value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
        var scale = 1 / ((1 << bits) - 1);

        for (var i = 0; i < count; i++) {
          convertToRgb(src, srcOffset, scale, dest, destOffset);
          srcOffset += 4;
          destOffset += 3 + alpha01;
        }
      }
    }, {
      key: "getOutputLength",
      value: function getOutputLength(inputLength, alpha01) {
        return inputLength / 4 * (3 + alpha01) | 0;
      }
    }]);

    return DeviceCmykCS;
  }(ColorSpace);

  return DeviceCmykCS;
}();

var CalGrayCS = function CalGrayCSClosure() {
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = src[srcOffset] * scale;
    var AG = Math.pow(A, cs.G);
    var L = cs.YW * AG;
    var val = Math.max(295.8 * Math.pow(L, 0.333333333333333333) - 40.8, 0);
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }

  var CalGrayCS = /*#__PURE__*/function (_ColorSpace7) {
    _inherits(CalGrayCS, _ColorSpace7);

    var _super7 = _createSuper(CalGrayCS);

    function CalGrayCS(whitePoint, blackPoint, gamma) {
      var _this4;

      _classCallCheck(this, CalGrayCS);

      _this4 = _super7.call(this, "CalGray", 1);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
      }

      blackPoint = blackPoint || [0, 0, 0];
      gamma = gamma || 1;
      _this4.XW = whitePoint[0];
      _this4.YW = whitePoint[1];
      _this4.ZW = whitePoint[2];
      _this4.XB = blackPoint[0];
      _this4.YB = blackPoint[1];
      _this4.ZB = blackPoint[2];
      _this4.G = gamma;

      if (_this4.XW < 0 || _this4.ZW < 0 || _this4.YW !== 1) {
        throw new _util.FormatError("Invalid WhitePoint components for ".concat(_this4.name) + ", no fallback available");
      }

      if (_this4.XB < 0 || _this4.YB < 0 || _this4.ZB < 0) {
        (0, _util.info)("Invalid BlackPoint for ".concat(_this4.name, ", falling back to default."));
        _this4.XB = _this4.YB = _this4.ZB = 0;
      }

      if (_this4.XB !== 0 || _this4.YB !== 0 || _this4.ZB !== 0) {
        (0, _util.warn)("".concat(_this4.name, ", BlackPoint: XB: ").concat(_this4.XB, ", YB: ").concat(_this4.YB, ", ") + "ZB: ".concat(_this4.ZB, ", only default values are supported."));
      }

      if (_this4.G < 1) {
        (0, _util.info)("Invalid Gamma: ".concat(_this4.G, " for ").concat(_this4.name, ", ") + "falling back to default.");
        _this4.G = 1;
      }

      return _this4;
    }

    _createClass(CalGrayCS, [{
      key: "getRgbItem",
      value: function getRgbItem(src, srcOffset, dest, destOffset) {
        convertToRgb(this, src, srcOffset, dest, destOffset, 1);
      }
    }, {
      key: "getRgbBuffer",
      value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
        var scale = 1 / ((1 << bits) - 1);

        for (var i = 0; i < count; ++i) {
          convertToRgb(this, src, srcOffset, dest, destOffset, scale);
          srcOffset += 1;
          destOffset += 3 + alpha01;
        }
      }
    }, {
      key: "getOutputLength",
      value: function getOutputLength(inputLength, alpha01) {
        return inputLength * (3 + alpha01);
      }
    }]);

    return CalGrayCS;
  }(ColorSpace);

  return CalGrayCS;
}();

var CalRGBCS = function CalRGBCSClosure() {
  var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  var tempNormalizeMatrix = new Float32Array(3);
  var tempConvertMatrix1 = new Float32Array(3);
  var tempConvertMatrix2 = new Float32Array(3);
  var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8.0;

  function matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }

  function convertToFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }

  function convertToD65(sourceWhitePoint, LMS, result) {
    var D65X = 0.95047;
    var D65Y = 1;
    var D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }

  function sRGBTransferFunction(color) {
    if (color <= 0.0031308) {
      return adjustToRange(0, 1, 12.92 * color);
    }

    if (color >= 0.99554525) {
      return 1;
    }

    return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
  }

  function adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }

  function decodeL(L) {
    if (L < 0) {
      return -decodeL(-L);
    }

    if (L > 8.0) {
      return Math.pow((L + 16) / 116, 3);
    }

    return L * DECODE_L_CONSTANT;
  }

  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }

    var zeroDecodeL = decodeL(0);
    var X_DST = zeroDecodeL;
    var X_SRC = decodeL(sourceBlackPoint[0]);
    var Y_DST = zeroDecodeL;
    var Y_SRC = decodeL(sourceBlackPoint[1]);
    var Z_DST = zeroDecodeL;
    var Z_SRC = decodeL(sourceBlackPoint[2]);
    var X_Scale = (1 - X_DST) / (1 - X_SRC);
    var X_Offset = 1 - X_Scale;
    var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    var Y_Offset = 1 - Y_Scale;
    var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    var Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }

  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }

    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_Flat = tempNormalizeMatrix;
    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }

  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_D65 = tempNormalizeMatrix;
    convertToD65(sourceWhitePoint, LMS, LMS_D65);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }

  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = adjustToRange(0, 1, src[srcOffset] * scale);
    var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
    var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
    var AGR = A === 1 ? 1 : Math.pow(A, cs.GR);
    var BGG = B === 1 ? 1 : Math.pow(B, cs.GG);
    var CGB = C === 1 ? 1 : Math.pow(C, cs.GB);
    var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
    var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
    var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
    var XYZ = tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    var XYZ_Flat = tempConvertMatrix2;
    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
    var XYZ_Black = tempConvertMatrix1;
    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
    var XYZ_D65 = tempConvertMatrix2;
    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    var SRGB = tempConvertMatrix1;
    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
    dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
    dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
  }

  var CalRGBCS = /*#__PURE__*/function (_ColorSpace8) {
    _inherits(CalRGBCS, _ColorSpace8);

    var _super8 = _createSuper(CalRGBCS);

    function CalRGBCS(whitePoint, blackPoint, gamma, matrix) {
      var _this5;

      _classCallCheck(this, CalRGBCS);

      _this5 = _super8.call(this, "CalRGB", 3);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
      }

      blackPoint = blackPoint || new Float32Array(3);
      gamma = gamma || new Float32Array([1, 1, 1]);
      matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      var XW = whitePoint[0];
      var YW = whitePoint[1];
      var ZW = whitePoint[2];
      _this5.whitePoint = whitePoint;
      var XB = blackPoint[0];
      var YB = blackPoint[1];
      var ZB = blackPoint[2];
      _this5.blackPoint = blackPoint;
      _this5.GR = gamma[0];
      _this5.GG = gamma[1];
      _this5.GB = gamma[2];
      _this5.MXA = matrix[0];
      _this5.MYA = matrix[1];
      _this5.MZA = matrix[2];
      _this5.MXB = matrix[3];
      _this5.MYB = matrix[4];
      _this5.MZB = matrix[5];
      _this5.MXC = matrix[6];
      _this5.MYC = matrix[7];
      _this5.MZC = matrix[8];

      if (XW < 0 || ZW < 0 || YW !== 1) {
        throw new _util.FormatError("Invalid WhitePoint components for ".concat(_this5.name) + ", no fallback available");
      }

      if (XB < 0 || YB < 0 || ZB < 0) {
        (0, _util.info)("Invalid BlackPoint for ".concat(_this5.name, " [").concat(XB, ", ").concat(YB, ", ").concat(ZB, "], ") + "falling back to default.");
        _this5.blackPoint = new Float32Array(3);
      }

      if (_this5.GR < 0 || _this5.GG < 0 || _this5.GB < 0) {
        (0, _util.info)("Invalid Gamma [".concat(_this5.GR, ", ").concat(_this5.GG, ", ").concat(_this5.GB, "] for ") + "".concat(_this5.name, ", falling back to default."));
        _this5.GR = _this5.GG = _this5.GB = 1;
      }

      return _this5;
    }

    _createClass(CalRGBCS, [{
      key: "getRgbItem",
      value: function getRgbItem(src, srcOffset, dest, destOffset) {
        convertToRgb(this, src, srcOffset, dest, destOffset, 1);
      }
    }, {
      key: "getRgbBuffer",
      value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
        var scale = 1 / ((1 << bits) - 1);

        for (var i = 0; i < count; ++i) {
          convertToRgb(this, src, srcOffset, dest, destOffset, scale);
          srcOffset += 3;
          destOffset += 3 + alpha01;
        }
      }
    }, {
      key: "getOutputLength",
      value: function getOutputLength(inputLength, alpha01) {
        return inputLength * (3 + alpha01) / 3 | 0;
      }
    }]);

    return CalRGBCS;
  }(ColorSpace);

  return CalRGBCS;
}();

var LabCS = function LabCSClosure() {
  function fn_g(x) {
    var result;

    if (x >= 6 / 29) {
      result = x * x * x;
    } else {
      result = 108 / 841 * (x - 4 / 29);
    }

    return result;
  }

  function decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }

  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
    var Ls = src[srcOffset];
    var as = src[srcOffset + 1];
    var bs = src[srcOffset + 2];

    if (maxVal !== false) {
      Ls = decode(Ls, maxVal, 0, 100);
      as = decode(as, maxVal, cs.amin, cs.amax);
      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
    }

    if (as > cs.amax) {
      as = cs.amax;
    } else if (as < cs.amin) {
      as = cs.amin;
    }

    if (bs > cs.bmax) {
      bs = cs.bmax;
    } else if (bs < cs.bmin) {
      bs = cs.bmin;
    }

    var M = (Ls + 16) / 116;
    var L = M + as / 500;
    var N = M - bs / 200;
    var X = cs.XW * fn_g(L);
    var Y = cs.YW * fn_g(M);
    var Z = cs.ZW * fn_g(N);
    var r, g, b;

    if (cs.ZW < 1) {
      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
      b = X * 0.072 + Y * -0.229 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.204 + Z * 1.057;
    }

    dest[destOffset] = Math.sqrt(r) * 255;
    dest[destOffset + 1] = Math.sqrt(g) * 255;
    dest[destOffset + 2] = Math.sqrt(b) * 255;
  }

  var LabCS = /*#__PURE__*/function (_ColorSpace9) {
    _inherits(LabCS, _ColorSpace9);

    var _super9 = _createSuper(LabCS);

    function LabCS(whitePoint, blackPoint, range) {
      var _this6;

      _classCallCheck(this, LabCS);

      _this6 = _super9.call(this, "Lab", 3);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space Lab");
      }

      blackPoint = blackPoint || [0, 0, 0];
      range = range || [-100, 100, -100, 100];
      _this6.XW = whitePoint[0];
      _this6.YW = whitePoint[1];
      _this6.ZW = whitePoint[2];
      _this6.amin = range[0];
      _this6.amax = range[1];
      _this6.bmin = range[2];
      _this6.bmax = range[3];
      _this6.XB = blackPoint[0];
      _this6.YB = blackPoint[1];
      _this6.ZB = blackPoint[2];

      if (_this6.XW < 0 || _this6.ZW < 0 || _this6.YW !== 1) {
        throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
      }

      if (_this6.XB < 0 || _this6.YB < 0 || _this6.ZB < 0) {
        (0, _util.info)("Invalid BlackPoint, falling back to default");
        _this6.XB = _this6.YB = _this6.ZB = 0;
      }

      if (_this6.amin > _this6.amax || _this6.bmin > _this6.bmax) {
        (0, _util.info)("Invalid Range, falling back to defaults");
        _this6.amin = -100;
        _this6.amax = 100;
        _this6.bmin = -100;
        _this6.bmax = 100;
      }

      return _this6;
    }

    _createClass(LabCS, [{
      key: "getRgbItem",
      value: function getRgbItem(src, srcOffset, dest, destOffset) {
        convertToRgb(this, src, srcOffset, false, dest, destOffset);
      }
    }, {
      key: "getRgbBuffer",
      value: function getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
        var maxVal = (1 << bits) - 1;

        for (var i = 0; i < count; i++) {
          convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
          srcOffset += 3;
          destOffset += 3 + alpha01;
        }
      }
    }, {
      key: "getOutputLength",
      value: function getOutputLength(inputLength, alpha01) {
        return inputLength * (3 + alpha01) / 3 | 0;
      }
    }, {
      key: "isDefaultDecode",
      value: function isDefaultDecode(decodeMap, bpc) {
        return true;
      }
    }, {
      key: "usesZeroToOneRange",
      get: function get() {
        return (0, _util.shadow)(this, "usesZeroToOneRange", false);
      }
    }]);

    return LabCS;
  }(ColorSpace);

  return LabCS;
}();

/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalTilingPatternCache = exports.LocalImageCache = exports.LocalGStateCache = exports.LocalFunctionCache = exports.LocalColorSpaceCache = exports.GlobalImageCache = void 0;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BaseLocalCache = /*#__PURE__*/function () {
  function BaseLocalCache(options) {
    _classCallCheck(this, BaseLocalCache);

    if (this.constructor === BaseLocalCache) {
      (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
    }

    if (!options || !options.onlyRefs) {
      this._nameRefMap = new Map();
      this._imageMap = new Map();
    }

    this._imageCache = new _primitives.RefSetCache();
  }

  _createClass(BaseLocalCache, [{
    key: "getByName",
    value: function getByName(name) {
      var ref = this._nameRefMap.get(name);

      if (ref) {
        return this.getByRef(ref);
      }

      return this._imageMap.get(name) || null;
    }
  }, {
    key: "getByRef",
    value: function getByRef(ref) {
      return this._imageCache.get(ref) || null;
    }
  }, {
    key: "set",
    value: function set(name, ref, data) {
      (0, _util.unreachable)("Abstract method `set` called.");
    }
  }]);

  return BaseLocalCache;
}();

var LocalImageCache = /*#__PURE__*/function (_BaseLocalCache) {
  _inherits(LocalImageCache, _BaseLocalCache);

  var _super = _createSuper(LocalImageCache);

  function LocalImageCache() {
    _classCallCheck(this, LocalImageCache);

    return _super.apply(this, arguments);
  }

  _createClass(LocalImageCache, [{
    key: "set",
    value: function set(name) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var data = arguments.length > 2 ? arguments[2] : undefined;

      if (!name) {
        throw new Error('LocalImageCache.set - expected "name" argument.');
      }

      if (ref) {
        if (this._imageCache.has(ref)) {
          return;
        }

        this._nameRefMap.set(name, ref);

        this._imageCache.put(ref, data);

        return;
      }

      if (this._imageMap.has(name)) {
        return;
      }

      this._imageMap.set(name, data);
    }
  }]);

  return LocalImageCache;
}(BaseLocalCache);

exports.LocalImageCache = LocalImageCache;

var LocalColorSpaceCache = /*#__PURE__*/function (_BaseLocalCache2) {
  _inherits(LocalColorSpaceCache, _BaseLocalCache2);

  var _super2 = _createSuper(LocalColorSpaceCache);

  function LocalColorSpaceCache() {
    _classCallCheck(this, LocalColorSpaceCache);

    return _super2.apply(this, arguments);
  }

  _createClass(LocalColorSpaceCache, [{
    key: "set",
    value: function set() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var data = arguments.length > 2 ? arguments[2] : undefined;

      if (!name && !ref) {
        throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
      }

      if (ref) {
        if (this._imageCache.has(ref)) {
          return;
        }

        if (name) {
          this._nameRefMap.set(name, ref);
        }

        this._imageCache.put(ref, data);

        return;
      }

      if (this._imageMap.has(name)) {
        return;
      }

      this._imageMap.set(name, data);
    }
  }]);

  return LocalColorSpaceCache;
}(BaseLocalCache);

exports.LocalColorSpaceCache = LocalColorSpaceCache;

var LocalFunctionCache = /*#__PURE__*/function (_BaseLocalCache3) {
  _inherits(LocalFunctionCache, _BaseLocalCache3);

  var _super3 = _createSuper(LocalFunctionCache);

  function LocalFunctionCache(options) {
    _classCallCheck(this, LocalFunctionCache);

    return _super3.call(this, {
      onlyRefs: true
    });
  }

  _createClass(LocalFunctionCache, [{
    key: "getByName",
    value: function getByName(name) {
      (0, _util.unreachable)("Should not call `getByName` method.");
    }
  }, {
    key: "set",
    value: function set() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var ref = arguments.length > 1 ? arguments[1] : undefined;
      var data = arguments.length > 2 ? arguments[2] : undefined;

      if (!ref) {
        throw new Error('LocalFunctionCache.set - expected "ref" argument.');
      }

      if (this._imageCache.has(ref)) {
        return;
      }

      this._imageCache.put(ref, data);
    }
  }]);

  return LocalFunctionCache;
}(BaseLocalCache);

exports.LocalFunctionCache = LocalFunctionCache;

var LocalGStateCache = /*#__PURE__*/function (_BaseLocalCache4) {
  _inherits(LocalGStateCache, _BaseLocalCache4);

  var _super4 = _createSuper(LocalGStateCache);

  function LocalGStateCache() {
    _classCallCheck(this, LocalGStateCache);

    return _super4.apply(this, arguments);
  }

  _createClass(LocalGStateCache, [{
    key: "set",
    value: function set(name) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var data = arguments.length > 2 ? arguments[2] : undefined;

      if (!name) {
        throw new Error('LocalGStateCache.set - expected "name" argument.');
      }

      if (ref) {
        if (this._imageCache.has(ref)) {
          return;
        }

        this._nameRefMap.set(name, ref);

        this._imageCache.put(ref, data);

        return;
      }

      if (this._imageMap.has(name)) {
        return;
      }

      this._imageMap.set(name, data);
    }
  }]);

  return LocalGStateCache;
}(BaseLocalCache);

exports.LocalGStateCache = LocalGStateCache;

var LocalTilingPatternCache = /*#__PURE__*/function (_BaseLocalCache5) {
  _inherits(LocalTilingPatternCache, _BaseLocalCache5);

  var _super5 = _createSuper(LocalTilingPatternCache);

  function LocalTilingPatternCache() {
    _classCallCheck(this, LocalTilingPatternCache);

    return _super5.apply(this, arguments);
  }

  _createClass(LocalTilingPatternCache, [{
    key: "set",
    value: function set(name) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var data = arguments.length > 2 ? arguments[2] : undefined;

      if (!name) {
        throw new Error('LocalTilingPatternCache.set - expected "name" argument.');
      }

      if (ref) {
        if (this._imageCache.has(ref)) {
          return;
        }

        this._nameRefMap.set(name, ref);

        this._imageCache.put(ref, data);

        return;
      }

      if (this._imageMap.has(name)) {
        return;
      }

      this._imageMap.set(name, data);
    }
  }]);

  return LocalTilingPatternCache;
}(BaseLocalCache);

exports.LocalTilingPatternCache = LocalTilingPatternCache;

var GlobalImageCache = /*#__PURE__*/function () {
  function GlobalImageCache() {
    _classCallCheck(this, GlobalImageCache);

    this._refCache = new _primitives.RefSetCache();
    this._imageCache = new _primitives.RefSetCache();
  }

  _createClass(GlobalImageCache, [{
    key: "_byteSize",
    get: function get() {
      var byteSize = 0;

      this._imageCache.forEach(function (imageData) {
        byteSize += imageData.byteSize;
      });

      return byteSize;
    }
  }, {
    key: "_cacheLimitReached",
    get: function get() {
      if (this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) {
        return false;
      }

      if (this._byteSize < GlobalImageCache.MAX_BYTE_SIZE) {
        return false;
      }

      return true;
    }
  }, {
    key: "shouldCache",
    value: function shouldCache(ref, pageIndex) {
      var pageIndexSet = this._refCache.get(ref);

      var numPages = pageIndexSet ? pageIndexSet.size + (pageIndexSet.has(pageIndex) ? 0 : 1) : 1;

      if (numPages < GlobalImageCache.NUM_PAGES_THRESHOLD) {
        return false;
      }

      if (!this._imageCache.has(ref) && this._cacheLimitReached) {
        return false;
      }

      return true;
    }
  }, {
    key: "addPageIndex",
    value: function addPageIndex(ref, pageIndex) {
      var pageIndexSet = this._refCache.get(ref);

      if (!pageIndexSet) {
        pageIndexSet = new Set();

        this._refCache.put(ref, pageIndexSet);
      }

      pageIndexSet.add(pageIndex);
    }
  }, {
    key: "addByteSize",
    value: function addByteSize(ref, byteSize) {
      var imageData = this._imageCache.get(ref);

      if (!imageData) {
        return;
      }

      if (imageData.byteSize) {
        return;
      }

      imageData.byteSize = byteSize;
    }
  }, {
    key: "getData",
    value: function getData(ref, pageIndex) {
      var pageIndexSet = this._refCache.get(ref);

      if (!pageIndexSet) {
        return null;
      }

      if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
        return null;
      }

      var imageData = this._imageCache.get(ref);

      if (!imageData) {
        return null;
      }

      pageIndexSet.add(pageIndex);
      return imageData;
    }
  }, {
    key: "setData",
    value: function setData(ref, data) {
      if (!this._refCache.has(ref)) {
        throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
      }

      if (this._imageCache.has(ref)) {
        return;
      }

      if (this._cacheLimitReached) {
        (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
        return;
      }

      this._imageCache.put(ref, data);
    }
  }, {
    key: "clear",
    value: function clear() {
      var onlyData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!onlyData) {
        this._refCache.clear();
      }

      this._imageCache.clear();
    }
  }], [{
    key: "NUM_PAGES_THRESHOLD",
    get: function get() {
      return (0, _util.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
    }
  }, {
    key: "MIN_IMAGES_TO_CACHE",
    get: function get() {
      return (0, _util.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
    }
  }, {
    key: "MAX_BYTE_SIZE",
    get: function get() {
      return (0, _util.shadow)(this, "MAX_BYTE_SIZE", 40e6);
    }
  }]);

  return GlobalImageCache;
}();

exports.GlobalImageCache = GlobalImageCache;

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getQuadPoints = getQuadPoints;
exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _obj = __w_pdfjs_require__(140);

var _core_utils = __w_pdfjs_require__(138);

var _default_appearance = __w_pdfjs_require__(156);

var _primitives = __w_pdfjs_require__(135);

var _colorspace = __w_pdfjs_require__(153);

var _operator_list = __w_pdfjs_require__(174);

var _stream = __w_pdfjs_require__(142);

var _writer = __w_pdfjs_require__(176);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationFactory = /*#__PURE__*/function () {
  function AnnotationFactory() {
    _classCallCheck(this, AnnotationFactory);
  }

  _createClass(AnnotationFactory, null, [{
    key: "create",
    value: function create(xref, ref, pdfManager, idFactory) {
      var _this = this;

      return pdfManager.ensureCatalog("acroForm").then(function (acroForm) {
        return pdfManager.ensure(_this, "_create", [xref, ref, pdfManager, idFactory, acroForm]);
      });
    }
  }, {
    key: "_create",
    value: function _create(xref, ref, pdfManager, idFactory, acroForm) {
      var dict = xref.fetchIfRef(ref);

      if (!(0, _primitives.isDict)(dict)) {
        return undefined;
      }

      var id = (0, _primitives.isRef)(ref) ? ref.toString() : "annot_".concat(idFactory.createObjId());
      var subtype = dict.get("Subtype");
      subtype = (0, _primitives.isName)(subtype) ? subtype.name : null;
      var parameters = {
        xref: xref,
        ref: ref,
        dict: dict,
        subtype: subtype,
        id: id,
        pdfManager: pdfManager,
        acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty
      };

      switch (subtype) {
        case "Link":
          return new LinkAnnotation(parameters);

        case "Text":
          return new TextAnnotation(parameters);

        case "Widget":
          var fieldType = (0, _core_utils.getInheritableProperty)({
            dict: dict,
            key: "FT"
          });
          fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;

          switch (fieldType) {
            case "Tx":
              return new TextWidgetAnnotation(parameters);

            case "Btn":
              return new ButtonWidgetAnnotation(parameters);

            case "Ch":
              return new ChoiceWidgetAnnotation(parameters);
          }

          (0, _util.warn)('Unimplemented widget field type "' + fieldType + '", ' + "falling back to base field type.");
          return new WidgetAnnotation(parameters);

        case "Popup":
          return new PopupAnnotation(parameters);

        case "FreeText":
          return new FreeTextAnnotation(parameters);

        case "Line":
          return new LineAnnotation(parameters);

        case "Square":
          return new SquareAnnotation(parameters);

        case "Circle":
          return new CircleAnnotation(parameters);

        case "PolyLine":
          return new PolylineAnnotation(parameters);

        case "Polygon":
          return new PolygonAnnotation(parameters);

        case "Caret":
          return new CaretAnnotation(parameters);

        case "Ink":
          return new InkAnnotation(parameters);

        case "Highlight":
          return new HighlightAnnotation(parameters);

        case "Underline":
          return new UnderlineAnnotation(parameters);

        case "Squiggly":
          return new SquigglyAnnotation(parameters);

        case "StrikeOut":
          return new StrikeOutAnnotation(parameters);

        case "Stamp":
          return new StampAnnotation(parameters);

        case "FileAttachment":
          return new FileAttachmentAnnotation(parameters);

        default:
          if (!subtype) {
            (0, _util.warn)("Annotation is missing the required /Subtype.");
          } else {
            (0, _util.warn)('Unimplemented annotation type "' + subtype + '", ' + "falling back to base annotation.");
          }

          return new Annotation(parameters);
      }
    }
  }]);

  return AnnotationFactory;
}();

exports.AnnotationFactory = AnnotationFactory;

function getQuadPoints(dict, rect) {
  if (!dict.has("QuadPoints")) {
    return null;
  }

  var quadPoints = dict.getArray("QuadPoints");

  if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
    return null;
  }

  var quadPointsLists = [];

  for (var i = 0, ii = quadPoints.length / 8; i < ii; i++) {
    quadPointsLists.push([]);

    for (var j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
      var x = quadPoints[j];
      var y = quadPoints[j + 1];

      if (rect !== null && (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3])) {
        return null;
      }

      quadPointsLists[i].push({
        x: x,
        y: y
      });
    }
  }

  return quadPointsLists.map(function (quadPointsList) {
    var _quadPointsList$reduc = quadPointsList.reduce(function (_ref, quadPoint) {
      var _ref2 = _slicedToArray(_ref, 4),
          mX = _ref2[0],
          MX = _ref2[1],
          mY = _ref2[2],
          MY = _ref2[3];

      return [Math.min(mX, quadPoint.x), Math.max(MX, quadPoint.x), Math.min(mY, quadPoint.y), Math.max(MY, quadPoint.y)];
    }, [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]),
        _quadPointsList$reduc2 = _slicedToArray(_quadPointsList$reduc, 4),
        minX = _quadPointsList$reduc2[0],
        maxX = _quadPointsList$reduc2[1],
        minY = _quadPointsList$reduc2[2],
        maxY = _quadPointsList$reduc2[3];

    return [{
      x: minX,
      y: maxY
    }, {
      x: maxX,
      y: maxY
    }, {
      x: minX,
      y: minY
    }, {
      x: maxX,
      y: minY
    }];
  });
}

function getTransformMatrix(rect, bbox, matrix) {
  var _Util$getAxialAligned = _util.Util.getAxialAlignedBoundingBox(bbox, matrix),
      _Util$getAxialAligned2 = _slicedToArray(_Util$getAxialAligned, 4),
      minX = _Util$getAxialAligned2[0],
      minY = _Util$getAxialAligned2[1],
      maxX = _Util$getAxialAligned2[2],
      maxY = _Util$getAxialAligned2[3];

  if (minX === maxX || minY === maxY) {
    return [1, 0, 0, 1, rect[0], rect[1]];
  }

  var xRatio = (rect[2] - rect[0]) / (maxX - minX);
  var yRatio = (rect[3] - rect[1]) / (maxY - minY);
  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
}

var Annotation = /*#__PURE__*/function () {
  function Annotation(params) {
    _classCallCheck(this, Annotation);

    var dict = params.dict;
    this.setContents(dict.get("Contents"));
    this.setModificationDate(dict.get("M"));
    this.setFlags(dict.get("F"));
    this.setRectangle(dict.getArray("Rect"));
    this.setColor(dict.getArray("C"));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this._streams = [];

    if (this.appearance) {
      this._streams.push(this.appearance);
    }

    this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      contents: this.contents,
      hasAppearance: !!this.appearance,
      id: params.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: params.subtype
    };
    this._fallbackFontDict = null;
  }

  _createClass(Annotation, [{
    key: "_hasFlag",
    value: function _hasFlag(flags, flag) {
      return !!(flags & flag);
    }
  }, {
    key: "_isViewable",
    value: function _isViewable(flags) {
      return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
    }
  }, {
    key: "_isPrintable",
    value: function _isPrintable(flags) {
      return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
    }
  }, {
    key: "isHidden",
    value: function isHidden(annotationStorage) {
      var data = annotationStorage && annotationStorage[this.data.id];

      if (data && "hidden" in data) {
        return data.hidden;
      }

      return this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
    }
  }, {
    key: "viewable",
    get: function get() {
      if (this.data.quadPoints === null) {
        return false;
      }

      if (this.flags === 0) {
        return true;
      }

      return this._isViewable(this.flags);
    }
  }, {
    key: "printable",
    get: function get() {
      if (this.data.quadPoints === null) {
        return false;
      }

      if (this.flags === 0) {
        return false;
      }

      return this._isPrintable(this.flags);
    }
  }, {
    key: "setContents",
    value: function setContents(contents) {
      this.contents = (0, _util.stringToPDFString)(contents || "");
    }
  }, {
    key: "setModificationDate",
    value: function setModificationDate(modificationDate) {
      this.modificationDate = (0, _util.isString)(modificationDate) ? modificationDate : null;
    }
  }, {
    key: "setFlags",
    value: function setFlags(flags) {
      this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
    }
  }, {
    key: "hasFlag",
    value: function hasFlag(flag) {
      return this._hasFlag(this.flags, flag);
    }
  }, {
    key: "setRectangle",
    value: function setRectangle(rectangle) {
      if (Array.isArray(rectangle) && rectangle.length === 4) {
        this.rectangle = _util.Util.normalizeRect(rectangle);
      } else {
        this.rectangle = [0, 0, 0, 0];
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var rgbColor = new Uint8ClampedArray(3);

      if (!Array.isArray(color)) {
        this.color = rgbColor;
        return;
      }

      switch (color.length) {
        case 0:
          this.color = null;
          break;

        case 1:
          _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);

          this.color = rgbColor;
          break;

        case 3:
          _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);

          this.color = rgbColor;
          break;

        case 4:
          _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);

          this.color = rgbColor;
          break;

        default:
          this.color = rgbColor;
          break;
      }
    }
  }, {
    key: "setBorderStyle",
    value: function setBorderStyle(borderStyle) {
      this.borderStyle = new AnnotationBorderStyle();

      if (!(0, _primitives.isDict)(borderStyle)) {
        return;
      }

      if (borderStyle.has("BS")) {
        var dict = borderStyle.get("BS");
        var dictType = dict.get("Type");

        if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
          this.borderStyle.setWidth(dict.get("W"), this.rectangle);
          this.borderStyle.setStyle(dict.get("S"));
          this.borderStyle.setDashArray(dict.getArray("D"));
        }
      } else if (borderStyle.has("Border")) {
        var array = borderStyle.getArray("Border");

        if (Array.isArray(array) && array.length >= 3) {
          this.borderStyle.setHorizontalCornerRadius(array[0]);
          this.borderStyle.setVerticalCornerRadius(array[1]);
          this.borderStyle.setWidth(array[2], this.rectangle);

          if (array.length === 4) {
            this.borderStyle.setDashArray(array[3]);
          }
        }
      } else {
        this.borderStyle.setWidth(0);
      }
    }
  }, {
    key: "setAppearance",
    value: function setAppearance(dict) {
      this.appearance = null;
      var appearanceStates = dict.get("AP");

      if (!(0, _primitives.isDict)(appearanceStates)) {
        return;
      }

      var normalAppearanceState = appearanceStates.get("N");

      if ((0, _primitives.isStream)(normalAppearanceState)) {
        this.appearance = normalAppearanceState;
        return;
      }

      if (!(0, _primitives.isDict)(normalAppearanceState)) {
        return;
      }

      var as = dict.get("AS");

      if (!(0, _primitives.isName)(as) || !normalAppearanceState.has(as.name)) {
        return;
      }

      this.appearance = normalAppearanceState.get(as.name);
    }
  }, {
    key: "loadResources",
    value: function loadResources(keys) {
      return this.appearance.dict.getAsync("Resources").then(function (resources) {
        if (!resources) {
          return undefined;
        }

        var objectLoader = new _obj.ObjectLoader(resources, keys, resources.xref);
        return objectLoader.load().then(function () {
          return resources;
        });
      });
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList(evaluator, task, renderForms, annotationStorage) {
      var _this2 = this;

      if (!this.appearance) {
        return Promise.resolve(new _operator_list.OperatorList());
      }

      var appearance = this.appearance;
      var data = this.data;
      var appearanceDict = appearance.dict;
      var resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
      var bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
      var matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
      var transform = getTransformMatrix(data.rect, bbox, matrix);
      return resourcesPromise.then(function (resources) {
        var opList = new _operator_list.OperatorList();
        opList.addOp(_util.OPS.beginAnnotation, [data.rect, transform, matrix]);
        return evaluator.getOperatorList({
          stream: appearance,
          task: task,
          resources: resources,
          operatorList: opList,
          fallbackFontDict: _this2._fallbackFontDict
        }).then(function () {
          opList.addOp(_util.OPS.endAnnotation, []);

          _this2.reset();

          return opList;
        });
      });
    }
  }, {
    key: "save",
    value: function () {
      var _save = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(evaluator, task, annotationStorage) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", null);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function save(_x, _x2, _x3) {
        return _save.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "getFieldObject",
    value: function getFieldObject() {
      return null;
    }
  }, {
    key: "reset",
    value: function reset() {
      var _iterator = _createForOfIteratorHelper(this._streams),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var stream = _step.value;
          stream.reset();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return Annotation;
}();

exports.Annotation = Annotation;

var AnnotationBorderStyle = /*#__PURE__*/function () {
  function AnnotationBorderStyle() {
    _classCallCheck(this, AnnotationBorderStyle);

    this.width = 1;
    this.style = _util.AnnotationBorderStyleType.SOLID;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }

  _createClass(AnnotationBorderStyle, [{
    key: "setWidth",
    value: function setWidth(width) {
      var rect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0];

      if ((0, _primitives.isName)(width)) {
        this.width = 0;
        return;
      }

      if (Number.isInteger(width)) {
        if (width > 0) {
          var maxWidth = (rect[2] - rect[0]) / 2;
          var maxHeight = (rect[3] - rect[1]) / 2;

          if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
            (0, _util.warn)("AnnotationBorderStyle.setWidth - ignoring width: ".concat(width));
            width = 1;
          }
        }

        this.width = width;
      }
    }
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      if (!(0, _primitives.isName)(style)) {
        return;
      }

      switch (style.name) {
        case "S":
          this.style = _util.AnnotationBorderStyleType.SOLID;
          break;

        case "D":
          this.style = _util.AnnotationBorderStyleType.DASHED;
          break;

        case "B":
          this.style = _util.AnnotationBorderStyleType.BEVELED;
          break;

        case "I":
          this.style = _util.AnnotationBorderStyleType.INSET;
          break;

        case "U":
          this.style = _util.AnnotationBorderStyleType.UNDERLINE;
          break;

        default:
          break;
      }
    }
  }, {
    key: "setDashArray",
    value: function setDashArray(dashArray) {
      if (Array.isArray(dashArray) && dashArray.length > 0) {
        var isValid = true;
        var allZeros = true;

        var _iterator2 = _createForOfIteratorHelper(dashArray),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var element = _step2.value;
            var validNumber = +element >= 0;

            if (!validNumber) {
              isValid = false;
              break;
            } else if (element > 0) {
              allZeros = false;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        if (isValid && !allZeros) {
          this.dashArray = dashArray;
        } else {
          this.width = 0;
        }
      } else if (dashArray) {
        this.width = 0;
      }
    }
  }, {
    key: "setHorizontalCornerRadius",
    value: function setHorizontalCornerRadius(radius) {
      if (Number.isInteger(radius)) {
        this.horizontalCornerRadius = radius;
      }
    }
  }, {
    key: "setVerticalCornerRadius",
    value: function setVerticalCornerRadius(radius) {
      if (Number.isInteger(radius)) {
        this.verticalCornerRadius = radius;
      }
    }
  }]);

  return AnnotationBorderStyle;
}();

exports.AnnotationBorderStyle = AnnotationBorderStyle;

var MarkupAnnotation = /*#__PURE__*/function (_Annotation) {
  _inherits(MarkupAnnotation, _Annotation);

  var _super = _createSuper(MarkupAnnotation);

  function MarkupAnnotation(parameters) {
    var _this3;

    _classCallCheck(this, MarkupAnnotation);

    _this3 = _super.call(this, parameters);
    var dict = parameters.dict;

    if (dict.has("IRT")) {
      var rawIRT = dict.getRaw("IRT");
      _this3.data.inReplyTo = (0, _primitives.isRef)(rawIRT) ? rawIRT.toString() : null;
      var rt = dict.get("RT");
      _this3.data.replyType = (0, _primitives.isName)(rt) ? rt.name : _util.AnnotationReplyType.REPLY;
    }

    if (_this3.data.replyType === _util.AnnotationReplyType.GROUP) {
      var parent = dict.get("IRT");
      _this3.data.title = (0, _util.stringToPDFString)(parent.get("T") || "");

      _this3.setContents(parent.get("Contents"));

      _this3.data.contents = _this3.contents;

      if (!parent.has("CreationDate")) {
        _this3.data.creationDate = null;
      } else {
        _this3.setCreationDate(parent.get("CreationDate"));

        _this3.data.creationDate = _this3.creationDate;
      }

      if (!parent.has("M")) {
        _this3.data.modificationDate = null;
      } else {
        _this3.setModificationDate(parent.get("M"));

        _this3.data.modificationDate = _this3.modificationDate;
      }

      _this3.data.hasPopup = parent.has("Popup");

      if (!parent.has("C")) {
        _this3.data.color = null;
      } else {
        _this3.setColor(parent.getArray("C"));

        _this3.data.color = _this3.color;
      }
    } else {
      _this3.data.title = (0, _util.stringToPDFString)(dict.get("T") || "");

      _this3.setCreationDate(dict.get("CreationDate"));

      _this3.data.creationDate = _this3.creationDate;
      _this3.data.hasPopup = dict.has("Popup");

      if (!dict.has("C")) {
        _this3.data.color = null;
      }
    }

    return _this3;
  }

  _createClass(MarkupAnnotation, [{
    key: "setCreationDate",
    value: function setCreationDate(creationDate) {
      this.creationDate = (0, _util.isString)(creationDate) ? creationDate : null;
    }
  }, {
    key: "_setDefaultAppearance",
    value: function _setDefaultAppearance(_ref3) {
      var xref = _ref3.xref,
          extra = _ref3.extra,
          strokeColor = _ref3.strokeColor,
          fillColor = _ref3.fillColor,
          blendMode = _ref3.blendMode,
          pointsCallback = _ref3.pointsCallback;
      var minX = Number.MAX_VALUE;
      var minY = Number.MAX_VALUE;
      var maxX = Number.MIN_VALUE;
      var maxY = Number.MIN_VALUE;
      var buffer = ["q"];

      if (extra) {
        buffer.push(extra);
      }

      if (strokeColor) {
        buffer.push("".concat(strokeColor[0], " ").concat(strokeColor[1], " ").concat(strokeColor[2], " RG"));
      }

      if (fillColor) {
        buffer.push("".concat(fillColor[0], " ").concat(fillColor[1], " ").concat(fillColor[2], " rg"));
      }

      var _iterator3 = _createForOfIteratorHelper(this.data.quadPoints),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var points = _step3.value;

          var _pointsCallback = pointsCallback(buffer, points),
              _pointsCallback2 = _slicedToArray(_pointsCallback, 4),
              mX = _pointsCallback2[0],
              MX = _pointsCallback2[1],
              mY = _pointsCallback2[2],
              MY = _pointsCallback2[3];

          minX = Math.min(minX, mX);
          maxX = Math.max(maxX, MX);
          minY = Math.min(minY, mY);
          maxY = Math.max(maxY, MY);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      buffer.push("Q");
      var formDict = new _primitives.Dict(xref);
      var appearanceStreamDict = new _primitives.Dict(xref);
      appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
      var appearanceStream = new _stream.StringStream(buffer.join(" "));
      appearanceStream.dict = appearanceStreamDict;
      formDict.set("Fm0", appearanceStream);
      var gsDict = new _primitives.Dict(xref);

      if (blendMode) {
        gsDict.set("BM", _primitives.Name.get(blendMode));
      }

      var stateDict = new _primitives.Dict(xref);
      stateDict.set("GS0", gsDict);
      var resources = new _primitives.Dict(xref);
      resources.set("ExtGState", stateDict);
      resources.set("XObject", formDict);
      var appearanceDict = new _primitives.Dict(xref);
      appearanceDict.set("Resources", resources);
      var bbox = this.data.rect = [minX, minY, maxX, maxY];
      appearanceDict.set("BBox", bbox);
      this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
      this.appearance.dict = appearanceDict;

      this._streams.push(this.appearance, appearanceStream);
    }
  }]);

  return MarkupAnnotation;
}(Annotation);

exports.MarkupAnnotation = MarkupAnnotation;

var WidgetAnnotation = /*#__PURE__*/function (_Annotation2) {
  _inherits(WidgetAnnotation, _Annotation2);

  var _super2 = _createSuper(WidgetAnnotation);

  function WidgetAnnotation(params) {
    var _this4;

    _classCallCheck(this, WidgetAnnotation);

    _this4 = _super2.call(this, params);
    var dict = params.dict;
    var data = _this4.data;
    _this4.ref = params.ref;
    data.annotationType = _util.AnnotationType.WIDGET;
    data.fieldName = _this4._constructFieldName(dict);
    data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType);
    var fieldValue = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "V",
      getArray: true
    });
    data.fieldValue = _this4._decodeFormValue(fieldValue);
    var defaultFieldValue = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "DV",
      getArray: true
    });
    data.defaultFieldValue = _this4._decodeFormValue(defaultFieldValue);
    data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
    var defaultAppearance = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "DA"
    }) || params.acroForm.get("DA") || "";
    data.defaultAppearance = (0, _util.isString)(defaultAppearance) ? defaultAppearance : "";
    data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(data.defaultAppearance);
    var fieldType = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "FT"
    });
    data.fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
    var localResources = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "DR"
    });
    var acroFormResources = params.acroForm.get("DR");

    var appearanceResources = _this4.appearance && _this4.appearance.dict.get("Resources");

    _this4._fieldResources = {
      localResources: localResources,
      acroFormResources: acroFormResources,
      appearanceResources: appearanceResources,
      mergedResources: _primitives.Dict.merge({
        xref: params.xref,
        dictArray: [localResources, appearanceResources, acroFormResources],
        mergeSubDicts: true
      })
    };
    data.fieldFlags = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "Ff"
    });

    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
      data.fieldFlags = 0;
    }

    data.readOnly = _this4.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
    data.hidden = _this4._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN);

    if (data.fieldType === "Sig") {
      data.fieldValue = null;

      _this4.setFlags(_util.AnnotationFlag.HIDDEN);

      data.hidden = true;
    }

    return _this4;
  }

  _createClass(WidgetAnnotation, [{
    key: "_constructFieldName",
    value: function _constructFieldName(dict) {
      if (!dict.has("T") && !dict.has("Parent")) {
        (0, _util.warn)("Unknown field name, falling back to empty field name.");
        return "";
      }

      if (!dict.has("Parent")) {
        return (0, _util.stringToPDFString)(dict.get("T"));
      }

      var fieldName = [];

      if (dict.has("T")) {
        fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
      }

      var loopDict = dict;

      while (loopDict.has("Parent")) {
        loopDict = loopDict.get("Parent");

        if (!(0, _primitives.isDict)(loopDict)) {
          break;
        }

        if (loopDict.has("T")) {
          fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
        }
      }

      return fieldName.join(".");
    }
  }, {
    key: "_decodeFormValue",
    value: function _decodeFormValue(formValue) {
      if (Array.isArray(formValue)) {
        return formValue.filter(function (item) {
          return (0, _util.isString)(item);
        }).map(function (item) {
          return (0, _util.stringToPDFString)(item);
        });
      } else if ((0, _primitives.isName)(formValue)) {
        return (0, _util.stringToPDFString)(formValue.name);
      } else if ((0, _util.isString)(formValue)) {
        return (0, _util.stringToPDFString)(formValue);
      }

      return null;
    }
  }, {
    key: "hasFieldFlag",
    value: function hasFieldFlag(flag) {
      return !!(this.data.fieldFlags & flag);
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList(evaluator, task, renderForms, annotationStorage) {
      var _this5 = this;

      if (renderForms) {
        return Promise.resolve(new _operator_list.OperatorList());
      }

      if (!this._hasText) {
        return _get(_getPrototypeOf(WidgetAnnotation.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms, annotationStorage);
      }

      return this._getAppearance(evaluator, task, annotationStorage).then(function (content) {
        if (_this5.appearance && content === null) {
          return _get(_getPrototypeOf(WidgetAnnotation.prototype), "getOperatorList", _this5).call(_this5, evaluator, task, renderForms, annotationStorage);
        }

        var operatorList = new _operator_list.OperatorList();

        if (!_this5.data.defaultAppearance || content === null) {
          return operatorList;
        }

        var matrix = [1, 0, 0, 1, 0, 0];
        var bbox = [0, 0, _this5.data.rect[2] - _this5.data.rect[0], _this5.data.rect[3] - _this5.data.rect[1]];
        var transform = getTransformMatrix(_this5.data.rect, bbox, matrix);
        operatorList.addOp(_util.OPS.beginAnnotation, [_this5.data.rect, transform, matrix]);
        var stream = new _stream.StringStream(content);
        return evaluator.getOperatorList({
          stream: stream,
          task: task,
          resources: _this5._fieldResources.mergedResources,
          operatorList: operatorList
        }).then(function () {
          operatorList.addOp(_util.OPS.endAnnotation, []);
          return operatorList;
        });
      });
    }
  }, {
    key: "save",
    value: function () {
      var _save2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(evaluator, task, annotationStorage) {
        var value, appearance, xref, dict, bbox, xfa, newRef, AP, encrypt, originalTransform, newTransform, appearanceDict, bufferOriginal, bufferNew;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                value = annotationStorage[this.data.id] && annotationStorage[this.data.id].value;

                if (!(value === this.data.fieldValue || value === undefined)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", null);

              case 3:
                _context2.next = 5;
                return this._getAppearance(evaluator, task, annotationStorage);

              case 5:
                appearance = _context2.sent;

                if (!(appearance === null)) {
                  _context2.next = 8;
                  break;
                }

                return _context2.abrupt("return", null);

              case 8:
                xref = evaluator.xref;
                dict = xref.fetchIfRef(this.ref);

                if ((0, _primitives.isDict)(dict)) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", null);

              case 12:
                bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
                xfa = {
                  path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                  value: value
                };
                newRef = xref.getNewRef();
                AP = new _primitives.Dict(xref);
                AP.set("N", newRef);
                encrypt = xref.encrypt;
                originalTransform = null;
                newTransform = null;

                if (encrypt) {
                  originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                  newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen);
                  appearance = newTransform.encryptString(appearance);
                }

                dict.set("V", (0, _util.isAscii)(value) ? value : (0, _util.stringToUTF16BEString)(value));
                dict.set("AP", AP);
                dict.set("M", "D:".concat((0, _util.getModificationDate)()));
                appearanceDict = new _primitives.Dict(xref);
                appearanceDict.set("Length", appearance.length);
                appearanceDict.set("Subtype", _primitives.Name.get("Form"));
                appearanceDict.set("Resources", this._getSaveFieldResources(xref));
                appearanceDict.set("BBox", bbox);
                bufferOriginal = ["".concat(this.ref.num, " ").concat(this.ref.gen, " obj\n")];
                (0, _writer.writeDict)(dict, bufferOriginal, originalTransform);
                bufferOriginal.push("\nendobj\n");
                bufferNew = ["".concat(newRef.num, " ").concat(newRef.gen, " obj\n")];
                (0, _writer.writeDict)(appearanceDict, bufferNew, newTransform);
                bufferNew.push(" stream\n");
                bufferNew.push(appearance);
                bufferNew.push("\nendstream\nendobj\n");
                return _context2.abrupt("return", [{
                  ref: this.ref,
                  data: bufferOriginal.join(""),
                  xfa: xfa
                }, {
                  ref: newRef,
                  data: bufferNew.join(""),
                  xfa: null
                }]);

              case 38:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function save(_x4, _x5, _x6) {
        return _save2.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "_getAppearance",
    value: function () {
      var _getAppearance2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(evaluator, task, annotationStorage) {
        var isPassword, value, defaultPadding, hPadding, totalHeight, totalWidth, font, fontSize, descent, vPadding, defaultAppearance, alignment, encodedString, renderedText;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);

                if (!(!annotationStorage || isPassword)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", null);

              case 3:
                value = annotationStorage[this.data.id] && annotationStorage[this.data.id].value;

                if (!(value === undefined)) {
                  _context3.next = 6;
                  break;
                }

                return _context3.abrupt("return", null);

              case 6:
                if (!(value === "")) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", "");

              case 8:
                defaultPadding = 2;
                hPadding = defaultPadding;
                totalHeight = this.data.rect[3] - this.data.rect[1];
                totalWidth = this.data.rect[2] - this.data.rect[0];

                if (!this.data.defaultAppearance) {
                  this.data.defaultAppearance = "/Helvetica 0 Tf 0 g";
                  this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this.data.defaultAppearance);
                }

                _context3.next = 15;
                return this._getFontData(evaluator, task);

              case 15:
                font = _context3.sent;
                fontSize = this._computeFontSize(font, totalHeight);
                descent = font.descent;

                if (isNaN(descent)) {
                  descent = 0;
                }

                vPadding = defaultPadding + Math.abs(descent) * fontSize;
                defaultAppearance = this.data.defaultAppearance;
                alignment = this.data.textAlignment;

                if (!this.data.multiLine) {
                  _context3.next = 24;
                  break;
                }

                return _context3.abrupt("return", this._getMultilineAppearance(defaultAppearance, value, font, fontSize, totalWidth, totalHeight, alignment, hPadding, vPadding));

              case 24:
                encodedString = font.encodeString(value).join("");

                if (!this.data.comb) {
                  _context3.next = 27;
                  break;
                }

                return _context3.abrupt("return", this._getCombAppearance(defaultAppearance, font, encodedString, totalWidth, hPadding, vPadding));

              case 27:
                if (!(alignment === 0 || alignment > 2)) {
                  _context3.next = 29;
                  break;
                }

                return _context3.abrupt("return", "/Tx BMC q BT " + defaultAppearance + " 1 0 0 1 ".concat(hPadding, " ").concat(vPadding, " Tm (").concat((0, _util.escapeString)(encodedString), ") Tj") + " ET Q EMC");

              case 29:
                renderedText = this._renderText(encodedString, font, fontSize, totalWidth, alignment, hPadding, vPadding);
                return _context3.abrupt("return", "/Tx BMC q BT " + defaultAppearance + " 1 0 0 1 0 0 Tm ".concat(renderedText) + " ET Q EMC");

              case 31:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getAppearance(_x7, _x8, _x9) {
        return _getAppearance2.apply(this, arguments);
      }

      return _getAppearance;
    }()
  }, {
    key: "_getFontData",
    value: function () {
      var _getFontData2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(evaluator, task) {
        var operatorList, initialState, _this$data$defaultApp, fontName, fontSize;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                operatorList = new _operator_list.OperatorList();
                initialState = {
                  font: null,
                  clone: function clone() {
                    return this;
                  }
                };
                _this$data$defaultApp = this.data.defaultAppearanceData, fontName = _this$data$defaultApp.fontName, fontSize = _this$data$defaultApp.fontSize;
                _context4.next = 5;
                return evaluator.handleSetFont(this._fieldResources.mergedResources, [fontName, fontSize], null, operatorList, task, initialState, null);

              case 5:
                return _context4.abrupt("return", initialState.font);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getFontData(_x10, _x11) {
        return _getFontData2.apply(this, arguments);
      }

      return _getFontData;
    }()
  }, {
    key: "_computeFontSize",
    value: function _computeFontSize(font, height) {
      var fontSize = this.data.defaultAppearanceData.fontSize;

      if (!fontSize) {
        var _this$data$defaultApp2 = this.data.defaultAppearanceData,
            fontColor = _this$data$defaultApp2.fontColor,
            fontName = _this$data$defaultApp2.fontName;
        var capHeight;

        if (font.capHeight) {
          capHeight = font.capHeight;
        } else {
          var glyphs = font.charsToGlyphs(font.encodeString("M").join(""));

          if (glyphs.length === 1 && glyphs[0].width) {
            var em = glyphs[0].width / 1000;
            capHeight = 0.7 * em;
          } else {
            capHeight = 0.7;
          }
        }

        fontSize = Math.max(1, Math.floor(height / (1.5 * capHeight)));
        this.data.defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
          fontSize: fontSize,
          fontName: fontName,
          fontColor: fontColor
        });
      }

      return fontSize;
    }
  }, {
    key: "_renderText",
    value: function _renderText(text, font, fontSize, totalWidth, alignment, hPadding, vPadding) {
      var glyphs = font.charsToGlyphs(text);
      var scale = fontSize / 1000;
      var width = 0;

      var _iterator4 = _createForOfIteratorHelper(glyphs),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var glyph = _step4.value;
          width += glyph.width * scale;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var shift;

      if (alignment === 1) {
        shift = (totalWidth - width) / 2;
      } else if (alignment === 2) {
        shift = totalWidth - width - hPadding;
      } else {
        shift = hPadding;
      }

      shift = shift.toFixed(2);
      vPadding = vPadding.toFixed(2);
      return "".concat(shift, " ").concat(vPadding, " Td (").concat((0, _util.escapeString)(text), ") Tj");
    }
  }, {
    key: "_getSaveFieldResources",
    value: function _getSaveFieldResources(xref) {
      var _this$_fieldResources = this._fieldResources,
          localResources = _this$_fieldResources.localResources,
          appearanceResources = _this$_fieldResources.appearanceResources,
          acroFormResources = _this$_fieldResources.acroFormResources;
      var fontNameStr = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName.name;

      if (!fontNameStr) {
        return localResources || _primitives.Dict.empty;
      }

      for (var _i2 = 0, _arr2 = [localResources, appearanceResources]; _i2 < _arr2.length; _i2++) {
        var resources = _arr2[_i2];

        if (resources instanceof _primitives.Dict) {
          var localFont = resources.get("Font");

          if (localFont instanceof _primitives.Dict && localFont.has(fontNameStr)) {
            return resources;
          }
        }
      }

      if (acroFormResources instanceof _primitives.Dict) {
        var acroFormFont = acroFormResources.get("Font");

        if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontNameStr)) {
          var subFontDict = new _primitives.Dict(xref);
          subFontDict.set(fontNameStr, acroFormFont.getRaw(fontNameStr));
          var subResourcesDict = new _primitives.Dict(xref);
          subResourcesDict.set("Font", subFontDict);
          return _primitives.Dict.merge({
            xref: xref,
            dictArray: [subResourcesDict, localResources],
            mergeSubDicts: true
          });
        }
      }

      return localResources || _primitives.Dict.empty;
    }
  }, {
    key: "getFieldObject",
    value: function getFieldObject() {
      if (this.data.fieldType === "Sig") {
        return {
          id: this.data.id,
          value: null,
          type: "signature"
        };
      }

      return null;
    }
  }]);

  return WidgetAnnotation;
}(Annotation);

var TextWidgetAnnotation = /*#__PURE__*/function (_WidgetAnnotation) {
  _inherits(TextWidgetAnnotation, _WidgetAnnotation);

  var _super3 = _createSuper(TextWidgetAnnotation);

  function TextWidgetAnnotation(params) {
    var _this6;

    _classCallCheck(this, TextWidgetAnnotation);

    _this6 = _super3.call(this, params);
    _this6._hasText = true;
    var dict = params.dict;

    if (!(0, _util.isString)(_this6.data.fieldValue)) {
      _this6.data.fieldValue = "";
    }

    var alignment = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "Q"
    });

    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
      alignment = null;
    }

    _this6.data.textAlignment = alignment;
    var maximumLength = (0, _core_utils.getInheritableProperty)({
      dict: dict,
      key: "MaxLen"
    });

    if (!Number.isInteger(maximumLength) || maximumLength < 0) {
      maximumLength = null;
    }

    _this6.data.maxLen = maximumLength;
    _this6.data.multiLine = _this6.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
    _this6.data.comb = _this6.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !_this6.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !_this6.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !_this6.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && _this6.data.maxLen !== null;
    return _this6;
  }

  _createClass(TextWidgetAnnotation, [{
    key: "_getCombAppearance",
    value: function _getCombAppearance(defaultAppearance, font, text, width, hPadding, vPadding) {
      var combWidth = (width / this.data.maxLen).toFixed(2);
      var buf = [];
      var positions = font.getCharPositions(text);

      var _iterator5 = _createForOfIteratorHelper(positions),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              start = _step5$value[0],
              end = _step5$value[1];

          buf.push("(".concat((0, _util.escapeString)(text.substring(start, end)), ") Tj"));
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      var renderedComb = buf.join(" ".concat(combWidth, " 0 Td "));
      return "/Tx BMC q BT " + defaultAppearance + " 1 0 0 1 ".concat(hPadding, " ").concat(vPadding, " Tm ").concat(renderedComb) + " ET Q EMC";
    }
  }, {
    key: "_getMultilineAppearance",
    value: function _getMultilineAppearance(defaultAppearance, text, font, fontSize, width, height, alignment, hPadding, vPadding) {
      var lines = text.split(/\r\n|\r|\n/);
      var buf = [];
      var totalWidth = width - 2 * hPadding;

      var _iterator6 = _createForOfIteratorHelper(lines),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var line = _step6.value;

          var chunks = this._splitLine(line, font, fontSize, totalWidth);

          var _iterator7 = _createForOfIteratorHelper(chunks),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var chunk = _step7.value;
              var padding = buf.length === 0 ? hPadding : 0;
              buf.push(this._renderText(chunk, font, fontSize, width, alignment, padding, -fontSize));
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var renderedText = buf.join("\n");
      return "/Tx BMC q BT " + defaultAppearance + " 1 0 0 1 0 ".concat(height, " Tm ").concat(renderedText) + " ET Q EMC";
    }
  }, {
    key: "_splitLine",
    value: function _splitLine(line, font, fontSize, width) {
      line = font.encodeString(line).join("");
      var glyphs = font.charsToGlyphs(line);

      if (glyphs.length <= 1) {
        return [line];
      }

      var positions = font.getCharPositions(line);
      var scale = fontSize / 1000;
      var chunks = [];
      var lastSpacePosInStringStart = -1,
          lastSpacePosInStringEnd = -1,
          lastSpacePos = -1,
          startChunk = 0,
          currentWidth = 0;

      for (var i = 0, ii = glyphs.length; i < ii; i++) {
        var _positions$i = _slicedToArray(positions[i], 2),
            start = _positions$i[0],
            end = _positions$i[1];

        var glyph = glyphs[i];
        var glyphWidth = glyph.width * scale;

        if (glyph.unicode === " ") {
          if (currentWidth + glyphWidth > width) {
            chunks.push(line.substring(startChunk, start));
            startChunk = start;
            currentWidth = glyphWidth;
            lastSpacePosInStringStart = -1;
            lastSpacePos = -1;
          } else {
            currentWidth += glyphWidth;
            lastSpacePosInStringStart = start;
            lastSpacePosInStringEnd = end;
            lastSpacePos = i;
          }
        } else {
          if (currentWidth + glyphWidth > width) {
            if (lastSpacePosInStringStart !== -1) {
              chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
              startChunk = lastSpacePosInStringEnd;
              i = lastSpacePos + 1;
              lastSpacePosInStringStart = -1;
              currentWidth = 0;
            } else {
              chunks.push(line.substring(startChunk, start));
              startChunk = start;
              currentWidth = glyphWidth;
            }
          } else {
            currentWidth += glyphWidth;
          }
        }
      }

      if (startChunk < line.length) {
        chunks.push(line.substring(startChunk, line.length));
      }

      return chunks;
    }
  }, {
    key: "getFieldObject",
    value: function getFieldObject() {
      return {
        id: this.data.id,
        value: this.data.fieldValue,
        defaultValue: this.data.defaultFieldValue,
        multiline: this.data.multiLine,
        password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
        charLimit: this.data.maxLen,
        comb: this.data.comb,
        editable: !this.data.readOnly,
        hidden: this.data.hidden,
        name: this.data.fieldName,
        rect: this.data.rect,
        actions: this.data.actions,
        type: "text"
      };
    }
  }]);

  return TextWidgetAnnotation;
}(WidgetAnnotation);

var ButtonWidgetAnnotation = /*#__PURE__*/function (_WidgetAnnotation2) {
  _inherits(ButtonWidgetAnnotation, _WidgetAnnotation2);

  var _super4 = _createSuper(ButtonWidgetAnnotation);

  function ButtonWidgetAnnotation(params) {
    var _this7;

    _classCallCheck(this, ButtonWidgetAnnotation);

    _this7 = _super4.call(this, params);
    _this7.checkedAppearance = null;
    _this7.uncheckedAppearance = null;
    _this7.data.checkBox = !_this7.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !_this7.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    _this7.data.radioButton = _this7.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !_this7.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    _this7.data.pushButton = _this7.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    _this7.data.isTooltipOnly = false;

    if (_this7.data.checkBox) {
      _this7._processCheckBox(params);
    } else if (_this7.data.radioButton) {
      _this7._processRadioButton(params);
    } else if (_this7.data.pushButton) {
      _this7._processPushButton(params);
    } else {
      (0, _util.warn)("Invalid field flags for button widget annotation");
    }

    return _this7;
  }

  _createClass(ButtonWidgetAnnotation, [{
    key: "getOperatorList",
    value: function getOperatorList(evaluator, task, renderForms, annotationStorage) {
      if (this.data.pushButton) {
        return _get(_getPrototypeOf(ButtonWidgetAnnotation.prototype), "getOperatorList", this).call(this, evaluator, task, false, annotationStorage);
      }

      if (annotationStorage) {
        var value = annotationStorage[this.data.id] && annotationStorage[this.data.id].value;

        if (value === undefined) {
          return _get(_getPrototypeOf(ButtonWidgetAnnotation.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms, annotationStorage);
        }

        var appearance;

        if (value) {
          appearance = this.checkedAppearance;
        } else {
          appearance = this.uncheckedAppearance;
        }

        if (appearance) {
          var savedAppearance = this.appearance;
          this.appearance = appearance;

          var operatorList = _get(_getPrototypeOf(ButtonWidgetAnnotation.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms, annotationStorage);

          this.appearance = savedAppearance;
          return operatorList;
        }

        return Promise.resolve(new _operator_list.OperatorList());
      }

      return _get(_getPrototypeOf(ButtonWidgetAnnotation.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms, annotationStorage);
    }
  }, {
    key: "save",
    value: function () {
      var _save3 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5(evaluator, task, annotationStorage) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.data.checkBox) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", this._saveCheckbox(evaluator, task, annotationStorage));

              case 2:
                if (!this.data.radioButton) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("return", this._saveRadioButton(evaluator, task, annotationStorage));

              case 4:
                return _context5.abrupt("return", null);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function save(_x12, _x13, _x14) {
        return _save3.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "_saveCheckbox",
    value: function () {
      var _saveCheckbox2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6(evaluator, task, annotationStorage) {
        var value, defaultValue, dict, xfa, name, encrypt, originalTransform, buffer;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                value = annotationStorage[this.data.id] && annotationStorage[this.data.id].value;

                if (!(value === undefined)) {
                  _context6.next = 3;
                  break;
                }

                return _context6.abrupt("return", null);

              case 3:
                defaultValue = this.data.fieldValue && this.data.fieldValue !== "Off";

                if (!(defaultValue === value)) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", null);

              case 6:
                dict = evaluator.xref.fetchIfRef(this.ref);

                if ((0, _primitives.isDict)(dict)) {
                  _context6.next = 9;
                  break;
                }

                return _context6.abrupt("return", null);

              case 9:
                xfa = {
                  path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                  value: value ? this.data.exportValue : ""
                };
                name = _primitives.Name.get(value ? this.data.exportValue : "Off");
                dict.set("V", name);
                dict.set("AS", name);
                dict.set("M", "D:".concat((0, _util.getModificationDate)()));
                encrypt = evaluator.xref.encrypt;
                originalTransform = null;

                if (encrypt) {
                  originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                }

                buffer = ["".concat(this.ref.num, " ").concat(this.ref.gen, " obj\n")];
                (0, _writer.writeDict)(dict, buffer, originalTransform);
                buffer.push("\nendobj\n");
                return _context6.abrupt("return", [{
                  ref: this.ref,
                  data: buffer.join(""),
                  xfa: xfa
                }]);

              case 21:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _saveCheckbox(_x15, _x16, _x17) {
        return _saveCheckbox2.apply(this, arguments);
      }

      return _saveCheckbox;
    }()
  }, {
    key: "_saveRadioButton",
    value: function () {
      var _saveRadioButton2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(evaluator, task, annotationStorage) {
        var value, defaultValue, dict, xfa, name, parentBuffer, encrypt, parent, parentTransform, originalTransform, buffer, newRefs;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                value = annotationStorage[this.data.id] && annotationStorage[this.data.id].value;

                if (!(value === undefined)) {
                  _context7.next = 3;
                  break;
                }

                return _context7.abrupt("return", null);

              case 3:
                defaultValue = this.data.fieldValue === this.data.buttonValue;

                if (!(defaultValue === value)) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return", null);

              case 6:
                dict = evaluator.xref.fetchIfRef(this.ref);

                if ((0, _primitives.isDict)(dict)) {
                  _context7.next = 9;
                  break;
                }

                return _context7.abrupt("return", null);

              case 9:
                xfa = {
                  path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                  value: value ? this.data.buttonValue : ""
                };
                name = _primitives.Name.get(value ? this.data.buttonValue : "Off");
                parentBuffer = null;
                encrypt = evaluator.xref.encrypt;

                if (value) {
                  if ((0, _primitives.isRef)(this.parent)) {
                    parent = evaluator.xref.fetch(this.parent);
                    parentTransform = null;

                    if (encrypt) {
                      parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen);
                    }

                    parent.set("V", name);
                    parentBuffer = ["".concat(this.parent.num, " ").concat(this.parent.gen, " obj\n")];
                    (0, _writer.writeDict)(parent, parentBuffer, parentTransform);
                    parentBuffer.push("\nendobj\n");
                  } else if ((0, _primitives.isDict)(this.parent)) {
                    this.parent.set("V", name);
                  }
                }

                dict.set("AS", name);
                dict.set("M", "D:".concat((0, _util.getModificationDate)()));
                originalTransform = null;

                if (encrypt) {
                  originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                }

                buffer = ["".concat(this.ref.num, " ").concat(this.ref.gen, " obj\n")];
                (0, _writer.writeDict)(dict, buffer, originalTransform);
                buffer.push("\nendobj\n");
                newRefs = [{
                  ref: this.ref,
                  data: buffer.join(""),
                  xfa: xfa
                }];

                if (parentBuffer !== null) {
                  newRefs.push({
                    ref: this.parent,
                    data: parentBuffer.join(""),
                    xfa: null
                  });
                }

                return _context7.abrupt("return", newRefs);

              case 24:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _saveRadioButton(_x18, _x19, _x20) {
        return _saveRadioButton2.apply(this, arguments);
      }

      return _saveRadioButton;
    }()
  }, {
    key: "_processCheckBox",
    value: function _processCheckBox(params) {
      var customAppearance = params.dict.get("AP");

      if (!(0, _primitives.isDict)(customAppearance)) {
        return;
      }

      var normalAppearance = customAppearance.get("N");

      if (!(0, _primitives.isDict)(normalAppearance)) {
        return;
      }

      var exportValues = normalAppearance.getKeys();

      if (!exportValues.includes("Off")) {
        exportValues.push("Off");
      }

      if (exportValues.length !== 2) {
        return;
      }

      this.data.exportValue = exportValues[0] === "Off" ? exportValues[1] : exportValues[0];
      this.checkedAppearance = normalAppearance.get(this.data.exportValue);
      this.uncheckedAppearance = normalAppearance.get("Off") || null;

      this._streams.push(this.checkedAppearance);

      if (this.uncheckedAppearance) {
        this._streams.push(this.uncheckedAppearance);
      }

      this._fallbackFontDict = this.fallbackFontDict;
    }
  }, {
    key: "_processRadioButton",
    value: function _processRadioButton(params) {
      this.data.fieldValue = this.data.buttonValue = null;
      var fieldParent = params.dict.get("Parent");

      if ((0, _primitives.isDict)(fieldParent)) {
        this.parent = params.dict.getRaw("Parent");
        var fieldParentValue = fieldParent.get("V");

        if ((0, _primitives.isName)(fieldParentValue)) {
          this.data.fieldValue = this._decodeFormValue(fieldParentValue);
        }
      }

      var appearanceStates = params.dict.get("AP");

      if (!(0, _primitives.isDict)(appearanceStates)) {
        return;
      }

      var normalAppearance = appearanceStates.get("N");

      if (!(0, _primitives.isDict)(normalAppearance)) {
        return;
      }

      var _iterator8 = _createForOfIteratorHelper(normalAppearance.getKeys()),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var key = _step8.value;

          if (key !== "Off") {
            this.data.buttonValue = this._decodeFormValue(key);
            break;
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      this.checkedAppearance = normalAppearance.get(this.data.buttonValue);
      this.uncheckedAppearance = normalAppearance.get("Off") || null;

      this._streams.push(this.checkedAppearance);

      if (this.uncheckedAppearance) {
        this._streams.push(this.uncheckedAppearance);
      }

      this._fallbackFontDict = this.fallbackFontDict;
    }
  }, {
    key: "_processPushButton",
    value: function _processPushButton(params) {
      if (!params.dict.has("A") && !params.dict.has("AA") && !this.data.alternativeText) {
        (0, _util.warn)("Push buttons without action dictionaries are not supported");
        return;
      }

      this.data.isTooltipOnly = !params.dict.has("A") && !params.dict.has("AA");

      _obj.Catalog.parseDestDictionary({
        destDict: params.dict,
        resultObj: this.data,
        docBaseUrl: params.pdfManager.docBaseUrl
      });
    }
  }, {
    key: "getFieldObject",
    value: function getFieldObject() {
      var type = "button";
      var exportValues;

      if (this.data.checkBox) {
        type = "checkbox";
        exportValues = this.data.exportValue;
      } else if (this.data.radioButton) {
        type = "radiobutton";
        exportValues = this.data.buttonValue;
      }

      return {
        id: this.data.id,
        value: this.data.fieldValue || "Off",
        defaultValue: this.data.defaultFieldValue,
        exportValues: exportValues,
        editable: !this.data.readOnly,
        name: this.data.fieldName,
        rect: this.data.rect,
        hidden: this.data.hidden,
        actions: this.data.actions,
        type: type
      };
    }
  }, {
    key: "fallbackFontDict",
    get: function get() {
      var dict = new _primitives.Dict();
      dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
      dict.set("Type", _primitives.Name.get("FallbackType"));
      dict.set("Subtype", _primitives.Name.get("FallbackType"));
      dict.set("Encoding", _primitives.Name.get("ZapfDingbatsEncoding"));
      return (0, _util.shadow)(this, "fallbackFontDict", dict);
    }
  }]);

  return ButtonWidgetAnnotation;
}(WidgetAnnotation);

var ChoiceWidgetAnnotation = /*#__PURE__*/function (_WidgetAnnotation3) {
  _inherits(ChoiceWidgetAnnotation, _WidgetAnnotation3);

  var _super5 = _createSuper(ChoiceWidgetAnnotation);

  function ChoiceWidgetAnnotation(params) {
    var _this8;

    _classCallCheck(this, ChoiceWidgetAnnotation);

    _this8 = _super5.call(this, params);
    _this8.data.options = [];
    var options = (0, _core_utils.getInheritableProperty)({
      dict: params.dict,
      key: "Opt"
    });

    if (Array.isArray(options)) {
      var xref = params.xref;

      for (var i = 0, ii = options.length; i < ii; i++) {
        var option = xref.fetchIfRef(options[i]);
        var isOptionArray = Array.isArray(option);
        _this8.data.options[i] = {
          exportValue: _this8._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
          displayValue: _this8._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
        };
      }
    }

    if ((0, _util.isString)(_this8.data.fieldValue)) {
      _this8.data.fieldValue = [_this8.data.fieldValue];
    } else if (!_this8.data.fieldValue) {
      _this8.data.fieldValue = [];
    }

    _this8.data.combo = _this8.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
    _this8.data.multiSelect = _this8.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
    _this8._hasText = true;
    return _this8;
  }

  _createClass(ChoiceWidgetAnnotation, [{
    key: "getFieldObject",
    value: function getFieldObject() {
      var type = this.data.combo ? "combobox" : "listbox";
      var value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
      return {
        id: this.data.id,
        value: value,
        defaultValue: this.data.defaultFieldValue,
        editable: !this.data.readOnly,
        name: this.data.fieldName,
        rect: this.data.rect,
        numItems: this.data.fieldValue.length,
        multipleSelection: this.data.multiSelect,
        hidden: this.data.hidden,
        actions: this.data.actions,
        items: this.data.options,
        type: type
      };
    }
  }]);

  return ChoiceWidgetAnnotation;
}(WidgetAnnotation);

var TextAnnotation = /*#__PURE__*/function (_MarkupAnnotation) {
  _inherits(TextAnnotation, _MarkupAnnotation);

  var _super6 = _createSuper(TextAnnotation);

  function TextAnnotation(parameters) {
    var _this9;

    _classCallCheck(this, TextAnnotation);

    var DEFAULT_ICON_SIZE = 22;
    _this9 = _super6.call(this, parameters);
    var dict = parameters.dict;
    _this9.data.annotationType = _util.AnnotationType.TEXT;

    if (_this9.data.hasAppearance) {
      _this9.data.name = "NoIcon";
    } else {
      _this9.data.rect[1] = _this9.data.rect[3] - DEFAULT_ICON_SIZE;
      _this9.data.rect[2] = _this9.data.rect[0] + DEFAULT_ICON_SIZE;
      _this9.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
    }

    if (dict.has("State")) {
      _this9.data.state = dict.get("State") || null;
      _this9.data.stateModel = dict.get("StateModel") || null;
    } else {
      _this9.data.state = null;
      _this9.data.stateModel = null;
    }

    return _this9;
  }

  return TextAnnotation;
}(MarkupAnnotation);

var LinkAnnotation = /*#__PURE__*/function (_Annotation3) {
  _inherits(LinkAnnotation, _Annotation3);

  var _super7 = _createSuper(LinkAnnotation);

  function LinkAnnotation(params) {
    var _this10;

    _classCallCheck(this, LinkAnnotation);

    _this10 = _super7.call(this, params);
    _this10.data.annotationType = _util.AnnotationType.LINK;
    var quadPoints = getQuadPoints(params.dict, _this10.rectangle);

    if (quadPoints) {
      _this10.data.quadPoints = quadPoints;
    }

    _obj.Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: _this10.data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });

    return _this10;
  }

  return LinkAnnotation;
}(Annotation);

var PopupAnnotation = /*#__PURE__*/function (_Annotation4) {
  _inherits(PopupAnnotation, _Annotation4);

  var _super8 = _createSuper(PopupAnnotation);

  function PopupAnnotation(parameters) {
    var _this11;

    _classCallCheck(this, PopupAnnotation);

    _this11 = _super8.call(this, parameters);
    _this11.data.annotationType = _util.AnnotationType.POPUP;
    var parentItem = parameters.dict.get("Parent");

    if (!parentItem) {
      (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
      return _possibleConstructorReturn(_this11);
    }

    var parentSubtype = parentItem.get("Subtype");
    _this11.data.parentType = (0, _primitives.isName)(parentSubtype) ? parentSubtype.name : null;
    var rawParent = parameters.dict.getRaw("Parent");
    _this11.data.parentId = (0, _primitives.isRef)(rawParent) ? rawParent.toString() : null;
    var parentRect = parentItem.getArray("Rect");

    if (Array.isArray(parentRect) && parentRect.length === 4) {
      _this11.data.parentRect = _util.Util.normalizeRect(parentRect);
    } else {
      _this11.data.parentRect = [0, 0, 0, 0];
    }

    var rt = parentItem.get("RT");

    if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
      parentItem = parentItem.get("IRT");
    }

    if (!parentItem.has("M")) {
      _this11.data.modificationDate = null;
    } else {
      _this11.setModificationDate(parentItem.get("M"));

      _this11.data.modificationDate = _this11.modificationDate;
    }

    if (!parentItem.has("C")) {
      _this11.data.color = null;
    } else {
      _this11.setColor(parentItem.getArray("C"));

      _this11.data.color = _this11.color;
    }

    if (!_this11.viewable) {
      var parentFlags = parentItem.get("F");

      if (_this11._isViewable(parentFlags)) {
        _this11.setFlags(parentFlags);
      }
    }

    _this11.data.title = (0, _util.stringToPDFString)(parentItem.get("T") || "");
    _this11.data.contents = (0, _util.stringToPDFString)(parentItem.get("Contents") || "");
    return _this11;
  }

  return PopupAnnotation;
}(Annotation);

var FreeTextAnnotation = /*#__PURE__*/function (_MarkupAnnotation2) {
  _inherits(FreeTextAnnotation, _MarkupAnnotation2);

  var _super9 = _createSuper(FreeTextAnnotation);

  function FreeTextAnnotation(parameters) {
    var _this12;

    _classCallCheck(this, FreeTextAnnotation);

    _this12 = _super9.call(this, parameters);
    _this12.data.annotationType = _util.AnnotationType.FREETEXT;
    return _this12;
  }

  return FreeTextAnnotation;
}(MarkupAnnotation);

var LineAnnotation = /*#__PURE__*/function (_MarkupAnnotation3) {
  _inherits(LineAnnotation, _MarkupAnnotation3);

  var _super10 = _createSuper(LineAnnotation);

  function LineAnnotation(parameters) {
    var _this13;

    _classCallCheck(this, LineAnnotation);

    _this13 = _super10.call(this, parameters);
    _this13.data.annotationType = _util.AnnotationType.LINE;
    _this13.data.lineCoordinates = _util.Util.normalizeRect(parameters.dict.getArray("L"));
    return _this13;
  }

  return LineAnnotation;
}(MarkupAnnotation);

var SquareAnnotation = /*#__PURE__*/function (_MarkupAnnotation4) {
  _inherits(SquareAnnotation, _MarkupAnnotation4);

  var _super11 = _createSuper(SquareAnnotation);

  function SquareAnnotation(parameters) {
    var _this14;

    _classCallCheck(this, SquareAnnotation);

    _this14 = _super11.call(this, parameters);
    _this14.data.annotationType = _util.AnnotationType.SQUARE;
    return _this14;
  }

  return SquareAnnotation;
}(MarkupAnnotation);

var CircleAnnotation = /*#__PURE__*/function (_MarkupAnnotation5) {
  _inherits(CircleAnnotation, _MarkupAnnotation5);

  var _super12 = _createSuper(CircleAnnotation);

  function CircleAnnotation(parameters) {
    var _this15;

    _classCallCheck(this, CircleAnnotation);

    _this15 = _super12.call(this, parameters);
    _this15.data.annotationType = _util.AnnotationType.CIRCLE;
    return _this15;
  }

  return CircleAnnotation;
}(MarkupAnnotation);

var PolylineAnnotation = /*#__PURE__*/function (_MarkupAnnotation6) {
  _inherits(PolylineAnnotation, _MarkupAnnotation6);

  var _super13 = _createSuper(PolylineAnnotation);

  function PolylineAnnotation(parameters) {
    var _this16;

    _classCallCheck(this, PolylineAnnotation);

    _this16 = _super13.call(this, parameters);
    _this16.data.annotationType = _util.AnnotationType.POLYLINE;
    _this16.data.vertices = [];
    var rawVertices = parameters.dict.getArray("Vertices");

    if (!Array.isArray(rawVertices)) {
      return _possibleConstructorReturn(_this16);
    }

    for (var i = 0, ii = rawVertices.length; i < ii; i += 2) {
      _this16.data.vertices.push({
        x: rawVertices[i],
        y: rawVertices[i + 1]
      });
    }

    return _this16;
  }

  return PolylineAnnotation;
}(MarkupAnnotation);

var PolygonAnnotation = /*#__PURE__*/function (_PolylineAnnotation) {
  _inherits(PolygonAnnotation, _PolylineAnnotation);

  var _super14 = _createSuper(PolygonAnnotation);

  function PolygonAnnotation(parameters) {
    var _this17;

    _classCallCheck(this, PolygonAnnotation);

    _this17 = _super14.call(this, parameters);
    _this17.data.annotationType = _util.AnnotationType.POLYGON;
    return _this17;
  }

  return PolygonAnnotation;
}(PolylineAnnotation);

var CaretAnnotation = /*#__PURE__*/function (_MarkupAnnotation7) {
  _inherits(CaretAnnotation, _MarkupAnnotation7);

  var _super15 = _createSuper(CaretAnnotation);

  function CaretAnnotation(parameters) {
    var _this18;

    _classCallCheck(this, CaretAnnotation);

    _this18 = _super15.call(this, parameters);
    _this18.data.annotationType = _util.AnnotationType.CARET;
    return _this18;
  }

  return CaretAnnotation;
}(MarkupAnnotation);

var InkAnnotation = /*#__PURE__*/function (_MarkupAnnotation8) {
  _inherits(InkAnnotation, _MarkupAnnotation8);

  var _super16 = _createSuper(InkAnnotation);

  function InkAnnotation(parameters) {
    var _this19;

    _classCallCheck(this, InkAnnotation);

    _this19 = _super16.call(this, parameters);
    _this19.data.annotationType = _util.AnnotationType.INK;
    _this19.data.inkLists = [];
    var rawInkLists = parameters.dict.getArray("InkList");

    if (!Array.isArray(rawInkLists)) {
      return _possibleConstructorReturn(_this19);
    }

    var xref = parameters.xref;

    for (var i = 0, ii = rawInkLists.length; i < ii; ++i) {
      _this19.data.inkLists.push([]);

      for (var j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
        _this19.data.inkLists[i].push({
          x: xref.fetchIfRef(rawInkLists[i][j]),
          y: xref.fetchIfRef(rawInkLists[i][j + 1])
        });
      }
    }

    return _this19;
  }

  return InkAnnotation;
}(MarkupAnnotation);

var HighlightAnnotation = /*#__PURE__*/function (_MarkupAnnotation9) {
  _inherits(HighlightAnnotation, _MarkupAnnotation9);

  var _super17 = _createSuper(HighlightAnnotation);

  function HighlightAnnotation(parameters) {
    var _this20;

    _classCallCheck(this, HighlightAnnotation);

    _this20 = _super17.call(this, parameters);
    _this20.data.annotationType = _util.AnnotationType.HIGHLIGHT;
    var quadPoints = _this20.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!_this20.appearance) {
        var fillColor = _this20.color ? Array.from(_this20.color).map(function (c) {
          return c / 255;
        }) : [1, 1, 0];

        _this20._setDefaultAppearance({
          xref: parameters.xref,
          fillColor: fillColor,
          blendMode: "Multiply",
          pointsCallback: function pointsCallback(buffer, points) {
            buffer.push("".concat(points[0].x, " ").concat(points[0].y, " m"));
            buffer.push("".concat(points[1].x, " ").concat(points[1].y, " l"));
            buffer.push("".concat(points[3].x, " ").concat(points[3].y, " l"));
            buffer.push("".concat(points[2].x, " ").concat(points[2].y, " l"));
            buffer.push("f");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      _this20.data.hasPopup = false;
    }

    return _this20;
  }

  return HighlightAnnotation;
}(MarkupAnnotation);

var UnderlineAnnotation = /*#__PURE__*/function (_MarkupAnnotation10) {
  _inherits(UnderlineAnnotation, _MarkupAnnotation10);

  var _super18 = _createSuper(UnderlineAnnotation);

  function UnderlineAnnotation(parameters) {
    var _this21;

    _classCallCheck(this, UnderlineAnnotation);

    _this21 = _super18.call(this, parameters);
    _this21.data.annotationType = _util.AnnotationType.UNDERLINE;
    var quadPoints = _this21.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!_this21.appearance) {
        var strokeColor = _this21.color ? Array.from(_this21.color).map(function (c) {
          return c / 255;
        }) : [0, 0, 0];

        _this21._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor: strokeColor,
          pointsCallback: function pointsCallback(buffer, points) {
            buffer.push("".concat(points[2].x, " ").concat(points[2].y, " m"));
            buffer.push("".concat(points[3].x, " ").concat(points[3].y, " l"));
            buffer.push("S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      _this21.data.hasPopup = false;
    }

    return _this21;
  }

  return UnderlineAnnotation;
}(MarkupAnnotation);

var SquigglyAnnotation = /*#__PURE__*/function (_MarkupAnnotation11) {
  _inherits(SquigglyAnnotation, _MarkupAnnotation11);

  var _super19 = _createSuper(SquigglyAnnotation);

  function SquigglyAnnotation(parameters) {
    var _this22;

    _classCallCheck(this, SquigglyAnnotation);

    _this22 = _super19.call(this, parameters);
    _this22.data.annotationType = _util.AnnotationType.SQUIGGLY;
    var quadPoints = _this22.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!_this22.appearance) {
        var strokeColor = _this22.color ? Array.from(_this22.color).map(function (c) {
          return c / 255;
        }) : [0, 0, 0];

        _this22._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor: strokeColor,
          pointsCallback: function pointsCallback(buffer, points) {
            var dy = (points[0].y - points[2].y) / 6;
            var shift = dy;
            var x = points[2].x;
            var y = points[2].y;
            var xEnd = points[3].x;
            buffer.push("".concat(x, " ").concat(y + shift, " m"));

            do {
              x += 2;
              shift = shift === 0 ? dy : 0;
              buffer.push("".concat(x, " ").concat(y + shift, " l"));
            } while (x < xEnd);

            buffer.push("S");
            return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
          }
        });
      }
    } else {
      _this22.data.hasPopup = false;
    }

    return _this22;
  }

  return SquigglyAnnotation;
}(MarkupAnnotation);

var StrikeOutAnnotation = /*#__PURE__*/function (_MarkupAnnotation12) {
  _inherits(StrikeOutAnnotation, _MarkupAnnotation12);

  var _super20 = _createSuper(StrikeOutAnnotation);

  function StrikeOutAnnotation(parameters) {
    var _this23;

    _classCallCheck(this, StrikeOutAnnotation);

    _this23 = _super20.call(this, parameters);
    _this23.data.annotationType = _util.AnnotationType.STRIKEOUT;
    var quadPoints = _this23.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!_this23.appearance) {
        var strokeColor = _this23.color ? Array.from(_this23.color).map(function (c) {
          return c / 255;
        }) : [0, 0, 0];

        _this23._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor: strokeColor,
          pointsCallback: function pointsCallback(buffer, points) {
            buffer.push("".concat((points[0].x + points[2].x) / 2) + " ".concat((points[0].y + points[2].y) / 2, " m"));
            buffer.push("".concat((points[1].x + points[3].x) / 2) + " ".concat((points[1].y + points[3].y) / 2, " l"));
            buffer.push("S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      _this23.data.hasPopup = false;
    }

    return _this23;
  }

  return StrikeOutAnnotation;
}(MarkupAnnotation);

var StampAnnotation = /*#__PURE__*/function (_MarkupAnnotation13) {
  _inherits(StampAnnotation, _MarkupAnnotation13);

  var _super21 = _createSuper(StampAnnotation);

  function StampAnnotation(parameters) {
    var _this24;

    _classCallCheck(this, StampAnnotation);

    _this24 = _super21.call(this, parameters);
    _this24.data.annotationType = _util.AnnotationType.STAMP;
    return _this24;
  }

  return StampAnnotation;
}(MarkupAnnotation);

var FileAttachmentAnnotation = /*#__PURE__*/function (_MarkupAnnotation14) {
  _inherits(FileAttachmentAnnotation, _MarkupAnnotation14);

  var _super22 = _createSuper(FileAttachmentAnnotation);

  function FileAttachmentAnnotation(parameters) {
    var _this25;

    _classCallCheck(this, FileAttachmentAnnotation);

    _this25 = _super22.call(this, parameters);
    var file = new _obj.FileSpec(parameters.dict.get("FS"), parameters.xref);
    _this25.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
    _this25.data.file = file.serializable;
    return _this25;
  }

  return FileAttachmentAnnotation;
}(MarkupAnnotation);

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createDefaultAppearance = createDefaultAppearance;
exports.parseDefaultAppearance = parseDefaultAppearance;

var _primitives = __w_pdfjs_require__(135);

var _util = __w_pdfjs_require__(4);

var _colorspace = __w_pdfjs_require__(153);

var _core_utils = __w_pdfjs_require__(138);

var _evaluator = __w_pdfjs_require__(157);

var _stream = __w_pdfjs_require__(142);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var DefaultAppearanceEvaluator = /*#__PURE__*/function (_EvaluatorPreprocesso) {
  _inherits(DefaultAppearanceEvaluator, _EvaluatorPreprocesso);

  var _super = _createSuper(DefaultAppearanceEvaluator);

  function DefaultAppearanceEvaluator(str) {
    _classCallCheck(this, DefaultAppearanceEvaluator);

    return _super.call(this, new _stream.StringStream(str));
  }

  _createClass(DefaultAppearanceEvaluator, [{
    key: "parse",
    value: function parse() {
      var operation = {
        fn: 0,
        args: []
      };
      var result = {
        fontSize: 0,
        fontName: _primitives.Name.get(""),
        fontColor: new Uint8ClampedArray([0, 0, 0])
      };

      try {
        while (true) {
          operation.args.length = 0;

          if (!this.read(operation)) {
            break;
          }

          if (this.savedStatesDepth !== 0) {
            continue;
          }

          var fn = operation.fn,
              args = operation.args;

          switch (fn | 0) {
            case _util.OPS.setFont:
              var _args = _slicedToArray(args, 2),
                  fontName = _args[0],
                  fontSize = _args[1];

              if ((0, _primitives.isName)(fontName)) {
                result.fontName = fontName;
              }

              if (typeof fontSize === "number" && fontSize > 0) {
                result.fontSize = fontSize;
              }

              break;

            case _util.OPS.setFillRGBColor:
              _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);

              break;

            case _util.OPS.setFillGray:
              _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);

              break;

            case _util.OPS.setFillColorSpace:
              _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);

              break;
          }
        }
      } catch (reason) {
        (0, _util.warn)("parseDefaultAppearance - ignoring errors: \"".concat(reason, "\"."));
      }

      return result;
    }
  }]);

  return DefaultAppearanceEvaluator;
}(_evaluator.EvaluatorPreprocessor);

function parseDefaultAppearance(str) {
  return new DefaultAppearanceEvaluator(str).parse();
}

function createDefaultAppearance(_ref) {
  var fontSize = _ref.fontSize,
      fontName = _ref.fontName,
      fontColor = _ref.fontColor;
  var colorCmd;

  if (fontColor.every(function (c) {
    return c === 0;
  })) {
    colorCmd = "0 g";
  } else {
    colorCmd = Array.from(fontColor).map(function (c) {
      return (c / 255).toFixed(2);
    }).join(" ") + " rg";
  }

  return "/".concat((0, _core_utils.escapePDFName)(fontName.name), " ").concat(fontSize, " Tf ").concat(colorCmd);
}

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PartialEvaluator = exports.EvaluatorPreprocessor = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _cmap = __w_pdfjs_require__(158);

var _primitives = __w_pdfjs_require__(135);

var _stream = __w_pdfjs_require__(142);

var _fonts = __w_pdfjs_require__(159);

var _encodings = __w_pdfjs_require__(162);

var _core_utils = __w_pdfjs_require__(138);

var _unicode = __w_pdfjs_require__(165);

var _standard_fonts = __w_pdfjs_require__(164);

var _pattern = __w_pdfjs_require__(168);

var _function = __w_pdfjs_require__(169);

var _parser = __w_pdfjs_require__(141);

var _image_utils = __w_pdfjs_require__(154);

var _bidi = __w_pdfjs_require__(171);

var _colorspace = __w_pdfjs_require__(153);

var _glyphlist = __w_pdfjs_require__(163);

var _metrics = __w_pdfjs_require__(172);

var _murmurhash = __w_pdfjs_require__(173);

var _operator_list = __w_pdfjs_require__(174);

var _image = __w_pdfjs_require__(175);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DefaultPartialEvaluatorOptions = Object.freeze({
  maxImageSize: -1,
  disableFontFace: false,
  ignoreErrors: false,
  isEvalSupported: true,
  fontExtraProperties: false
});
var PatternType = {
  TILING: 1,
  SHADING: 2
};
var deferred = Promise.resolve();

function normalizeBlendMode(value) {
  var parsingArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (Array.isArray(value)) {
    for (var i = 0, ii = value.length; i < ii; i++) {
      var maybeBM = normalizeBlendMode(value[i], true);

      if (maybeBM) {
        return maybeBM;
      }
    }

    (0, _util.warn)("Unsupported blend mode Array: ".concat(value));
    return "source-over";
  }

  if (!(0, _primitives.isName)(value)) {
    if (parsingArray) {
      return null;
    }

    return "source-over";
  }

  switch (value.name) {
    case "Normal":
    case "Compatible":
      return "source-over";

    case "Multiply":
      return "multiply";

    case "Screen":
      return "screen";

    case "Overlay":
      return "overlay";

    case "Darken":
      return "darken";

    case "Lighten":
      return "lighten";

    case "ColorDodge":
      return "color-dodge";

    case "ColorBurn":
      return "color-burn";

    case "HardLight":
      return "hard-light";

    case "SoftLight":
      return "soft-light";

    case "Difference":
      return "difference";

    case "Exclusion":
      return "exclusion";

    case "Hue":
      return "hue";

    case "Saturation":
      return "saturation";

    case "Color":
      return "color";

    case "Luminosity":
      return "luminosity";
  }

  if (parsingArray) {
    return null;
  }

  (0, _util.warn)("Unsupported blend mode: ".concat(value.name));
  return "source-over";
}

var TimeSlotManager = /*#__PURE__*/function () {
  function TimeSlotManager() {
    _classCallCheck(this, TimeSlotManager);

    this.reset();
  }

  _createClass(TimeSlotManager, [{
    key: "check",
    value: function check() {
      if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
        return false;
      }

      this.checked = 0;
      return this.endTime <= Date.now();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
      this.checked = 0;
    }
  }], [{
    key: "TIME_SLOT_DURATION_MS",
    get: function get() {
      return (0, _util.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
    }
  }, {
    key: "CHECK_TIME_EVERY",
    get: function get() {
      return (0, _util.shadow)(this, "CHECK_TIME_EVERY", 100);
    }
  }]);

  return TimeSlotManager;
}();

var PartialEvaluator = /*#__PURE__*/function () {
  function PartialEvaluator(_ref) {
    var xref = _ref.xref,
        handler = _ref.handler,
        pageIndex = _ref.pageIndex,
        idFactory = _ref.idFactory,
        fontCache = _ref.fontCache,
        builtInCMapCache = _ref.builtInCMapCache,
        globalImageCache = _ref.globalImageCache,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? null : _ref$options;

    _classCallCheck(this, PartialEvaluator);

    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.globalImageCache = globalImageCache;
    this.options = options || DefaultPartialEvaluatorOptions;
    this.parsingType3Font = false;
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }

  _createClass(PartialEvaluator, [{
    key: "_pdfFunctionFactory",
    get: function get() {
      var pdfFunctionFactory = new _function.PDFFunctionFactory({
        xref: this.xref,
        isEvalSupported: this.options.isEvalSupported
      });
      return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
    }
  }, {
    key: "clone",
    value: function clone() {
      var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultPartialEvaluatorOptions;
      var newEvaluator = Object.create(this);
      newEvaluator.options = newOptions;
      return newEvaluator;
    }
  }, {
    key: "hasBlendModes",
    value: function hasBlendModes(resources, nonBlendModesSet) {
      if (!(resources instanceof _primitives.Dict)) {
        return false;
      }

      if (resources.objId && nonBlendModesSet.has(resources.objId)) {
        return false;
      }

      var processed = new _primitives.RefSet(nonBlendModesSet);

      if (resources.objId) {
        processed.put(resources.objId);
      }

      var nodes = [resources],
          xref = this.xref;

      while (nodes.length) {
        var node = nodes.shift();
        var graphicStates = node.get("ExtGState");

        if (graphicStates instanceof _primitives.Dict) {
          var _iterator = _createForOfIteratorHelper(graphicStates.getRawValues()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var graphicState = _step.value;

              if (graphicState instanceof _primitives.Ref) {
                if (processed.has(graphicState)) {
                  continue;
                }

                try {
                  graphicState = xref.fetch(graphicState);
                } catch (ex) {
                  if (ex instanceof _core_utils.MissingDataException) {
                    throw ex;
                  }

                  processed.put(graphicState);
                  (0, _util.info)("hasBlendModes - ignoring ExtGState: \"".concat(ex, "\"."));
                  continue;
                }
              }

              if (!(graphicState instanceof _primitives.Dict)) {
                continue;
              }

              if (graphicState.objId) {
                processed.put(graphicState.objId);
              }

              var bm = graphicState.get("BM");

              if (bm instanceof _primitives.Name) {
                if (bm.name !== "Normal") {
                  return true;
                }

                continue;
              }

              if (bm !== undefined && Array.isArray(bm)) {
                var _iterator2 = _createForOfIteratorHelper(bm),
                    _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var element = _step2.value;

                    if (element instanceof _primitives.Name && element.name !== "Normal") {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        var xObjects = node.get("XObject");

        if (!(xObjects instanceof _primitives.Dict)) {
          continue;
        }

        var _iterator3 = _createForOfIteratorHelper(xObjects.getRawValues()),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var xObject = _step3.value;

            if (xObject instanceof _primitives.Ref) {
              if (processed.has(xObject)) {
                continue;
              }

              try {
                xObject = xref.fetch(xObject);
              } catch (ex) {
                if (ex instanceof _core_utils.MissingDataException) {
                  throw ex;
                }

                processed.put(xObject);
                (0, _util.info)("hasBlendModes - ignoring XObject: \"".concat(ex, "\"."));
                continue;
              }
            }

            if (!(0, _primitives.isStream)(xObject)) {
              continue;
            }

            if (xObject.dict.objId) {
              processed.put(xObject.dict.objId);
            }

            var xResources = xObject.dict.get("Resources");

            if (!(xResources instanceof _primitives.Dict)) {
              continue;
            }

            if (xResources.objId && processed.has(xResources.objId)) {
              continue;
            }

            nodes.push(xResources);

            if (xResources.objId) {
              processed.put(xResources.objId);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      processed.forEach(function (ref) {
        nonBlendModesSet.put(ref);
      });
      return false;
    }
  }, {
    key: "fetchBuiltInCMap",
    value: function () {
      var _fetchBuiltInCMap = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(name) {
        var cachedData, readableStream, reader, data;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cachedData = this.builtInCMapCache.get(name);

                if (!cachedData) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", cachedData);

              case 3:
                readableStream = this.handler.sendWithStream("FetchBuiltInCMap", {
                  name: name
                });
                reader = readableStream.getReader();
                _context.next = 7;
                return new Promise(function (resolve, reject) {
                  function pump() {
                    reader.read().then(function (_ref2) {
                      var value = _ref2.value,
                          done = _ref2.done;

                      if (done) {
                        return;
                      }

                      resolve(value);
                      pump();
                    }, reject);
                  }

                  pump();
                });

              case 7:
                data = _context.sent;

                if (data.compressionType !== _util.CMapCompressionType.NONE) {
                  this.builtInCMapCache.set(name, data);
                }

                return _context.abrupt("return", data);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchBuiltInCMap(_x) {
        return _fetchBuiltInCMap.apply(this, arguments);
      }

      return fetchBuiltInCMap;
    }()
  }, {
    key: "buildFormXObject",
    value: function () {
      var _buildFormXObject = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
        var dict, matrix, bbox, optionalContent, group, groupOptions, groupSubtype, colorSpace, cs, cachedColorSpace;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dict = xobj.dict;
                matrix = dict.getArray("Matrix");
                bbox = dict.getArray("BBox");

                if (Array.isArray(bbox) && bbox.length === 4) {
                  bbox = _util.Util.normalizeRect(bbox);
                } else {
                  bbox = null;
                }

                optionalContent = null;

                if (!dict.has("OC")) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 8;
                return this.parseMarkedContentProps(dict.get("OC"), resources);

              case 8:
                optionalContent = _context2.sent;
                operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);

              case 10:
                group = dict.get("Group");

                if (!group) {
                  _context2.next = 30;
                  break;
                }

                groupOptions = {
                  matrix: matrix,
                  bbox: bbox,
                  smask: smask,
                  isolated: false,
                  knockout: false
                };
                groupSubtype = group.get("S");
                colorSpace = null;

                if (!(0, _primitives.isName)(groupSubtype, "Transparency")) {
                  _context2.next = 28;
                  break;
                }

                groupOptions.isolated = group.get("I") || false;
                groupOptions.knockout = group.get("K") || false;

                if (!group.has("CS")) {
                  _context2.next = 28;
                  break;
                }

                cs = group.getRaw("CS");
                cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);

                if (!cachedColorSpace) {
                  _context2.next = 25;
                  break;
                }

                colorSpace = cachedColorSpace;
                _context2.next = 28;
                break;

              case 25:
                _context2.next = 27;
                return this.parseColorSpace({
                  cs: cs,
                  resources: resources,
                  localColorSpaceCache: localColorSpaceCache
                });

              case 27:
                colorSpace = _context2.sent;

              case 28:
                if (smask && smask.backdrop) {
                  colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                  smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                }

                operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);

              case 30:
                operatorList.addOp(_util.OPS.paintFormXObjectBegin, [matrix, bbox]);
                return _context2.abrupt("return", this.getOperatorList({
                  stream: xobj,
                  task: task,
                  resources: dict.get("Resources") || resources,
                  operatorList: operatorList,
                  initialState: initialState
                }).then(function () {
                  operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);

                  if (group) {
                    operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
                  }

                  if (optionalContent) {
                    operatorList.addOp(_util.OPS.endMarkedContent, []);
                  }
                }));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function buildFormXObject(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _buildFormXObject.apply(this, arguments);
      }

      return buildFormXObject;
    }()
  }, {
    key: "_sendImgData",
    value: function _sendImgData(objId, imgData) {
      var cacheGlobally = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var transfers = imgData ? [imgData.data.buffer] : null;

      if (this.parsingType3Font || cacheGlobally) {
        return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
      }

      return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
    }
  }, {
    key: "buildPaintImageXObject",
    value: function () {
      var _buildPaintImageXObject = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref3) {
        var _this = this;

        var resources, image, _ref3$isInline, isInline, operatorList, cacheKey, localImageCache, localColorSpaceCache, dict, imageRef, w, h, maxImageSize, imageMask, imgData, args, width, height, bitStrideLength, imgArray, decode, softMask, mask, SMALL_IMAGE_DIMENSIONS, imageObj, objId, cacheGlobally;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                resources = _ref3.resources, image = _ref3.image, _ref3$isInline = _ref3.isInline, isInline = _ref3$isInline === void 0 ? false : _ref3$isInline, operatorList = _ref3.operatorList, cacheKey = _ref3.cacheKey, localImageCache = _ref3.localImageCache, localColorSpaceCache = _ref3.localColorSpaceCache;
                dict = image.dict;
                imageRef = dict.objId;
                w = dict.get("Width", "W");
                h = dict.get("Height", "H");

                if (!(!(w && (0, _util.isNum)(w)) || !(h && (0, _util.isNum)(h)))) {
                  _context3.next = 8;
                  break;
                }

                (0, _util.warn)("Image dimensions are missing, or not numbers.");
                return _context3.abrupt("return", undefined);

              case 8:
                maxImageSize = this.options.maxImageSize;

                if (!(maxImageSize !== -1 && w * h > maxImageSize)) {
                  _context3.next = 12;
                  break;
                }

                (0, _util.warn)("Image exceeded maximum allowed size and was removed.");
                return _context3.abrupt("return", undefined);

              case 12:
                imageMask = dict.get("ImageMask", "IM") || false;

                if (!imageMask) {
                  _context3.next = 25;
                  break;
                }

                width = dict.get("Width", "W");
                height = dict.get("Height", "H");
                bitStrideLength = width + 7 >> 3;
                imgArray = image.getBytes(bitStrideLength * height, true);
                decode = dict.getArray("Decode", "D");
                imgData = _image.PDFImage.createMask({
                  imgArray: imgArray,
                  width: width,
                  height: height,
                  imageIsFromDecodeStream: image instanceof _stream.DecodeStream,
                  inverseDecode: !!decode && decode[0] > 0
                });
                imgData.cached = !!cacheKey;
                args = [imgData];
                operatorList.addOp(_util.OPS.paintImageMaskXObject, args);

                if (cacheKey) {
                  localImageCache.set(cacheKey, imageRef, {
                    fn: _util.OPS.paintImageMaskXObject,
                    args: args
                  });
                }

                return _context3.abrupt("return", undefined);

              case 25:
                softMask = dict.get("SMask", "SM") || false;
                mask = dict.get("Mask") || false;
                SMALL_IMAGE_DIMENSIONS = 200;

                if (!(isInline && !softMask && !mask && w + h < SMALL_IMAGE_DIMENSIONS)) {
                  _context3.next = 33;
                  break;
                }

                imageObj = new _image.PDFImage({
                  xref: this.xref,
                  res: resources,
                  image: image,
                  isInline: isInline,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: localColorSpaceCache
                });
                imgData = imageObj.createImageData(true);
                operatorList.addOp(_util.OPS.paintInlineImageXObject, [imgData]);
                return _context3.abrupt("return", undefined);

              case 33:
                objId = "img_".concat(this.idFactory.createObjId()), cacheGlobally = false;

                if (this.parsingType3Font) {
                  objId = "".concat(this.idFactory.getDocId(), "_type3_").concat(objId);
                } else if (imageRef) {
                  cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);

                  if (cacheGlobally) {
                    objId = "".concat(this.idFactory.getDocId(), "_").concat(objId);
                  }
                }

                operatorList.addDependency(objId);
                args = [objId, w, h];

                _image.PDFImage.buildImage({
                  xref: this.xref,
                  res: resources,
                  image: image,
                  isInline: isInline,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: localColorSpaceCache
                }).then(function (imageObj) {
                  imgData = imageObj.createImageData(false);

                  if (cacheKey && imageRef && cacheGlobally) {
                    _this.globalImageCache.addByteSize(imageRef, imgData.data.length);
                  }

                  return _this._sendImgData(objId, imgData, cacheGlobally);
                })["catch"](function (reason) {
                  (0, _util.warn)("Unable to decode image \"".concat(objId, "\": \"").concat(reason, "\"."));
                  return _this._sendImgData(objId, null, cacheGlobally);
                });

                operatorList.addOp(_util.OPS.paintImageXObject, args);

                if (cacheKey) {
                  localImageCache.set(cacheKey, imageRef, {
                    fn: _util.OPS.paintImageXObject,
                    args: args
                  });

                  if (imageRef) {
                    (0, _util.assert)(!isInline, "Cannot cache an inline image globally.");
                    this.globalImageCache.addPageIndex(imageRef, this.pageIndex);

                    if (cacheGlobally) {
                      this.globalImageCache.setData(imageRef, {
                        objId: objId,
                        fn: _util.OPS.paintImageXObject,
                        args: args,
                        byteSize: 0
                      });
                    }
                  }
                }

                return _context3.abrupt("return", undefined);

              case 41:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function buildPaintImageXObject(_x9) {
        return _buildPaintImageXObject.apply(this, arguments);
      }

      return buildPaintImageXObject;
    }()
  }, {
    key: "handleSMask",
    value: function handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
      var smaskContent = smask.get("G");
      var smaskOptions = {
        subtype: smask.get("S").name,
        backdrop: smask.get("BC")
      };
      var transferObj = smask.get("TR");

      if ((0, _function.isPDFFunction)(transferObj)) {
        var transferFn = this._pdfFunctionFactory.create(transferObj);

        var transferMap = new Uint8Array(256);
        var tmp = new Float32Array(1);

        for (var i = 0; i < 256; i++) {
          tmp[0] = i / 255;
          transferFn(tmp, 0, tmp, 0);
          transferMap[i] = tmp[0] * 255 | 0;
        }

        smaskOptions.transferMap = transferMap;
      }

      return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
    }
  }, {
    key: "handleTransferFunction",
    value: function handleTransferFunction(tr) {
      var transferArray;

      if (Array.isArray(tr)) {
        transferArray = tr;
      } else if ((0, _function.isPDFFunction)(tr)) {
        transferArray = [tr];
      } else {
        return null;
      }

      var transferMaps = [];
      var numFns = 0,
          numEffectfulFns = 0;

      var _iterator4 = _createForOfIteratorHelper(transferArray),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var entry = _step4.value;
          var transferObj = this.xref.fetchIfRef(entry);
          numFns++;

          if ((0, _primitives.isName)(transferObj, "Identity")) {
            transferMaps.push(null);
            continue;
          } else if (!(0, _function.isPDFFunction)(transferObj)) {
            return null;
          }

          var transferFn = this._pdfFunctionFactory.create(transferObj);

          var transferMap = new Uint8Array(256),
              tmp = new Float32Array(1);

          for (var j = 0; j < 256; j++) {
            tmp[0] = j / 255;
            transferFn(tmp, 0, tmp, 0);
            transferMap[j] = tmp[0] * 255 | 0;
          }

          transferMaps.push(transferMap);
          numEffectfulFns++;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (!(numFns === 1 || numFns === 4)) {
        return null;
      }

      if (numEffectfulFns === 0) {
        return null;
      }

      return transferMaps;
    }
  }, {
    key: "handleTilingType",
    value: function handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, cacheKey, localTilingPatternCache) {
      var _this2 = this;

      var tilingOpList = new _operator_list.OperatorList();

      var patternResources = _primitives.Dict.merge({
        xref: this.xref,
        dictArray: [patternDict.get("Resources"), resources]
      });

      return this.getOperatorList({
        stream: pattern,
        task: task,
        resources: patternResources,
        operatorList: tilingOpList
      }).then(function () {
        var operatorListIR = tilingOpList.getIR();
        var tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
        operatorList.addDependencies(tilingOpList.dependencies);
        operatorList.addOp(fn, tilingPatternIR);

        if (cacheKey) {
          localTilingPatternCache.set(cacheKey, patternDict.objId, {
            operatorListIR: operatorListIR,
            dict: patternDict
          });
        }
      })["catch"](function (reason) {
        if (reason instanceof _util.AbortException) {
          return;
        }

        if (_this2.options.ignoreErrors) {
          _this2.handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorTilingPattern
          });

          (0, _util.warn)("handleTilingType - ignoring pattern: \"".concat(reason, "\"."));
          return;
        }

        throw reason;
      });
    }
  }, {
    key: "handleSetFont",
    value: function handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
      var _this3 = this;

      var fallbackFontDict = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var fontName;

      if (fontArgs) {
        fontArgs = fontArgs.slice();
        fontName = fontArgs[0].name;
      }

      return this.loadFont(fontName, fontRef, resources, fallbackFontDict).then(function (translated) {
        if (!translated.font.isType3Font) {
          return translated;
        }

        return translated.loadType3Data(_this3, resources, task).then(function () {
          operatorList.addDependencies(translated.type3Dependencies);
          return translated;
        })["catch"](function (reason) {
          _this3.handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadType3
          });

          return new TranslatedFont({
            loadedName: "g_font_error",
            font: new _fonts.ErrorFont("Type3 font load error: ".concat(reason)),
            dict: translated.font,
            extraProperties: _this3.options.fontExtraProperties
          });
        });
      }).then(function (translated) {
        state.font = translated.font;
        translated.send(_this3.handler);
        return translated.loadedName;
      });
    }
  }, {
    key: "handleText",
    value: function handleText(chars, state) {
      var font = state.font;
      var glyphs = font.charsToGlyphs(chars);

      if (font.data) {
        var isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);

        if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
          PartialEvaluator.buildFontPaths(font, glyphs, this.handler);
        }
      }

      return glyphs;
    }
  }, {
    key: "ensureStateFont",
    value: function ensureStateFont(state) {
      if (state.font) {
        return;
      }

      var reason = new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");

      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorFontState
        });
        (0, _util.warn)("ensureStateFont: \"".concat(reason, "\"."));
        return;
      }

      throw reason;
    }
  }, {
    key: "setGState",
    value: function () {
      var _setGState = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(_ref4) {
        var _this4 = this;

        var resources, gState, operatorList, cacheKey, task, stateManager, localGStateCache, localColorSpaceCache, gStateRef, isSimpleGState, gStateObj, gStateKeys, promise, _loop, i, ii;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                resources = _ref4.resources, gState = _ref4.gState, operatorList = _ref4.operatorList, cacheKey = _ref4.cacheKey, task = _ref4.task, stateManager = _ref4.stateManager, localGStateCache = _ref4.localGStateCache, localColorSpaceCache = _ref4.localColorSpaceCache;
                gStateRef = gState.objId;
                isSimpleGState = true;
                gStateObj = [];
                gStateKeys = gState.getKeys();
                promise = Promise.resolve();

                _loop = function _loop() {
                  var key = gStateKeys[i];
                  var value = gState.get(key);

                  switch (key) {
                    case "Type":
                      break;

                    case "LW":
                    case "LC":
                    case "LJ":
                    case "ML":
                    case "D":
                    case "RI":
                    case "FL":
                    case "CA":
                    case "ca":
                      gStateObj.push([key, value]);
                      break;

                    case "Font":
                      isSimpleGState = false;
                      promise = promise.then(function () {
                        return _this4.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {
                          operatorList.addDependency(loadedName);
                          gStateObj.push([key, [loadedName, value[1]]]);
                        });
                      });
                      break;

                    case "BM":
                      gStateObj.push([key, normalizeBlendMode(value)]);
                      break;

                    case "SMask":
                      if ((0, _primitives.isName)(value, "None")) {
                        gStateObj.push([key, false]);
                        break;
                      }

                      if ((0, _primitives.isDict)(value)) {
                        isSimpleGState = false;
                        promise = promise.then(function () {
                          return _this4.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
                        });
                        gStateObj.push([key, true]);
                      } else {
                        (0, _util.warn)("Unsupported SMask type");
                      }

                      break;

                    case "TR":
                      var transferMaps = _this4.handleTransferFunction(value);

                      gStateObj.push([key, transferMaps]);
                      break;

                    case "OP":
                    case "op":
                    case "OPM":
                    case "BG":
                    case "BG2":
                    case "UCR":
                    case "UCR2":
                    case "TR2":
                    case "HT":
                    case "SM":
                    case "SA":
                    case "AIS":
                    case "TK":
                      (0, _util.info)("graphic state operator " + key);
                      break;

                    default:
                      (0, _util.info)("Unknown graphic state operator " + key);
                      break;
                  }
                };

                for (i = 0, ii = gStateKeys.length; i < ii; i++) {
                  _loop();
                }

                return _context4.abrupt("return", promise.then(function () {
                  if (gStateObj.length > 0) {
                    operatorList.addOp(_util.OPS.setGState, [gStateObj]);
                  }

                  if (isSimpleGState) {
                    localGStateCache.set(cacheKey, gStateRef, gStateObj);
                  }
                }));

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function setGState(_x10) {
        return _setGState.apply(this, arguments);
      }

      return setGState;
    }()
  }, {
    key: "loadFont",
    value: function loadFont(fontName, font, resources) {
      var _this5 = this;

      var fallbackFontDict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var errorFont = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
          return _regenerator["default"].wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  return _context5.abrupt("return", new TranslatedFont({
                    loadedName: "g_font_error",
                    font: new _fonts.ErrorFont("Font \"".concat(fontName, "\" is not available.")),
                    dict: font,
                    extraProperties: _this5.options.fontExtraProperties
                  }));

                case 1:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function errorFont() {
          return _ref5.apply(this, arguments);
        };
      }();

      var fontRef,
          xref = this.xref;

      if (font) {
        if (!(0, _primitives.isRef)(font)) {
          throw new _util.FormatError('The "font" object should be a reference.');
        }

        fontRef = font;
      } else {
        var fontRes = resources.get("Font");

        if (fontRes) {
          fontRef = fontRes.getRaw(fontName);
        }
      }

      if (!fontRef) {
        var partialMsg = "Font \"".concat(fontName || font && font.toString(), "\" is not available");

        if (!this.options.ignoreErrors && !this.parsingType3Font) {
          (0, _util.warn)("".concat(partialMsg, "."));
          return errorFont();
        }

        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorFontMissing
        });
        (0, _util.warn)("".concat(partialMsg, " -- attempting to fallback to a default font."));

        if (fallbackFontDict) {
          fontRef = fallbackFontDict;
        } else {
          fontRef = PartialEvaluator.fallbackFontDict;
        }
      }

      if (this.fontCache.has(fontRef)) {
        return this.fontCache.get(fontRef);
      }

      font = xref.fetchIfRef(fontRef);

      if (!(0, _primitives.isDict)(font)) {
        return errorFont();
      }

      if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
        return this.fontCache.get(font.cacheKey);
      }

      var fontCapability = (0, _util.createPromiseCapability)();
      var preEvaluatedFont;

      try {
        preEvaluatedFont = this.preEvaluateFont(font);
      } catch (reason) {
        (0, _util.warn)("loadFont - preEvaluateFont failed: \"".concat(reason, "\"."));
        return errorFont();
      }

      var _preEvaluatedFont = preEvaluatedFont,
          descriptor = _preEvaluatedFont.descriptor,
          hash = _preEvaluatedFont.hash;
      var fontRefIsRef = (0, _primitives.isRef)(fontRef),
          fontID;

      if (fontRefIsRef) {
        fontID = "f".concat(fontRef.toString());
      }

      if (hash && (0, _primitives.isDict)(descriptor)) {
        if (!descriptor.fontAliases) {
          descriptor.fontAliases = Object.create(null);
        }

        var fontAliases = descriptor.fontAliases;

        if (fontAliases[hash]) {
          var aliasFontRef = fontAliases[hash].aliasRef;

          if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
            this.fontCache.putAlias(fontRef, aliasFontRef);
            return this.fontCache.get(fontRef);
          }
        } else {
          fontAliases[hash] = {
            fontID: this.idFactory.createFontId()
          };
        }

        if (fontRefIsRef) {
          fontAliases[hash].aliasRef = fontRef;
        }

        fontID = fontAliases[hash].fontID;
      }

      if (fontRefIsRef) {
        this.fontCache.put(fontRef, fontCapability.promise);
      } else {
        if (!fontID) {
          fontID = this.idFactory.createFontId();
        }

        font.cacheKey = "cacheKey_".concat(fontID);
        this.fontCache.put(font.cacheKey, fontCapability.promise);
      }

      (0, _util.assert)(fontID && fontID.startsWith("f"), 'The "fontID" must be (correctly) defined.');
      font.loadedName = "".concat(this.idFactory.getDocId(), "_").concat(fontID);
      this.translateFont(preEvaluatedFont).then(function (translatedFont) {
        if (translatedFont.fontType !== undefined) {
          var xrefFontStats = xref.stats.fontTypes;
          xrefFontStats[translatedFont.fontType] = true;
        }

        fontCapability.resolve(new TranslatedFont({
          loadedName: font.loadedName,
          font: translatedFont,
          dict: font,
          extraProperties: _this5.options.fontExtraProperties
        }));
      })["catch"](function (reason) {
        _this5.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorFontTranslate
        });

        (0, _util.warn)("loadFont - translateFont failed: \"".concat(reason, "\"."));

        try {
          var fontFile3 = descriptor && descriptor.get("FontFile3");
          var subtype = fontFile3 && fontFile3.get("Subtype");
          var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
          var xrefFontStats = xref.stats.fontTypes;
          xrefFontStats[fontType] = true;
        } catch (ex) {}

        fontCapability.resolve(new TranslatedFont({
          loadedName: font.loadedName,
          font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason),
          dict: font,
          extraProperties: _this5.options.fontExtraProperties
        }));
      });
      return fontCapability.promise;
    }
  }, {
    key: "buildPath",
    value: function buildPath(operatorList, fn, args) {
      var parsingText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var lastIndex = operatorList.length - 1;

      if (!args) {
        args = [];
      }

      if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
        if (parsingText) {
          (0, _util.warn)("Encountered path operator \"".concat(fn, "\" inside of a text object."));
          operatorList.addOp(_util.OPS.save, null);
        }

        operatorList.addOp(_util.OPS.constructPath, [[fn], args]);

        if (parsingText) {
          operatorList.addOp(_util.OPS.restore, null);
        }
      } else {
        var opArgs = operatorList.argsArray[lastIndex];
        opArgs[0].push(fn);
        Array.prototype.push.apply(opArgs[1], args);
      }
    }
  }, {
    key: "parseColorSpace",
    value: function parseColorSpace(_ref6) {
      var _this6 = this;

      var cs = _ref6.cs,
          resources = _ref6.resources,
          localColorSpaceCache = _ref6.localColorSpaceCache;
      return _colorspace.ColorSpace.parseAsync({
        cs: cs,
        xref: this.xref,
        resources: resources,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache: localColorSpaceCache
      })["catch"](function (reason) {
        if (reason instanceof _util.AbortException) {
          return null;
        }

        if (_this6.options.ignoreErrors) {
          _this6.handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorColorSpace
          });

          (0, _util.warn)("parseColorSpace - ignoring ColorSpace: \"".concat(reason, "\"."));
          return null;
        }

        throw reason;
      });
    }
  }, {
    key: "handleColorN",
    value: function handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache) {
      var patternName = args.pop();

      if (patternName instanceof _primitives.Name) {
        var name = patternName.name;
        var localTilingPattern = localTilingPatternCache.getByName(name);

        if (localTilingPattern) {
          try {
            var color = cs.base ? cs.base.getRgb(args, 0) : null;
            var tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
            operatorList.addOp(fn, tilingPatternIR);
            return undefined;
          } catch (ex) {
            if (ex instanceof _core_utils.MissingDataException) {
              throw ex;
            }
          }
        }

        var pattern = patterns.get(name);

        if (pattern) {
          var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
          var typeNum = dict.get("PatternType");

          if (typeNum === PatternType.TILING) {
            var _color = cs.base ? cs.base.getRgb(args, 0) : null;

            return this.handleTilingType(fn, _color, resources, pattern, dict, operatorList, task, name, localTilingPatternCache);
          } else if (typeNum === PatternType.SHADING) {
            var shading = dict.get("Shading");
            var matrix = dict.getArray("Matrix");
            pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this._pdfFunctionFactory, localColorSpaceCache);
            operatorList.addOp(fn, pattern.getIR());
            return undefined;
          }

          throw new _util.FormatError("Unknown PatternType: ".concat(typeNum));
        }
      }

      throw new _util.FormatError("Unknown PatternName: ".concat(patternName));
    }
  }, {
    key: "parseMarkedContentProps",
    value: function () {
      var _parseMarkedContentProps = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6(contentProperties, resources) {
        var optionalContent, properties, optionalContentType, optionalContentGroups, groupIds, expression;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(0, _primitives.isName)(contentProperties)) {
                  _context6.next = 5;
                  break;
                }

                properties = resources.get("Properties");
                optionalContent = properties.get(contentProperties.name);
                _context6.next = 10;
                break;

              case 5:
                if (!(0, _primitives.isDict)(contentProperties)) {
                  _context6.next = 9;
                  break;
                }

                optionalContent = contentProperties;
                _context6.next = 10;
                break;

              case 9:
                throw new _util.FormatError("Optional content properties malformed.");

              case 10:
                optionalContentType = optionalContent.get("Type").name;

                if (!(optionalContentType === "OCG")) {
                  _context6.next = 15;
                  break;
                }

                return _context6.abrupt("return", {
                  type: optionalContentType,
                  id: optionalContent.objId
                });

              case 15:
                if (!(optionalContentType === "OCMD")) {
                  _context6.next = 27;
                  break;
                }

                optionalContentGroups = optionalContent.get("OCGs");

                if (!(Array.isArray(optionalContentGroups) || (0, _primitives.isDict)(optionalContentGroups))) {
                  _context6.next = 25;
                  break;
                }

                groupIds = [];

                if (Array.isArray(optionalContentGroups)) {
                  optionalContent.get("OCGs").forEach(function (ocg) {
                    groupIds.push(ocg.toString());
                  });
                } else {
                  groupIds.push(optionalContentGroups.objId);
                }

                expression = null;

                if (optionalContent.get("VE")) {
                  expression = true;
                }

                return _context6.abrupt("return", {
                  type: optionalContentType,
                  ids: groupIds,
                  policy: (0, _primitives.isName)(optionalContent.get("P")) ? optionalContent.get("P").name : null,
                  expression: expression
                });

              case 25:
                if (!(0, _primitives.isRef)(optionalContentGroups)) {
                  _context6.next = 27;
                  break;
                }

                return _context6.abrupt("return", {
                  type: optionalContentType,
                  id: optionalContentGroups.toString()
                });

              case 27:
                return _context6.abrupt("return", null);

              case 28:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function parseMarkedContentProps(_x11, _x12) {
        return _parseMarkedContentProps.apply(this, arguments);
      }

      return parseMarkedContentProps;
    }()
  }, {
    key: "getOperatorList",
    value: function getOperatorList(_ref7) {
      var _this7 = this;

      var stream = _ref7.stream,
          task = _ref7.task,
          resources = _ref7.resources,
          operatorList = _ref7.operatorList,
          _ref7$initialState = _ref7.initialState,
          initialState = _ref7$initialState === void 0 ? null : _ref7$initialState,
          _ref7$fallbackFontDic = _ref7.fallbackFontDict,
          fallbackFontDict = _ref7$fallbackFontDic === void 0 ? null : _ref7$fallbackFontDic;
      resources = resources || _primitives.Dict.empty;
      initialState = initialState || new EvalState();

      if (!operatorList) {
        throw new Error('getOperatorList: missing "operatorList" parameter');
      }

      var self = this;
      var xref = this.xref;
      var parsingText = false;
      var localImageCache = new _image_utils.LocalImageCache();
      var localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
      var localGStateCache = new _image_utils.LocalGStateCache();
      var localTilingPatternCache = new _image_utils.LocalTilingPatternCache();

      var xobjs = resources.get("XObject") || _primitives.Dict.empty;

      var patterns = resources.get("Pattern") || _primitives.Dict.empty;

      var stateManager = new StateManager(initialState);
      var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
      var timeSlotManager = new TimeSlotManager();

      function closePendingRestoreOPS(argument) {
        for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
          operatorList.addOp(_util.OPS.restore, []);
        }
      }

      return new Promise(function promiseBody(resolve, reject) {
        var next = function next(promise) {
          Promise.all([promise, operatorList.ready]).then(function () {
            try {
              promiseBody(resolve, reject);
            } catch (ex) {
              reject(ex);
            }
          }, reject);
        };

        task.ensureNotTerminated();
        timeSlotManager.reset();
        var stop,
            operation = {},
            i,
            ii,
            cs,
            name;

        while (!(stop = timeSlotManager.check())) {
          operation.args = null;

          if (!preprocessor.read(operation)) {
            break;
          }

          var args = operation.args;
          var fn = operation.fn;

          switch (fn | 0) {
            case _util.OPS.paintXObject:
              name = args[0].name;

              if (name) {
                var localImage = localImageCache.getByName(name);

                if (localImage) {
                  operatorList.addOp(localImage.fn, localImage.args);
                  args = null;
                  continue;
                }
              }

              next(new Promise(function (resolveXObject, rejectXObject) {
                if (!name) {
                  throw new _util.FormatError("XObject must be referred to by name.");
                }

                var xobj = xobjs.getRaw(name);

                if (xobj instanceof _primitives.Ref) {
                  var _localImage = localImageCache.getByRef(xobj);

                  if (_localImage) {
                    operatorList.addOp(_localImage.fn, _localImage.args);
                    resolveXObject();
                    return;
                  }

                  var globalImage = self.globalImageCache.getData(xobj, self.pageIndex);

                  if (globalImage) {
                    operatorList.addDependency(globalImage.objId);
                    operatorList.addOp(globalImage.fn, globalImage.args);
                    resolveXObject();
                    return;
                  }

                  xobj = xref.fetch(xobj);
                }

                if (!(0, _primitives.isStream)(xobj)) {
                  throw new _util.FormatError("XObject should be a stream");
                }

                var type = xobj.dict.get("Subtype");

                if (!(0, _primitives.isName)(type)) {
                  throw new _util.FormatError("XObject should have a Name subtype");
                }

                if (type.name === "Form") {
                  stateManager.save();
                  self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function () {
                    stateManager.restore();
                    resolveXObject();
                  }, rejectXObject);
                  return;
                } else if (type.name === "Image") {
                  self.buildPaintImageXObject({
                    resources: resources,
                    image: xobj,
                    operatorList: operatorList,
                    cacheKey: name,
                    localImageCache: localImageCache,
                    localColorSpaceCache: localColorSpaceCache
                  }).then(resolveXObject, rejectXObject);
                  return;
                } else if (type.name === "PS") {
                  (0, _util.info)("Ignored XObject subtype PS");
                } else {
                  throw new _util.FormatError("Unhandled XObject subtype ".concat(type.name));
                }

                resolveXObject();
              })["catch"](function (reason) {
                if (reason instanceof _util.AbortException) {
                  return;
                }

                if (self.options.ignoreErrors) {
                  self.handler.send("UnsupportedFeature", {
                    featureId: _util.UNSUPPORTED_FEATURES.errorXObject
                  });
                  (0, _util.warn)("getOperatorList - ignoring XObject: \"".concat(reason, "\"."));
                  return;
                }

                throw reason;
              }));
              return;

            case _util.OPS.setFont:
              var fontSize = args[1];
              next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function (loadedName) {
                operatorList.addDependency(loadedName);
                operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
              }));
              return;

            case _util.OPS.beginText:
              parsingText = true;
              break;

            case _util.OPS.endText:
              parsingText = false;
              break;

            case _util.OPS.endInlineImage:
              var cacheKey = args[0].cacheKey;

              if (cacheKey) {
                var _localImage2 = localImageCache.getByName(cacheKey);

                if (_localImage2) {
                  operatorList.addOp(_localImage2.fn, _localImage2.args);
                  args = null;
                  continue;
                }
              }

              next(self.buildPaintImageXObject({
                resources: resources,
                image: args[0],
                isInline: true,
                operatorList: operatorList,
                cacheKey: cacheKey,
                localImageCache: localImageCache,
                localColorSpaceCache: localColorSpaceCache
              }));
              return;

            case _util.OPS.showText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              args[0] = self.handleText(args[0], stateManager.state);
              break;

            case _util.OPS.showSpacedText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              var arr = args[0];
              var combinedGlyphs = [];
              var arrLength = arr.length;
              var state = stateManager.state;

              for (i = 0; i < arrLength; ++i) {
                var arrItem = arr[i];

                if ((0, _util.isString)(arrItem)) {
                  Array.prototype.push.apply(combinedGlyphs, self.handleText(arrItem, state));
                } else if ((0, _util.isNum)(arrItem)) {
                  combinedGlyphs.push(arrItem);
                }
              }

              args[0] = combinedGlyphs;
              fn = _util.OPS.showText;
              break;

            case _util.OPS.nextLineShowText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              operatorList.addOp(_util.OPS.nextLine);
              args[0] = self.handleText(args[0], stateManager.state);
              fn = _util.OPS.showText;
              break;

            case _util.OPS.nextLineSetSpacingShowText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              operatorList.addOp(_util.OPS.nextLine);
              operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
              operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
              args[0] = self.handleText(args[0], stateManager.state);
              fn = _util.OPS.showText;
              break;

            case _util.OPS.setTextRenderingMode:
              stateManager.state.textRenderingMode = args[0];
              break;

            case _util.OPS.setFillColorSpace:
              {
                var cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);

                if (cachedColorSpace) {
                  stateManager.state.fillColorSpace = cachedColorSpace;
                  continue;
                }

                next(self.parseColorSpace({
                  cs: args[0],
                  resources: resources,
                  localColorSpaceCache: localColorSpaceCache
                }).then(function (colorSpace) {
                  if (colorSpace) {
                    stateManager.state.fillColorSpace = colorSpace;
                  }
                }));
                return;
              }

            case _util.OPS.setStrokeColorSpace:
              {
                var _cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);

                if (_cachedColorSpace) {
                  stateManager.state.strokeColorSpace = _cachedColorSpace;
                  continue;
                }

                next(self.parseColorSpace({
                  cs: args[0],
                  resources: resources,
                  localColorSpaceCache: localColorSpaceCache
                }).then(function (colorSpace) {
                  if (colorSpace) {
                    stateManager.state.strokeColorSpace = colorSpace;
                  }
                }));
                return;
              }

            case _util.OPS.setFillColor:
              cs = stateManager.state.fillColorSpace;
              args = cs.getRgb(args, 0);
              fn = _util.OPS.setFillRGBColor;
              break;

            case _util.OPS.setStrokeColor:
              cs = stateManager.state.strokeColorSpace;
              args = cs.getRgb(args, 0);
              fn = _util.OPS.setStrokeRGBColor;
              break;

            case _util.OPS.setFillGray:
              stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
              args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
              fn = _util.OPS.setFillRGBColor;
              break;

            case _util.OPS.setStrokeGray:
              stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
              args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
              fn = _util.OPS.setStrokeRGBColor;
              break;

            case _util.OPS.setFillCMYKColor:
              stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
              args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
              fn = _util.OPS.setFillRGBColor;
              break;

            case _util.OPS.setStrokeCMYKColor:
              stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
              args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
              fn = _util.OPS.setStrokeRGBColor;
              break;

            case _util.OPS.setFillRGBColor:
              stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
              args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
              break;

            case _util.OPS.setStrokeRGBColor:
              stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
              args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
              break;

            case _util.OPS.setFillColorN:
              cs = stateManager.state.fillColorSpace;

              if (cs.name === "Pattern") {
                next(self.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache));
                return;
              }

              args = cs.getRgb(args, 0);
              fn = _util.OPS.setFillRGBColor;
              break;

            case _util.OPS.setStrokeColorN:
              cs = stateManager.state.strokeColorSpace;

              if (cs.name === "Pattern") {
                next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache));
                return;
              }

              args = cs.getRgb(args, 0);
              fn = _util.OPS.setStrokeRGBColor;
              break;

            case _util.OPS.shadingFill:
              var shadingRes = resources.get("Shading");

              if (!shadingRes) {
                throw new _util.FormatError("No shading resource found");
              }

              var shading = shadingRes.get(args[0].name);

              if (!shading) {
                throw new _util.FormatError("No shading object found");
              }

              var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self.handler, self._pdfFunctionFactory, localColorSpaceCache);

              var patternIR = shadingFill.getIR();
              args = [patternIR];
              fn = _util.OPS.shadingFill;
              break;

            case _util.OPS.setGState:
              name = args[0].name;

              if (name) {
                var localGStateObj = localGStateCache.getByName(name);

                if (localGStateObj) {
                  if (localGStateObj.length > 0) {
                    operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                  }

                  args = null;
                  continue;
                }
              }

              next(new Promise(function (resolveGState, rejectGState) {
                if (!name) {
                  throw new _util.FormatError("GState must be referred to by name.");
                }

                var extGState = resources.get("ExtGState");

                if (!(extGState instanceof _primitives.Dict)) {
                  throw new _util.FormatError("ExtGState should be a dictionary.");
                }

                var gState = extGState.get(name);

                if (!(gState instanceof _primitives.Dict)) {
                  throw new _util.FormatError("GState should be a dictionary.");
                }

                self.setGState({
                  resources: resources,
                  gState: gState,
                  operatorList: operatorList,
                  cacheKey: name,
                  task: task,
                  stateManager: stateManager,
                  localGStateCache: localGStateCache,
                  localColorSpaceCache: localColorSpaceCache
                }).then(resolveGState, rejectGState);
              })["catch"](function (reason) {
                if (reason instanceof _util.AbortException) {
                  return;
                }

                if (self.options.ignoreErrors) {
                  self.handler.send("UnsupportedFeature", {
                    featureId: _util.UNSUPPORTED_FEATURES.errorExtGState
                  });
                  (0, _util.warn)("getOperatorList - ignoring ExtGState: \"".concat(reason, "\"."));
                  return;
                }

                throw reason;
              }));
              return;

            case _util.OPS.moveTo:
            case _util.OPS.lineTo:
            case _util.OPS.curveTo:
            case _util.OPS.curveTo2:
            case _util.OPS.curveTo3:
            case _util.OPS.closePath:
            case _util.OPS.rectangle:
              self.buildPath(operatorList, fn, args, parsingText);
              continue;

            case _util.OPS.markPoint:
            case _util.OPS.markPointProps:
            case _util.OPS.beginCompat:
            case _util.OPS.endCompat:
              continue;

            case _util.OPS.beginMarkedContentProps:
              if (!(0, _primitives.isName)(args[0])) {
                (0, _util.warn)("Expected name for beginMarkedContentProps arg0=".concat(args[0]));
                continue;
              }

              if (args[0].name === "OC") {
                next(self.parseMarkedContentProps(args[1], resources).then(function (data) {
                  operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
                })["catch"](function (reason) {
                  if (reason instanceof _util.AbortException) {
                    return;
                  }

                  if (self.options.ignoreErrors) {
                    self.handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.errorMarkedContent
                    });
                    (0, _util.warn)("getOperatorList - ignoring beginMarkedContentProps: \"".concat(reason, "\"."));
                    return;
                  }

                  throw reason;
                }));
                return;
              }

              args = [args[0].name];
              break;

            case _util.OPS.beginMarkedContent:
            case _util.OPS.endMarkedContent:
            default:
              if (args !== null) {
                for (i = 0, ii = args.length; i < ii; i++) {
                  if (args[i] instanceof _primitives.Dict) {
                    break;
                  }
                }

                if (i < ii) {
                  (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                  continue;
                }
              }

          }

          operatorList.addOp(fn, args);
        }

        if (stop) {
          next(deferred);
          return;
        }

        closePendingRestoreOPS();
        resolve();
      })["catch"](function (reason) {
        if (reason instanceof _util.AbortException) {
          return;
        }

        if (_this7.options.ignoreErrors) {
          _this7.handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
          });

          (0, _util.warn)("getOperatorList - ignoring errors during \"".concat(task.name, "\" ") + "task: \"".concat(reason, "\"."));
          closePendingRestoreOPS();
          return;
        }

        throw reason;
      });
    }
  }, {
    key: "getTextContent",
    value: function getTextContent(_ref8) {
      var _this8 = this;

      var stream = _ref8.stream,
          task = _ref8.task,
          resources = _ref8.resources,
          _ref8$stateManager = _ref8.stateManager,
          stateManager = _ref8$stateManager === void 0 ? null : _ref8$stateManager,
          _ref8$normalizeWhites = _ref8.normalizeWhitespace,
          normalizeWhitespace = _ref8$normalizeWhites === void 0 ? false : _ref8$normalizeWhites,
          _ref8$combineTextItem = _ref8.combineTextItems,
          combineTextItems = _ref8$combineTextItem === void 0 ? false : _ref8$combineTextItem,
          sink = _ref8.sink,
          _ref8$seenStyles = _ref8.seenStyles,
          seenStyles = _ref8$seenStyles === void 0 ? Object.create(null) : _ref8$seenStyles;
      resources = resources || _primitives.Dict.empty;
      stateManager = stateManager || new StateManager(new TextState());
      var WhitespaceRegexp = /\s/g;
      var textContent = {
        items: [],
        styles: Object.create(null)
      };
      var textContentItem = {
        initialized: false,
        str: [],
        width: 0,
        height: 0,
        vertical: false,
        lastAdvanceWidth: 0,
        lastAdvanceHeight: 0,
        textAdvanceScale: 0,
        spaceWidth: 0,
        fakeSpaceMin: Infinity,
        fakeMultiSpaceMin: Infinity,
        fakeMultiSpaceMax: -0,
        textRunBreakAllowed: false,
        transform: null,
        fontName: null
      };
      var SPACE_FACTOR = 0.3;
      var MULTI_SPACE_FACTOR = 1.5;
      var MULTI_SPACE_FACTOR_MAX = 4;
      var self = this;
      var xref = this.xref;
      var xobjs = null;
      var emptyXObjectCache = new _image_utils.LocalImageCache();
      var emptyGStateCache = new _image_utils.LocalGStateCache();
      var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
      var textState;

      function ensureTextContentItem() {
        if (textContentItem.initialized) {
          return textContentItem;
        }

        var font = textState.font;

        if (!(font.loadedName in seenStyles)) {
          seenStyles[font.loadedName] = true;
          textContent.styles[font.loadedName] = {
            fontFamily: font.fallbackName,
            ascent: font.ascent,
            descent: font.descent,
            vertical: font.vertical
          };
        }

        textContentItem.fontName = font.loadedName;
        var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];

        if (font.isType3Font && textState.fontSize <= 1 && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
          var glyphHeight = font.bbox[3] - font.bbox[1];

          if (glyphHeight > 0) {
            tsm[3] *= glyphHeight * textState.fontMatrix[3];
          }
        }

        var trm = _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));

        textContentItem.transform = trm;

        if (!font.vertical) {
          textContentItem.width = 0;
          textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
          textContentItem.vertical = false;
        } else {
          textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
          textContentItem.height = 0;
          textContentItem.vertical = true;
        }

        var a = textState.textLineMatrix[0];
        var b = textState.textLineMatrix[1];
        var scaleLineX = Math.sqrt(a * a + b * b);
        a = textState.ctm[0];
        b = textState.ctm[1];
        var scaleCtmX = Math.sqrt(a * a + b * b);
        textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
        textContentItem.lastAdvanceWidth = 0;
        textContentItem.lastAdvanceHeight = 0;
        var spaceWidth = font.spaceWidth / 1000 * textState.fontSize;

        if (spaceWidth) {
          textContentItem.spaceWidth = spaceWidth;
          textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
          textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
          textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
          textContentItem.textRunBreakAllowed = !font.isMonospace;
        } else {
          textContentItem.spaceWidth = 0;
          textContentItem.fakeSpaceMin = Infinity;
          textContentItem.fakeMultiSpaceMin = Infinity;
          textContentItem.fakeMultiSpaceMax = 0;
          textContentItem.textRunBreakAllowed = false;
        }

        textContentItem.initialized = true;
        return textContentItem;
      }

      function replaceWhitespace(str) {
        var i = 0,
            ii = str.length,
            code;

        while (i < ii && (code = str.charCodeAt(i)) >= 0x20 && code <= 0x7f) {
          i++;
        }

        return i < ii ? str.replace(WhitespaceRegexp, " ") : str;
      }

      function runBidiTransform(textChunk) {
        var str = textChunk.str.join("");
        var bidiResult = (0, _bidi.bidi)(str, -1, textChunk.vertical);
        return {
          str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str,
          dir: bidiResult.dir,
          width: textChunk.width,
          height: textChunk.height,
          transform: textChunk.transform,
          fontName: textChunk.fontName
        };
      }

      function handleSetFont(fontName, fontRef) {
        return self.loadFont(fontName, fontRef, resources).then(function (translated) {
          textState.font = translated.font;
          textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
        });
      }

      function buildTextContentItem(chars) {
        var font = textState.font;
        var textChunk = ensureTextContentItem();
        var width = 0;
        var height = 0;
        var glyphs = font.charsToGlyphs(chars);

        for (var i = 0; i < glyphs.length; i++) {
          var glyph = glyphs[i];
          var glyphWidth = null;

          if (font.vertical && glyph.vmetric) {
            glyphWidth = glyph.vmetric[0];
          } else {
            glyphWidth = glyph.width;
          }

          var glyphUnicode = glyph.unicode;
          var NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();

          if (NormalizedUnicodes[glyphUnicode] !== undefined) {
            glyphUnicode = NormalizedUnicodes[glyphUnicode];
          }

          glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
          var charSpacing = textState.charSpacing;

          if (glyph.isSpace) {
            var wordSpacing = textState.wordSpacing;
            charSpacing += wordSpacing;

            if (wordSpacing > 0) {
              addFakeSpaces(wordSpacing, textChunk.str);
            }
          }

          var tx = 0;
          var ty = 0;

          if (!font.vertical) {
            var w0 = glyphWidth * textState.fontMatrix[0];
            tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
            width += tx;
          } else {
            var w1 = glyphWidth * textState.fontMatrix[0];
            ty = w1 * textState.fontSize + charSpacing;
            height += ty;
          }

          textState.translateTextMatrix(tx, ty);
          textChunk.str.push(glyphUnicode);
        }

        if (!font.vertical) {
          textChunk.lastAdvanceWidth = width;
          textChunk.width += width;
        } else {
          textChunk.lastAdvanceHeight = height;
          textChunk.height += Math.abs(height);
        }

        return textChunk;
      }

      function addFakeSpaces(width, strBuf) {
        if (width < textContentItem.fakeSpaceMin) {
          return;
        }

        if (width < textContentItem.fakeMultiSpaceMin) {
          strBuf.push(" ");
          return;
        }

        var fakeSpaces = Math.round(width / textContentItem.spaceWidth);

        while (fakeSpaces-- > 0) {
          strBuf.push(" ");
        }
      }

      function flushTextContentItem() {
        if (!textContentItem.initialized) {
          return;
        }

        if (!textContentItem.vertical) {
          textContentItem.width *= textContentItem.textAdvanceScale;
        } else {
          textContentItem.height *= textContentItem.textAdvanceScale;
        }

        textContent.items.push(runBidiTransform(textContentItem));
        textContentItem.initialized = false;
        textContentItem.str.length = 0;
      }

      function enqueueChunk() {
        var length = textContent.items.length;

        if (length > 0) {
          sink.enqueue(textContent, length);
          textContent.items = [];
          textContent.styles = Object.create(null);
        }
      }

      var timeSlotManager = new TimeSlotManager();
      return new Promise(function promiseBody(resolve, reject) {
        var next = function next(promise) {
          enqueueChunk();
          Promise.all([promise, sink.ready]).then(function () {
            try {
              promiseBody(resolve, reject);
            } catch (ex) {
              reject(ex);
            }
          }, reject);
        };

        task.ensureNotTerminated();
        timeSlotManager.reset();
        var stop,
            operation = {},
            args = [];

        while (!(stop = timeSlotManager.check())) {
          args.length = 0;
          operation.args = args;

          if (!preprocessor.read(operation)) {
            break;
          }

          textState = stateManager.state;
          var fn = operation.fn;
          args = operation.args;
          var advance, diff;

          switch (fn | 0) {
            case _util.OPS.setFont:
              var fontNameArg = args[0].name,
                  fontSizeArg = args[1];

              if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                break;
              }

              flushTextContentItem();
              textState.fontName = fontNameArg;
              textState.fontSize = fontSizeArg;
              next(handleSetFont(fontNameArg, null));
              return;

            case _util.OPS.setTextRise:
              flushTextContentItem();
              textState.textRise = args[0];
              break;

            case _util.OPS.setHScale:
              flushTextContentItem();
              textState.textHScale = args[0] / 100;
              break;

            case _util.OPS.setLeading:
              flushTextContentItem();
              textState.leading = args[0];
              break;

            case _util.OPS.moveText:
              var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
              advance = args[0] - args[1];

              if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                textState.translateTextLineMatrix(args[0], args[1]);
                textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
                textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
                diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
                addFakeSpaces(diff, textContentItem.str);
                break;
              }

              flushTextContentItem();
              textState.translateTextLineMatrix(args[0], args[1]);
              textState.textMatrix = textState.textLineMatrix.slice();
              break;

            case _util.OPS.setLeadingMoveText:
              flushTextContentItem();
              textState.leading = -args[1];
              textState.translateTextLineMatrix(args[0], args[1]);
              textState.textMatrix = textState.textLineMatrix.slice();
              break;

            case _util.OPS.nextLine:
              flushTextContentItem();
              textState.carriageReturn();
              break;

            case _util.OPS.setTextMatrix:
              advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);

              if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
                textState.translateTextLineMatrix(advance.width, advance.height);
                textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
                textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
                diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
                addFakeSpaces(diff, textContentItem.str);
                break;
              }

              flushTextContentItem();
              textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;

            case _util.OPS.setCharSpacing:
              textState.charSpacing = args[0];
              break;

            case _util.OPS.setWordSpacing:
              textState.wordSpacing = args[0];
              break;

            case _util.OPS.beginText:
              flushTextContentItem();
              textState.textMatrix = _util.IDENTITY_MATRIX.slice();
              textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
              break;

            case _util.OPS.showSpacedText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              var items = args[0];
              var offset;

              for (var j = 0, jj = items.length; j < jj; j++) {
                if (typeof items[j] === "string") {
                  buildTextContentItem(items[j]);
                } else if ((0, _util.isNum)(items[j])) {
                  ensureTextContentItem();
                  advance = items[j] * textState.fontSize / 1000;
                  var breakTextRun = false;

                  if (textState.font.vertical) {
                    offset = advance;
                    textState.translateTextMatrix(0, offset);
                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;

                    if (!breakTextRun) {
                      textContentItem.height += offset;
                    }
                  } else {
                    advance = -advance;
                    offset = advance * textState.textHScale;
                    textState.translateTextMatrix(offset, 0);
                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;

                    if (!breakTextRun) {
                      textContentItem.width += offset;
                    }
                  }

                  if (breakTextRun) {
                    flushTextContentItem();
                  } else if (advance > 0) {
                    addFakeSpaces(advance, textContentItem.str);
                  }
                }
              }

              break;

            case _util.OPS.showText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              buildTextContentItem(args[0]);
              break;

            case _util.OPS.nextLineShowText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              flushTextContentItem();
              textState.carriageReturn();
              buildTextContentItem(args[0]);
              break;

            case _util.OPS.nextLineSetSpacingShowText:
              if (!stateManager.state.font) {
                self.ensureStateFont(stateManager.state);
                continue;
              }

              flushTextContentItem();
              textState.wordSpacing = args[0];
              textState.charSpacing = args[1];
              textState.carriageReturn();
              buildTextContentItem(args[2]);
              break;

            case _util.OPS.paintXObject:
              flushTextContentItem();

              if (!xobjs) {
                xobjs = resources.get("XObject") || _primitives.Dict.empty;
              }

              var name = args[0].name;

              if (name && emptyXObjectCache.getByName(name)) {
                break;
              }

              next(new Promise(function (resolveXObject, rejectXObject) {
                if (!name) {
                  throw new _util.FormatError("XObject must be referred to by name.");
                }

                var xobj = xobjs.getRaw(name);

                if (xobj instanceof _primitives.Ref) {
                  if (emptyXObjectCache.getByRef(xobj)) {
                    resolveXObject();
                    return;
                  }

                  var globalImage = self.globalImageCache.getData(xobj, self.pageIndex);

                  if (globalImage) {
                    resolveXObject();
                    return;
                  }

                  xobj = xref.fetch(xobj);
                }

                if (!(0, _primitives.isStream)(xobj)) {
                  throw new _util.FormatError("XObject should be a stream");
                }

                var type = xobj.dict.get("Subtype");

                if (!(0, _primitives.isName)(type)) {
                  throw new _util.FormatError("XObject should have a Name subtype");
                }

                if (type.name !== "Form") {
                  emptyXObjectCache.set(name, xobj.dict.objId, true);
                  resolveXObject();
                  return;
                }

                var currentState = stateManager.state.clone();
                var xObjStateManager = new StateManager(currentState);
                var matrix = xobj.dict.getArray("Matrix");

                if (Array.isArray(matrix) && matrix.length === 6) {
                  xObjStateManager.transform(matrix);
                }

                enqueueChunk();
                var sinkWrapper = {
                  enqueueInvoked: false,
                  enqueue: function enqueue(chunk, size) {
                    this.enqueueInvoked = true;
                    sink.enqueue(chunk, size);
                  },

                  get desiredSize() {
                    return sink.desiredSize;
                  },

                  get ready() {
                    return sink.ready;
                  }

                };
                self.getTextContent({
                  stream: xobj,
                  task: task,
                  resources: xobj.dict.get("Resources") || resources,
                  stateManager: xObjStateManager,
                  normalizeWhitespace: normalizeWhitespace,
                  combineTextItems: combineTextItems,
                  sink: sinkWrapper,
                  seenStyles: seenStyles
                }).then(function () {
                  if (!sinkWrapper.enqueueInvoked) {
                    emptyXObjectCache.set(name, xobj.dict.objId, true);
                  }

                  resolveXObject();
                }, rejectXObject);
              })["catch"](function (reason) {
                if (reason instanceof _util.AbortException) {
                  return;
                }

                if (self.options.ignoreErrors) {
                  (0, _util.warn)("getTextContent - ignoring XObject: \"".concat(reason, "\"."));
                  return;
                }

                throw reason;
              }));
              return;

            case _util.OPS.setGState:
              name = args[0].name;

              if (name && emptyGStateCache.getByName(name)) {
                break;
              }

              next(new Promise(function (resolveGState, rejectGState) {
                if (!name) {
                  throw new _util.FormatError("GState must be referred to by name.");
                }

                var extGState = resources.get("ExtGState");

                if (!(extGState instanceof _primitives.Dict)) {
                  throw new _util.FormatError("ExtGState should be a dictionary.");
                }

                var gState = extGState.get(name);

                if (!(gState instanceof _primitives.Dict)) {
                  throw new _util.FormatError("GState should be a dictionary.");
                }

                var gStateFont = gState.get("Font");

                if (!gStateFont) {
                  emptyGStateCache.set(name, gState.objId, true);
                  resolveGState();
                  return;
                }

                flushTextContentItem();
                textState.fontName = null;
                textState.fontSize = gStateFont[1];
                handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
              })["catch"](function (reason) {
                if (reason instanceof _util.AbortException) {
                  return;
                }

                if (self.options.ignoreErrors) {
                  (0, _util.warn)("getTextContent - ignoring ExtGState: \"".concat(reason, "\"."));
                  return;
                }

                throw reason;
              }));
              return;
          }

          if (textContent.items.length >= sink.desiredSize) {
            stop = true;
            break;
          }
        }

        if (stop) {
          next(deferred);
          return;
        }

        flushTextContentItem();
        enqueueChunk();
        resolve();
      })["catch"](function (reason) {
        if (reason instanceof _util.AbortException) {
          return;
        }

        if (_this8.options.ignoreErrors) {
          (0, _util.warn)("getTextContent - ignoring errors during \"".concat(task.name, "\" ") + "task: \"".concat(reason, "\"."));
          flushTextContentItem();
          enqueueChunk();
          return;
        }

        throw reason;
      });
    }
  }, {
    key: "extractDataStructures",
    value: function extractDataStructures(dict, baseDict, properties) {
      var _this9 = this;

      var xref = this.xref;
      var cidToGidBytes;
      var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
      var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(undefined);

      if (properties.composite) {
        var cidSystemInfo = dict.get("CIDSystemInfo");

        if ((0, _primitives.isDict)(cidSystemInfo)) {
          properties.cidSystemInfo = {
            registry: (0, _util.stringToPDFString)(cidSystemInfo.get("Registry")),
            ordering: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordering")),
            supplement: cidSystemInfo.get("Supplement")
          };
        }

        var cidToGidMap = dict.get("CIDToGIDMap");

        if ((0, _primitives.isStream)(cidToGidMap)) {
          cidToGidBytes = cidToGidMap.getBytes();
        }
      }

      var differences = [];
      var baseEncodingName = null;
      var encoding;

      if (dict.has("Encoding")) {
        encoding = dict.get("Encoding");

        if ((0, _primitives.isDict)(encoding)) {
          baseEncodingName = encoding.get("BaseEncoding");
          baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;

          if (encoding.has("Differences")) {
            var diffEncoding = encoding.get("Differences");
            var index = 0;

            for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
              var data = xref.fetchIfRef(diffEncoding[j]);

              if ((0, _util.isNum)(data)) {
                index = data;
              } else if ((0, _primitives.isName)(data)) {
                differences[index++] = data.name;
              } else {
                throw new _util.FormatError("Invalid entry in 'Differences' array: ".concat(data));
              }
            }
          }
        } else if ((0, _primitives.isName)(encoding)) {
          baseEncodingName = encoding.name;
        } else {
          throw new _util.FormatError("Encoding is not a Name nor a Dict");
        }

        if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
          baseEncodingName = null;
        }
      }

      if (baseEncodingName) {
        properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName).slice();
      } else {
        var isSymbolicFont = !!(properties.flags & _fonts.FontFlags.Symbolic);
        var isNonsymbolicFont = !!(properties.flags & _fonts.FontFlags.Nonsymbolic);
        encoding = _encodings.StandardEncoding;

        if (properties.type === "TrueType" && !isNonsymbolicFont) {
          encoding = _encodings.WinAnsiEncoding;
        }

        if (isSymbolicFont) {
          encoding = _encodings.MacRomanEncoding;

          if (!properties.file) {
            if (/Symbol/i.test(properties.name)) {
              encoding = _encodings.SymbolSetEncoding;
            } else if (/Dingbats|Wingdings/i.test(properties.name)) {
              encoding = _encodings.ZapfDingbatsEncoding;
            }
          }
        }

        properties.defaultEncoding = encoding;
      }

      properties.differences = differences;
      properties.baseEncodingName = baseEncodingName;
      properties.hasEncoding = !!baseEncodingName || differences.length > 0;
      properties.dict = dict;
      return toUnicodePromise.then(function (readToUnicode) {
        properties.toUnicode = readToUnicode;
        return _this9.buildToUnicode(properties);
      }).then(function (builtToUnicode) {
        properties.toUnicode = builtToUnicode;

        if (cidToGidBytes) {
          properties.cidToGidMap = _this9.readCidToGidMap(cidToGidBytes, builtToUnicode);
        }

        return properties;
      });
    }
  }, {
    key: "_buildSimpleFontToUnicode",
    value: function _buildSimpleFontToUnicode(properties) {
      var forceGlyphs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      (0, _util.assert)(!properties.composite, "Must be a simple font.");
      var toUnicode = [];
      var encoding = properties.defaultEncoding.slice();
      var baseEncodingName = properties.baseEncodingName;
      var differences = properties.differences;

      for (var charcode in differences) {
        var glyphName = differences[charcode];

        if (glyphName === ".notdef") {
          continue;
        }

        encoding[charcode] = glyphName;
      }

      var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

      for (var _charcode in encoding) {
        var _glyphName = encoding[_charcode];

        if (_glyphName === "") {
          continue;
        } else if (glyphsUnicodeMap[_glyphName] === undefined) {
          var code = 0;

          switch (_glyphName[0]) {
            case "G":
              if (_glyphName.length === 3) {
                code = parseInt(_glyphName.substring(1), 16);
              }

              break;

            case "g":
              if (_glyphName.length === 5) {
                code = parseInt(_glyphName.substring(1), 16);
              }

              break;

            case "C":
            case "c":
              if (_glyphName.length >= 3 && _glyphName.length <= 4) {
                var codeStr = _glyphName.substring(1);

                if (forceGlyphs) {
                  code = parseInt(codeStr, 16);
                  break;
                }

                code = +codeStr;

                if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                  return this._buildSimpleFontToUnicode(properties, true);
                }
              }

              break;

            default:
              var unicode = (0, _unicode.getUnicodeForGlyph)(_glyphName, glyphsUnicodeMap);

              if (unicode !== -1) {
                code = unicode;
              }

          }

          if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
            if (baseEncodingName && code === +_charcode) {
              var baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);

              if (baseEncoding && (_glyphName = baseEncoding[_charcode])) {
                toUnicode[_charcode] = String.fromCharCode(glyphsUnicodeMap[_glyphName]);
                continue;
              }
            }

            toUnicode[_charcode] = String.fromCodePoint(code);
          }

          continue;
        }

        toUnicode[_charcode] = String.fromCharCode(glyphsUnicodeMap[_glyphName]);
      }

      return new _fonts.ToUnicodeMap(toUnicode);
    }
  }, {
    key: "buildToUnicode",
    value: function buildToUnicode(properties) {
      properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;

      if (properties.hasIncludedToUnicodeMap) {
        if (!properties.composite && properties.hasEncoding) {
          properties.fallbackToUnicode = this._buildSimpleFontToUnicode(properties);
        }

        return Promise.resolve(properties.toUnicode);
      }

      if (!properties.composite) {
        return Promise.resolve(this._buildSimpleFontToUnicode(properties));
      }

      if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
        var registry = properties.cidSystemInfo.registry;
        var ordering = properties.cidSystemInfo.ordering;

        var ucs2CMapName = _primitives.Name.get(registry + "-" + ordering + "-UCS2");

        return _cmap.CMapFactory.create({
          encoding: ucs2CMapName,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        }).then(function (ucs2CMap) {
          var cMap = properties.cMap;
          var toUnicode = [];
          cMap.forEach(function (charcode, cid) {
            if (cid > 0xffff) {
              throw new _util.FormatError("Max size of CID is 65,535");
            }

            var ucs2 = ucs2CMap.lookup(cid);

            if (ucs2) {
              toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
            }
          });
          return new _fonts.ToUnicodeMap(toUnicode);
        });
      }

      return Promise.resolve(new _fonts.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
    }
  }, {
    key: "readToUnicode",
    value: function readToUnicode(toUnicode) {
      var _this10 = this;

      var cmapObj = toUnicode;

      if ((0, _primitives.isName)(cmapObj)) {
        return _cmap.CMapFactory.create({
          encoding: cmapObj,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        }).then(function (cmap) {
          if (cmap instanceof _cmap.IdentityCMap) {
            return new _fonts.IdentityToUnicodeMap(0, 0xffff);
          }

          return new _fonts.ToUnicodeMap(cmap.getMap());
        });
      } else if ((0, _primitives.isStream)(cmapObj)) {
        return _cmap.CMapFactory.create({
          encoding: cmapObj,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        }).then(function (cmap) {
          if (cmap instanceof _cmap.IdentityCMap) {
            return new _fonts.IdentityToUnicodeMap(0, 0xffff);
          }

          var map = new Array(cmap.length);
          cmap.forEach(function (charCode, token) {
            var str = [];

            for (var k = 0; k < token.length; k += 2) {
              var w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);

              if ((w1 & 0xf800) !== 0xd800) {
                str.push(w1);
                continue;
              }

              k += 2;
              var w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
              str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
            }

            map[charCode] = String.fromCodePoint.apply(String, str);
          });
          return new _fonts.ToUnicodeMap(map);
        }, function (reason) {
          if (reason instanceof _util.AbortException) {
            return null;
          }

          if (_this10.options.ignoreErrors) {
            _this10.handler.send("UnsupportedFeature", {
              featureId: _util.UNSUPPORTED_FEATURES.errorFontToUnicode
            });

            (0, _util.warn)("readToUnicode - ignoring ToUnicode data: \"".concat(reason, "\"."));
            return null;
          }

          throw reason;
        });
      }

      return Promise.resolve(null);
    }
  }, {
    key: "readCidToGidMap",
    value: function readCidToGidMap(glyphsData, toUnicode) {
      var result = [];

      for (var j = 0, jj = glyphsData.length; j < jj; j++) {
        var glyphID = glyphsData[j++] << 8 | glyphsData[j];
        var code = j >> 1;

        if (glyphID === 0 && !toUnicode.has(code)) {
          continue;
        }

        result[code] = glyphID;
      }

      return result;
    }
  }, {
    key: "extractWidths",
    value: function extractWidths(dict, descriptor, properties) {
      var xref = this.xref;
      var glyphsWidths = [];
      var defaultWidth = 0;
      var glyphsVMetrics = [];
      var defaultVMetrics;
      var i, ii, j, jj, start, code, widths;

      if (properties.composite) {
        defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
        widths = dict.get("W");

        if (widths) {
          for (i = 0, ii = widths.length; i < ii; i++) {
            start = xref.fetchIfRef(widths[i++]);
            code = xref.fetchIfRef(widths[i]);

            if (Array.isArray(code)) {
              for (j = 0, jj = code.length; j < jj; j++) {
                glyphsWidths[start++] = xref.fetchIfRef(code[j]);
              }
            } else {
              var width = xref.fetchIfRef(widths[++i]);

              for (j = start; j <= code; j++) {
                glyphsWidths[j] = width;
              }
            }
          }
        }

        if (properties.vertical) {
          var vmetrics = dict.getArray("DW2") || [880, -1000];
          defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
          vmetrics = dict.get("W2");

          if (vmetrics) {
            for (i = 0, ii = vmetrics.length; i < ii; i++) {
              start = xref.fetchIfRef(vmetrics[i++]);
              code = xref.fetchIfRef(vmetrics[i]);

              if (Array.isArray(code)) {
                for (j = 0, jj = code.length; j < jj; j++) {
                  glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                }
              } else {
                var vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];

                for (j = start; j <= code; j++) {
                  glyphsVMetrics[j] = vmetric;
                }
              }
            }
          }
        }
      } else {
        var firstChar = properties.firstChar;
        widths = dict.get("Widths");

        if (widths) {
          j = firstChar;

          for (i = 0, ii = widths.length; i < ii; i++) {
            glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
          }

          defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
        } else {
          var baseFontName = dict.get("BaseFont");

          if ((0, _primitives.isName)(baseFontName)) {
            var metrics = this.getBaseFontMetrics(baseFontName.name);
            glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
            defaultWidth = metrics.defaultWidth;
          }
        }
      }

      var isMonospace = true;
      var firstWidth = defaultWidth;

      for (var glyph in glyphsWidths) {
        var glyphWidth = glyphsWidths[glyph];

        if (!glyphWidth) {
          continue;
        }

        if (!firstWidth) {
          firstWidth = glyphWidth;
          continue;
        }

        if (firstWidth !== glyphWidth) {
          isMonospace = false;
          break;
        }
      }

      if (isMonospace) {
        properties.flags |= _fonts.FontFlags.FixedPitch;
      }

      properties.defaultWidth = defaultWidth;
      properties.widths = glyphsWidths;
      properties.defaultVMetrics = defaultVMetrics;
      properties.vmetrics = glyphsVMetrics;
    }
  }, {
    key: "isSerifFont",
    value: function isSerifFont(baseFontName) {
      var fontNameWoStyle = baseFontName.split("-")[0];
      return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
    }
  }, {
    key: "getBaseFontMetrics",
    value: function getBaseFontMetrics(name) {
      var defaultWidth = 0;
      var widths = Object.create(null);
      var monospace = false;
      var stdFontMap = (0, _standard_fonts.getStdFontMap)();
      var lookupName = stdFontMap[name] || name;
      var Metrics = (0, _metrics.getMetrics)();

      if (!(lookupName in Metrics)) {
        if (this.isSerifFont(name)) {
          lookupName = "Times-Roman";
        } else {
          lookupName = "Helvetica";
        }
      }

      var glyphWidths = Metrics[lookupName];

      if ((0, _util.isNum)(glyphWidths)) {
        defaultWidth = glyphWidths;
        monospace = true;
      } else {
        widths = glyphWidths();
      }

      return {
        defaultWidth: defaultWidth,
        monospace: monospace,
        widths: widths
      };
    }
  }, {
    key: "buildCharCodeToWidth",
    value: function buildCharCodeToWidth(widthsByGlyphName, properties) {
      var widths = Object.create(null);
      var differences = properties.differences;
      var encoding = properties.defaultEncoding;

      for (var charCode = 0; charCode < 256; charCode++) {
        if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
          widths[charCode] = widthsByGlyphName[differences[charCode]];
          continue;
        }

        if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
          widths[charCode] = widthsByGlyphName[encoding[charCode]];
          continue;
        }
      }

      return widths;
    }
  }, {
    key: "preEvaluateFont",
    value: function preEvaluateFont(dict) {
      var baseDict = dict;
      var type = dict.get("Subtype");

      if (!(0, _primitives.isName)(type)) {
        throw new _util.FormatError("invalid font Subtype");
      }

      var composite = false;
      var uint8array;

      if (type.name === "Type0") {
        var df = dict.get("DescendantFonts");

        if (!df) {
          throw new _util.FormatError("Descendant fonts are not specified");
        }

        dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;

        if (!(dict instanceof _primitives.Dict)) {
          throw new _util.FormatError("Descendant font is not a dictionary.");
        }

        type = dict.get("Subtype");

        if (!(0, _primitives.isName)(type)) {
          throw new _util.FormatError("invalid font Subtype");
        }

        composite = true;
      }

      var descriptor = dict.get("FontDescriptor");

      if (descriptor) {
        var hash = new _murmurhash.MurmurHash3_64();
        var encoding = baseDict.getRaw("Encoding");

        if ((0, _primitives.isName)(encoding)) {
          hash.update(encoding.name);
        } else if ((0, _primitives.isRef)(encoding)) {
          hash.update(encoding.toString());
        } else if ((0, _primitives.isDict)(encoding)) {
          var _iterator5 = _createForOfIteratorHelper(encoding.getRawValues()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var entry = _step5.value;

              if ((0, _primitives.isName)(entry)) {
                hash.update(entry.name);
              } else if ((0, _primitives.isRef)(entry)) {
                hash.update(entry.toString());
              } else if (Array.isArray(entry)) {
                var diffLength = entry.length,
                    diffBuf = new Array(diffLength);

                for (var j = 0; j < diffLength; j++) {
                  var diffEntry = entry[j];

                  if ((0, _primitives.isName)(diffEntry)) {
                    diffBuf[j] = diffEntry.name;
                  } else if ((0, _util.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
                    diffBuf[j] = diffEntry.toString();
                  }
                }

                hash.update(diffBuf.join());
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }

        var firstChar = dict.get("FirstChar") || 0;
        var lastChar = dict.get("LastChar") || (composite ? 0xffff : 0xff);
        hash.update("".concat(firstChar, "-").concat(lastChar));
        var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");

        if ((0, _primitives.isStream)(toUnicode)) {
          var stream = toUnicode.str || toUnicode;
          uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
          hash.update(uint8array);
        } else if ((0, _primitives.isName)(toUnicode)) {
          hash.update(toUnicode.name);
        }

        var widths = dict.get("Widths") || baseDict.get("Widths");

        if (widths) {
          uint8array = new Uint8Array(new Uint32Array(widths).buffer);
          hash.update(uint8array);
        }
      }

      return {
        descriptor: descriptor,
        dict: dict,
        baseDict: baseDict,
        composite: composite,
        type: type.name,
        hash: hash ? hash.hexdigest() : ""
      };
    }
  }, {
    key: "translateFont",
    value: function () {
      var _translateFont = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(preEvaluatedFont) {
        var _this11 = this;

        var baseDict, dict, composite, descriptor, type, maxCharIndex, properties, firstChar, lastChar, baseFontName, metrics, fontNameWoStyle, flags, widths, fontName, baseFont, fontNameStr, baseFontStr, fontFile, subtype, length1, length2, length3, cidEncoding, cMap;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                baseDict = preEvaluatedFont.baseDict;
                dict = preEvaluatedFont.dict;
                composite = preEvaluatedFont.composite;
                descriptor = preEvaluatedFont.descriptor;
                type = preEvaluatedFont.type;
                maxCharIndex = composite ? 0xffff : 0xff;
                firstChar = dict.get("FirstChar") || 0;
                lastChar = dict.get("LastChar") || maxCharIndex;

                if (descriptor) {
                  _context7.next = 25;
                  break;
                }

                if (!(type === "Type3")) {
                  _context7.next = 15;
                  break;
                }

                descriptor = new _primitives.Dict(null);
                descriptor.set("FontName", _primitives.Name.get(type));
                descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
                _context7.next = 25;
                break;

              case 15:
                baseFontName = dict.get("BaseFont");

                if ((0, _primitives.isName)(baseFontName)) {
                  _context7.next = 18;
                  break;
                }

                throw new _util.FormatError("Base font is not specified");

              case 18:
                baseFontName = baseFontName.name.replace(/[,_]/g, "-");
                metrics = this.getBaseFontMetrics(baseFontName);
                fontNameWoStyle = baseFontName.split("-")[0];
                flags = (this.isSerifFont(fontNameWoStyle) ? _fonts.FontFlags.Serif : 0) | (metrics.monospace ? _fonts.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts.FontFlags.Symbolic : _fonts.FontFlags.Nonsymbolic);
                properties = {
                  type: type,
                  name: baseFontName,
                  widths: metrics.widths,
                  defaultWidth: metrics.defaultWidth,
                  flags: flags,
                  firstChar: firstChar,
                  lastChar: lastChar
                };
                widths = dict.get("Widths");
                return _context7.abrupt("return", this.extractDataStructures(dict, dict, properties).then(function (newProperties) {
                  if (widths) {
                    var glyphWidths = [];
                    var j = firstChar;

                    for (var _i = 0, ii = widths.length; _i < ii; _i++) {
                      glyphWidths[j++] = _this11.xref.fetchIfRef(widths[_i]);
                    }

                    newProperties.widths = glyphWidths;
                  } else {
                    newProperties.widths = _this11.buildCharCodeToWidth(metrics.widths, newProperties);
                  }

                  return new _fonts.Font(baseFontName, null, newProperties);
                }));

              case 25:
                fontName = descriptor.get("FontName");
                baseFont = dict.get("BaseFont");

                if ((0, _util.isString)(fontName)) {
                  fontName = _primitives.Name.get(fontName);
                }

                if ((0, _util.isString)(baseFont)) {
                  baseFont = _primitives.Name.get(baseFont);
                }

                if (type !== "Type3") {
                  fontNameStr = fontName && fontName.name;
                  baseFontStr = baseFont && baseFont.name;

                  if (fontNameStr !== baseFontStr) {
                    (0, _util.info)("The FontDescriptor's FontName is \"".concat(fontNameStr, "\" but ") + "should be the same as the Font's BaseFont \"".concat(baseFontStr, "\"."));

                    if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
                      fontName = baseFont;
                    }
                  }
                }

                fontName = fontName || baseFont;

                if ((0, _primitives.isName)(fontName)) {
                  _context7.next = 33;
                  break;
                }

                throw new _util.FormatError("invalid font name");

              case 33:
                _context7.prev = 33;
                fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                _context7.next = 43;
                break;

              case 37:
                _context7.prev = 37;
                _context7.t0 = _context7["catch"](33);

                if (this.options.ignoreErrors) {
                  _context7.next = 41;
                  break;
                }

                throw _context7.t0;

              case 41:
                (0, _util.warn)("translateFont - fetching \"".concat(fontName.name, "\" font file: \"").concat(_context7.t0, "\"."));
                fontFile = new _stream.NullStream();

              case 43:
                if (fontFile) {
                  if (fontFile.dict) {
                    subtype = fontFile.dict.get("Subtype");

                    if (subtype) {
                      subtype = subtype.name;
                    }

                    length1 = fontFile.dict.get("Length1");
                    length2 = fontFile.dict.get("Length2");
                    length3 = fontFile.dict.get("Length3");
                  }
                }

                properties = {
                  type: type,
                  name: fontName.name,
                  subtype: subtype,
                  file: fontFile,
                  length1: length1,
                  length2: length2,
                  length3: length3,
                  loadedName: baseDict.loadedName,
                  composite: composite,
                  fixedPitch: false,
                  fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
                  firstChar: firstChar || 0,
                  lastChar: lastChar || maxCharIndex,
                  bbox: descriptor.getArray("FontBBox"),
                  ascent: descriptor.get("Ascent"),
                  descent: descriptor.get("Descent"),
                  xHeight: descriptor.get("XHeight"),
                  capHeight: descriptor.get("CapHeight"),
                  flags: descriptor.get("Flags"),
                  italicAngle: descriptor.get("ItalicAngle"),
                  isType3Font: false
                };

                if (!composite) {
                  _context7.next = 53;
                  break;
                }

                cidEncoding = baseDict.get("Encoding");

                if ((0, _primitives.isName)(cidEncoding)) {
                  properties.cidEncoding = cidEncoding.name;
                }

                _context7.next = 50;
                return _cmap.CMapFactory.create({
                  encoding: cidEncoding,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                });

              case 50:
                cMap = _context7.sent;
                properties.cMap = cMap;
                properties.vertical = properties.cMap.vertical;

              case 53:
                return _context7.abrupt("return", this.extractDataStructures(dict, baseDict, properties).then(function (newProperties) {
                  _this11.extractWidths(dict, descriptor, newProperties);

                  if (type === "Type3") {
                    newProperties.isType3Font = true;
                  }

                  return new _fonts.Font(fontName.name, fontFile, newProperties);
                }));

              case 54:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[33, 37]]);
      }));

      function translateFont(_x13) {
        return _translateFont.apply(this, arguments);
      }

      return translateFont;
    }()
  }], [{
    key: "buildFontPaths",
    value: function buildFontPaths(font, glyphs, handler) {
      function buildPath(fontChar) {
        if (font.renderer.hasBuiltPath(fontChar)) {
          return;
        }

        handler.send("commonobj", ["".concat(font.loadedName, "_path_").concat(fontChar), "FontPath", font.renderer.getPathJs(fontChar)]);
      }

      var _iterator6 = _createForOfIteratorHelper(glyphs),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var glyph = _step6.value;
          buildPath(glyph.fontChar);
          var accent = glyph.accent;

          if (accent && accent.fontChar) {
            buildPath(accent.fontChar);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }, {
    key: "fallbackFontDict",
    get: function get() {
      var dict = new _primitives.Dict();
      dict.set("BaseFont", _primitives.Name.get("PDFJS-FallbackFont"));
      dict.set("Type", _primitives.Name.get("FallbackType"));
      dict.set("Subtype", _primitives.Name.get("FallbackType"));
      dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
      return (0, _util.shadow)(this, "fallbackFontDict", dict);
    }
  }]);

  return PartialEvaluator;
}();

exports.PartialEvaluator = PartialEvaluator;

var TranslatedFont = /*#__PURE__*/function () {
  function TranslatedFont(_ref9) {
    var loadedName = _ref9.loadedName,
        font = _ref9.font,
        dict = _ref9.dict,
        _ref9$extraProperties = _ref9.extraProperties,
        extraProperties = _ref9$extraProperties === void 0 ? false : _ref9$extraProperties;

    _classCallCheck(this, TranslatedFont);

    this.loadedName = loadedName;
    this.font = font;
    this.dict = dict;
    this._extraProperties = extraProperties;
    this.type3Loaded = null;
    this.type3Dependencies = font.isType3Font ? new Set() : null;
    this.sent = false;
  }

  _createClass(TranslatedFont, [{
    key: "send",
    value: function send(handler) {
      if (this.sent) {
        return;
      }

      this.sent = true;
      handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._extraProperties)]);
    }
  }, {
    key: "fallback",
    value: function fallback(handler) {
      if (!this.font.data) {
        return;
      }

      this.font.disableFontFace = true;
      var glyphs = this.font.glyphCacheValues;
      PartialEvaluator.buildFontPaths(this.font, glyphs, handler);
    }
  }, {
    key: "loadType3Data",
    value: function loadType3Data(evaluator, resources, task) {
      var _this12 = this;

      if (this.type3Loaded) {
        return this.type3Loaded;
      }

      if (!this.font.isType3Font) {
        throw new Error("Must be a Type3 font.");
      }

      var type3Options = Object.create(evaluator.options);
      type3Options.ignoreErrors = false;
      var type3Evaluator = evaluator.clone(type3Options);
      type3Evaluator.parsingType3Font = true;
      var translatedFont = this.font,
          type3Dependencies = this.type3Dependencies;
      var loadCharProcsPromise = Promise.resolve();
      var charProcs = this.dict.get("CharProcs");
      var fontResources = this.dict.get("Resources") || resources;
      var charProcOperatorList = Object.create(null);

      var _iterator7 = _createForOfIteratorHelper(charProcs.getKeys()),
          _step7;

      try {
        var _loop2 = function _loop2() {
          var key = _step7.value;
          loadCharProcsPromise = loadCharProcsPromise.then(function () {
            var glyphStream = charProcs.get(key);
            var operatorList = new _operator_list.OperatorList();
            return type3Evaluator.getOperatorList({
              stream: glyphStream,
              task: task,
              resources: fontResources,
              operatorList: operatorList
            }).then(function () {
              if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
                _this12._removeType3ColorOperators(operatorList);
              }

              charProcOperatorList[key] = operatorList.getIR();

              var _iterator8 = _createForOfIteratorHelper(operatorList.dependencies),
                  _step8;

              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var dependency = _step8.value;
                  type3Dependencies.add(dependency);
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            })["catch"](function (reason) {
              (0, _util.warn)("Type3 font resource \"".concat(key, "\" is not available."));
              var dummyOperatorList = new _operator_list.OperatorList();
              charProcOperatorList[key] = dummyOperatorList.getIR();
            });
          });
        };

        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      this.type3Loaded = loadCharProcsPromise.then(function () {
        translatedFont.charProcOperatorList = charProcOperatorList;
      });
      return this.type3Loaded;
    }
  }, {
    key: "_removeType3ColorOperators",
    value: function _removeType3ColorOperators(operatorList) {
      var i = 1,
          ii = operatorList.length;

      while (i < ii) {
        switch (operatorList.fnArray[i]) {
          case _util.OPS.setStrokeColorSpace:
          case _util.OPS.setFillColorSpace:
          case _util.OPS.setStrokeColor:
          case _util.OPS.setStrokeColorN:
          case _util.OPS.setFillColor:
          case _util.OPS.setFillColorN:
          case _util.OPS.setStrokeGray:
          case _util.OPS.setFillGray:
          case _util.OPS.setStrokeRGBColor:
          case _util.OPS.setFillRGBColor:
          case _util.OPS.setStrokeCMYKColor:
          case _util.OPS.setFillCMYKColor:
          case _util.OPS.shadingFill:
          case _util.OPS.setRenderingIntent:
            operatorList.fnArray.splice(i, 1);
            operatorList.argsArray.splice(i, 1);
            ii--;
            continue;

          case _util.OPS.setGState:
            var _operatorList$argsArr = _slicedToArray(operatorList.argsArray[i], 1),
                _gStateObj = _operatorList$argsArr[0];

            var j = 0,
                jj = _gStateObj.length;

            while (j < jj) {
              var _gStateObj$j = _slicedToArray(_gStateObj[j], 1),
                  gStateKey = _gStateObj$j[0];

              switch (gStateKey) {
                case "TR":
                case "TR2":
                case "HT":
                case "BG":
                case "BG2":
                case "UCR":
                case "UCR2":
                  _gStateObj.splice(j, 1);

                  jj--;
                  continue;
              }

              j++;
            }

            break;
        }

        i++;
      }
    }
  }]);

  return TranslatedFont;
}();

var StateManager = /*#__PURE__*/function () {
  function StateManager() {
    var initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new EvalState();

    _classCallCheck(this, StateManager);

    this.state = initialState;
    this.stateStack = [];
  }

  _createClass(StateManager, [{
    key: "save",
    value: function save() {
      var old = this.state;
      this.stateStack.push(this.state);
      this.state = old.clone();
    }
  }, {
    key: "restore",
    value: function restore() {
      var prev = this.stateStack.pop();

      if (prev) {
        this.state = prev;
      }
    }
  }, {
    key: "transform",
    value: function transform(args) {
      this.state.ctm = _util.Util.transform(this.state.ctm, args);
    }
  }]);

  return StateManager;
}();

var TextState = /*#__PURE__*/function () {
  function TextState() {
    _classCallCheck(this, TextState);

    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.font = null;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.textMatrix = _util.IDENTITY_MATRIX.slice();
    this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }

  _createClass(TextState, [{
    key: "setTextMatrix",
    value: function setTextMatrix(a, b, c, d, e, f) {
      var m = this.textMatrix;
      m[0] = a;
      m[1] = b;
      m[2] = c;
      m[3] = d;
      m[4] = e;
      m[5] = f;
    }
  }, {
    key: "setTextLineMatrix",
    value: function setTextLineMatrix(a, b, c, d, e, f) {
      var m = this.textLineMatrix;
      m[0] = a;
      m[1] = b;
      m[2] = c;
      m[3] = d;
      m[4] = e;
      m[5] = f;
    }
  }, {
    key: "translateTextMatrix",
    value: function translateTextMatrix(x, y) {
      var m = this.textMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
    }
  }, {
    key: "translateTextLineMatrix",
    value: function translateTextLineMatrix(x, y) {
      var m = this.textLineMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
    }
  }, {
    key: "calcTextLineMatrixAdvance",
    value: function calcTextLineMatrixAdvance(a, b, c, d, e, f) {
      var font = this.font;

      if (!font) {
        return null;
      }

      var m = this.textLineMatrix;

      if (!(a === m[0] && b === m[1] && c === m[2] && d === m[3])) {
        return null;
      }

      var txDiff = e - m[4],
          tyDiff = f - m[5];

      if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
        return null;
      }

      var tx,
          ty,
          denominator = a * d - b * c;

      if (font.vertical) {
        tx = -tyDiff * c / denominator;
        ty = tyDiff * a / denominator;
      } else {
        tx = txDiff * d / denominator;
        ty = -txDiff * b / denominator;
      }

      return {
        width: tx,
        height: ty,
        value: font.vertical ? ty : tx
      };
    }
  }, {
    key: "calcRenderMatrix",
    value: function calcRenderMatrix(ctm) {
      var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
      return _util.Util.transform(ctm, _util.Util.transform(this.textMatrix, tsm));
    }
  }, {
    key: "carriageReturn",
    value: function carriageReturn() {
      this.translateTextLineMatrix(0, -this.leading);
      this.textMatrix = this.textLineMatrix.slice();
    }
  }, {
    key: "clone",
    value: function clone() {
      var clone = Object.create(this);
      clone.textMatrix = this.textMatrix.slice();
      clone.textLineMatrix = this.textLineMatrix.slice();
      clone.fontMatrix = this.fontMatrix.slice();
      return clone;
    }
  }]);

  return TextState;
}();

var EvalState = /*#__PURE__*/function () {
  function EvalState() {
    _classCallCheck(this, EvalState);

    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.font = null;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
    this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
  }

  _createClass(EvalState, [{
    key: "clone",
    value: function clone() {
      return Object.create(this);
    }
  }]);

  return EvalState;
}();

var EvaluatorPreprocessor = /*#__PURE__*/function () {
  function EvaluatorPreprocessor(stream, xref) {
    var stateManager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new StateManager();

    _classCallCheck(this, EvaluatorPreprocessor);

    this.parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream, EvaluatorPreprocessor.opMap),
      xref: xref
    });
    this.stateManager = stateManager;
    this.nonProcessedArgs = [];
    this._numInvalidPathOPS = 0;
  }

  _createClass(EvaluatorPreprocessor, [{
    key: "savedStatesDepth",
    get: function get() {
      return this.stateManager.stateStack.length;
    }
  }, {
    key: "read",
    value: function read(operation) {
      var args = operation.args;

      while (true) {
        var obj = this.parser.getObj();

        if (obj instanceof _primitives.Cmd) {
          var cmd = obj.cmd;
          var opSpec = EvaluatorPreprocessor.opMap[cmd];

          if (!opSpec) {
            (0, _util.warn)("Unknown command \"".concat(cmd, "\"."));
            continue;
          }

          var fn = opSpec.id;
          var numArgs = opSpec.numArgs;
          var argsLength = args !== null ? args.length : 0;

          if (!opSpec.variableArgs) {
            if (argsLength !== numArgs) {
              var nonProcessedArgs = this.nonProcessedArgs;

              while (argsLength > numArgs) {
                nonProcessedArgs.push(args.shift());
                argsLength--;
              }

              while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                if (args === null) {
                  args = [];
                }

                args.unshift(nonProcessedArgs.pop());
                argsLength++;
              }
            }

            if (argsLength < numArgs) {
              var partialMsg = "command ".concat(cmd, ": expected ").concat(numArgs, " args, ") + "but received ".concat(argsLength, " args.");

              if (fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
                throw new _util.FormatError("Invalid ".concat(partialMsg));
              }

              (0, _util.warn)("Skipping ".concat(partialMsg));

              if (args !== null) {
                args.length = 0;
              }

              continue;
            }
          } else if (argsLength > numArgs) {
            (0, _util.info)("Command ".concat(cmd, ": expected [0, ").concat(numArgs, "] args, ") + "but received ".concat(argsLength, " args."));
          }

          this.preprocessCommand(fn, args);
          operation.fn = fn;
          operation.args = args;
          return true;
        }

        if (obj === _primitives.EOF) {
          return false;
        }

        if (obj !== null) {
          if (args === null) {
            args = [];
          }

          args.push(obj);

          if (args.length > 33) {
            throw new _util.FormatError("Too many arguments");
          }
        }
      }
    }
  }, {
    key: "preprocessCommand",
    value: function preprocessCommand(fn, args) {
      switch (fn | 0) {
        case _util.OPS.save:
          this.stateManager.save();
          break;

        case _util.OPS.restore:
          this.stateManager.restore();
          break;

        case _util.OPS.transform:
          this.stateManager.transform(args);
          break;
      }
    }
  }], [{
    key: "opMap",
    get: function get() {
      var getOPMap = (0, _core_utils.getLookupTableFactory)(function (t) {
        t.w = {
          id: _util.OPS.setLineWidth,
          numArgs: 1,
          variableArgs: false
        };
        t.J = {
          id: _util.OPS.setLineCap,
          numArgs: 1,
          variableArgs: false
        };
        t.j = {
          id: _util.OPS.setLineJoin,
          numArgs: 1,
          variableArgs: false
        };
        t.M = {
          id: _util.OPS.setMiterLimit,
          numArgs: 1,
          variableArgs: false
        };
        t.d = {
          id: _util.OPS.setDash,
          numArgs: 2,
          variableArgs: false
        };
        t.ri = {
          id: _util.OPS.setRenderingIntent,
          numArgs: 1,
          variableArgs: false
        };
        t.i = {
          id: _util.OPS.setFlatness,
          numArgs: 1,
          variableArgs: false
        };
        t.gs = {
          id: _util.OPS.setGState,
          numArgs: 1,
          variableArgs: false
        };
        t.q = {
          id: _util.OPS.save,
          numArgs: 0,
          variableArgs: false
        };
        t.Q = {
          id: _util.OPS.restore,
          numArgs: 0,
          variableArgs: false
        };
        t.cm = {
          id: _util.OPS.transform,
          numArgs: 6,
          variableArgs: false
        };
        t.m = {
          id: _util.OPS.moveTo,
          numArgs: 2,
          variableArgs: false
        };
        t.l = {
          id: _util.OPS.lineTo,
          numArgs: 2,
          variableArgs: false
        };
        t.c = {
          id: _util.OPS.curveTo,
          numArgs: 6,
          variableArgs: false
        };
        t.v = {
          id: _util.OPS.curveTo2,
          numArgs: 4,
          variableArgs: false
        };
        t.y = {
          id: _util.OPS.curveTo3,
          numArgs: 4,
          variableArgs: false
        };
        t.h = {
          id: _util.OPS.closePath,
          numArgs: 0,
          variableArgs: false
        };
        t.re = {
          id: _util.OPS.rectangle,
          numArgs: 4,
          variableArgs: false
        };
        t.S = {
          id: _util.OPS.stroke,
          numArgs: 0,
          variableArgs: false
        };
        t.s = {
          id: _util.OPS.closeStroke,
          numArgs: 0,
          variableArgs: false
        };
        t.f = {
          id: _util.OPS.fill,
          numArgs: 0,
          variableArgs: false
        };
        t.F = {
          id: _util.OPS.fill,
          numArgs: 0,
          variableArgs: false
        };
        t["f*"] = {
          id: _util.OPS.eoFill,
          numArgs: 0,
          variableArgs: false
        };
        t.B = {
          id: _util.OPS.fillStroke,
          numArgs: 0,
          variableArgs: false
        };
        t["B*"] = {
          id: _util.OPS.eoFillStroke,
          numArgs: 0,
          variableArgs: false
        };
        t.b = {
          id: _util.OPS.closeFillStroke,
          numArgs: 0,
          variableArgs: false
        };
        t["b*"] = {
          id: _util.OPS.closeEOFillStroke,
          numArgs: 0,
          variableArgs: false
        };
        t.n = {
          id: _util.OPS.endPath,
          numArgs: 0,
          variableArgs: false
        };
        t.W = {
          id: _util.OPS.clip,
          numArgs: 0,
          variableArgs: false
        };
        t["W*"] = {
          id: _util.OPS.eoClip,
          numArgs: 0,
          variableArgs: false
        };
        t.BT = {
          id: _util.OPS.beginText,
          numArgs: 0,
          variableArgs: false
        };
        t.ET = {
          id: _util.OPS.endText,
          numArgs: 0,
          variableArgs: false
        };
        t.Tc = {
          id: _util.OPS.setCharSpacing,
          numArgs: 1,
          variableArgs: false
        };
        t.Tw = {
          id: _util.OPS.setWordSpacing,
          numArgs: 1,
          variableArgs: false
        };
        t.Tz = {
          id: _util.OPS.setHScale,
          numArgs: 1,
          variableArgs: false
        };
        t.TL = {
          id: _util.OPS.setLeading,
          numArgs: 1,
          variableArgs: false
        };
        t.Tf = {
          id: _util.OPS.setFont,
          numArgs: 2,
          variableArgs: false
        };
        t.Tr = {
          id: _util.OPS.setTextRenderingMode,
          numArgs: 1,
          variableArgs: false
        };
        t.Ts = {
          id: _util.OPS.setTextRise,
          numArgs: 1,
          variableArgs: false
        };
        t.Td = {
          id: _util.OPS.moveText,
          numArgs: 2,
          variableArgs: false
        };
        t.TD = {
          id: _util.OPS.setLeadingMoveText,
          numArgs: 2,
          variableArgs: false
        };
        t.Tm = {
          id: _util.OPS.setTextMatrix,
          numArgs: 6,
          variableArgs: false
        };
        t["T*"] = {
          id: _util.OPS.nextLine,
          numArgs: 0,
          variableArgs: false
        };
        t.Tj = {
          id: _util.OPS.showText,
          numArgs: 1,
          variableArgs: false
        };
        t.TJ = {
          id: _util.OPS.showSpacedText,
          numArgs: 1,
          variableArgs: false
        };
        t["'"] = {
          id: _util.OPS.nextLineShowText,
          numArgs: 1,
          variableArgs: false
        };
        t['"'] = {
          id: _util.OPS.nextLineSetSpacingShowText,
          numArgs: 3,
          variableArgs: false
        };
        t.d0 = {
          id: _util.OPS.setCharWidth,
          numArgs: 2,
          variableArgs: false
        };
        t.d1 = {
          id: _util.OPS.setCharWidthAndBounds,
          numArgs: 6,
          variableArgs: false
        };
        t.CS = {
          id: _util.OPS.setStrokeColorSpace,
          numArgs: 1,
          variableArgs: false
        };
        t.cs = {
          id: _util.OPS.setFillColorSpace,
          numArgs: 1,
          variableArgs: false
        };
        t.SC = {
          id: _util.OPS.setStrokeColor,
          numArgs: 4,
          variableArgs: true
        };
        t.SCN = {
          id: _util.OPS.setStrokeColorN,
          numArgs: 33,
          variableArgs: true
        };
        t.sc = {
          id: _util.OPS.setFillColor,
          numArgs: 4,
          variableArgs: true
        };
        t.scn = {
          id: _util.OPS.setFillColorN,
          numArgs: 33,
          variableArgs: true
        };
        t.G = {
          id: _util.OPS.setStrokeGray,
          numArgs: 1,
          variableArgs: false
        };
        t.g = {
          id: _util.OPS.setFillGray,
          numArgs: 1,
          variableArgs: false
        };
        t.RG = {
          id: _util.OPS.setStrokeRGBColor,
          numArgs: 3,
          variableArgs: false
        };
        t.rg = {
          id: _util.OPS.setFillRGBColor,
          numArgs: 3,
          variableArgs: false
        };
        t.K = {
          id: _util.OPS.setStrokeCMYKColor,
          numArgs: 4,
          variableArgs: false
        };
        t.k = {
          id: _util.OPS.setFillCMYKColor,
          numArgs: 4,
          variableArgs: false
        };
        t.sh = {
          id: _util.OPS.shadingFill,
          numArgs: 1,
          variableArgs: false
        };
        t.BI = {
          id: _util.OPS.beginInlineImage,
          numArgs: 0,
          variableArgs: false
        };
        t.ID = {
          id: _util.OPS.beginImageData,
          numArgs: 0,
          variableArgs: false
        };
        t.EI = {
          id: _util.OPS.endInlineImage,
          numArgs: 1,
          variableArgs: false
        };
        t.Do = {
          id: _util.OPS.paintXObject,
          numArgs: 1,
          variableArgs: false
        };
        t.MP = {
          id: _util.OPS.markPoint,
          numArgs: 1,
          variableArgs: false
        };
        t.DP = {
          id: _util.OPS.markPointProps,
          numArgs: 2,
          variableArgs: false
        };
        t.BMC = {
          id: _util.OPS.beginMarkedContent,
          numArgs: 1,
          variableArgs: false
        };
        t.BDC = {
          id: _util.OPS.beginMarkedContentProps,
          numArgs: 2,
          variableArgs: false
        };
        t.EMC = {
          id: _util.OPS.endMarkedContent,
          numArgs: 0,
          variableArgs: false
        };
        t.BX = {
          id: _util.OPS.beginCompat,
          numArgs: 0,
          variableArgs: false
        };
        t.EX = {
          id: _util.OPS.endCompat,
          numArgs: 0,
          variableArgs: false
        };
        t.BM = null;
        t.BD = null;
        t["true"] = null;
        t.fa = null;
        t.fal = null;
        t.fals = null;
        t["false"] = null;
        t.nu = null;
        t.nul = null;
        t["null"] = null;
      });
      return (0, _util.shadow)(this, "opMap", getOPMap());
    }
  }, {
    key: "MAX_INVALID_PATH_OPS",
    get: function get() {
      return (0, _util.shadow)(this, "MAX_INVALID_PATH_OPS", 20);
    }
  }]);

  return EvaluatorPreprocessor;
}();

exports.EvaluatorPreprocessor = EvaluatorPreprocessor;

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IdentityCMap = exports.CMapFactory = exports.CMap = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _parser = __w_pdfjs_require__(141);

var _core_utils = __w_pdfjs_require__(138);

var _stream = __w_pdfjs_require__(142);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
var MAX_MAP_RANGE = Math.pow(2, 24) - 1;

var CMap = /*#__PURE__*/function () {
  function CMap() {
    var builtInCMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, CMap);

    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }

  _createClass(CMap, [{
    key: "addCodespaceRange",
    value: function addCodespaceRange(n, low, high) {
      this.codespaceRanges[n - 1].push(low, high);
      this.numCodespaceRanges++;
    }
  }, {
    key: "mapCidRange",
    value: function mapCidRange(low, high, dstLow) {
      if (high - low > MAX_MAP_RANGE) {
        throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
      }

      while (low <= high) {
        this._map[low++] = dstLow++;
      }
    }
  }, {
    key: "mapBfRange",
    value: function mapBfRange(low, high, dstLow) {
      if (high - low > MAX_MAP_RANGE) {
        throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
      }

      var lastByte = dstLow.length - 1;

      while (low <= high) {
        this._map[low++] = dstLow;
        dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
      }
    }
  }, {
    key: "mapBfRangeToArray",
    value: function mapBfRangeToArray(low, high, array) {
      if (high - low > MAX_MAP_RANGE) {
        throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
      }

      var ii = array.length;
      var i = 0;

      while (low <= high && i < ii) {
        this._map[low] = array[i++];
        ++low;
      }
    }
  }, {
    key: "mapOne",
    value: function mapOne(src, dst) {
      this._map[src] = dst;
    }
  }, {
    key: "lookup",
    value: function lookup(code) {
      return this._map[code];
    }
  }, {
    key: "contains",
    value: function contains(code) {
      return this._map[code] !== undefined;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var map = this._map;
      var length = map.length;

      if (length <= 0x10000) {
        for (var i = 0; i < length; i++) {
          if (map[i] !== undefined) {
            callback(i, map[i]);
          }
        }
      } else {
        for (var _i in map) {
          callback(_i, map[_i]);
        }
      }
    }
  }, {
    key: "charCodeOf",
    value: function charCodeOf(value) {
      var map = this._map;

      if (map.length <= 0x10000) {
        return map.indexOf(value);
      }

      for (var charCode in map) {
        if (map[charCode] === value) {
          return charCode | 0;
        }
      }

      return -1;
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return this._map;
    }
  }, {
    key: "readCharCode",
    value: function readCharCode(str, offset, out) {
      var c = 0;
      var codespaceRanges = this.codespaceRanges;

      for (var n = 0, nn = codespaceRanges.length; n < nn; n++) {
        c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
        var codespaceRange = codespaceRanges[n];

        for (var k = 0, kk = codespaceRange.length; k < kk;) {
          var low = codespaceRange[k++];
          var high = codespaceRange[k++];

          if (c >= low && c <= high) {
            out.charcode = c;
            out.length = n + 1;
            return;
          }
        }
      }

      out.charcode = 0;
      out.length = 1;
    }
  }, {
    key: "getCharCodeLength",
    value: function getCharCodeLength(charCode) {
      var codespaceRanges = this.codespaceRanges;

      for (var n = 0, nn = codespaceRanges.length; n < nn; n++) {
        var codespaceRange = codespaceRanges[n];

        for (var k = 0, kk = codespaceRange.length; k < kk;) {
          var low = codespaceRange[k++];
          var high = codespaceRange[k++];

          if (charCode >= low && charCode <= high) {
            return n + 1;
          }
        }
      }

      return 1;
    }
  }, {
    key: "length",
    get: function get() {
      return this._map.length;
    }
  }, {
    key: "isIdentityCMap",
    get: function get() {
      if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
        return false;
      }

      if (this._map.length !== 0x10000) {
        return false;
      }

      for (var i = 0; i < 0x10000; i++) {
        if (this._map[i] !== i) {
          return false;
        }
      }

      return true;
    }
  }]);

  return CMap;
}();

exports.CMap = CMap;

var IdentityCMap = /*#__PURE__*/function (_CMap) {
  _inherits(IdentityCMap, _CMap);

  var _super = _createSuper(IdentityCMap);

  function IdentityCMap(vertical, n) {
    var _this;

    _classCallCheck(this, IdentityCMap);

    _this = _super.call(this);
    _this.vertical = vertical;

    _this.addCodespaceRange(n, 0, 0xffff);

    return _this;
  }

  _createClass(IdentityCMap, [{
    key: "mapCidRange",
    value: function mapCidRange(low, high, dstLow) {
      (0, _util.unreachable)("should not call mapCidRange");
    }
  }, {
    key: "mapBfRange",
    value: function mapBfRange(low, high, dstLow) {
      (0, _util.unreachable)("should not call mapBfRange");
    }
  }, {
    key: "mapBfRangeToArray",
    value: function mapBfRangeToArray(low, high, array) {
      (0, _util.unreachable)("should not call mapBfRangeToArray");
    }
  }, {
    key: "mapOne",
    value: function mapOne(src, dst) {
      (0, _util.unreachable)("should not call mapCidOne");
    }
  }, {
    key: "lookup",
    value: function lookup(code) {
      return Number.isInteger(code) && code <= 0xffff ? code : undefined;
    }
  }, {
    key: "contains",
    value: function contains(code) {
      return Number.isInteger(code) && code <= 0xffff;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      for (var i = 0; i <= 0xffff; i++) {
        callback(i, i);
      }
    }
  }, {
    key: "charCodeOf",
    value: function charCodeOf(value) {
      return Number.isInteger(value) && value <= 0xffff ? value : -1;
    }
  }, {
    key: "getMap",
    value: function getMap() {
      var map = new Array(0x10000);

      for (var i = 0; i <= 0xffff; i++) {
        map[i] = i;
      }

      return map;
    }
  }, {
    key: "length",
    get: function get() {
      return 0x10000;
    }
  }, {
    key: "isIdentityCMap",
    get: function get() {
      (0, _util.unreachable)("should not access .isIdentityCMap");
    }
  }]);

  return IdentityCMap;
}(CMap);

exports.IdentityCMap = IdentityCMap;

var BinaryCMapReader = function BinaryCMapReaderClosure() {
  function hexToInt(a, size) {
    var n = 0;

    for (var i = 0; i <= size; i++) {
      n = n << 8 | a[i];
    }

    return n >>> 0;
  }

  function hexToStr(a, size) {
    if (size === 1) {
      return String.fromCharCode(a[0], a[1]);
    }

    if (size === 3) {
      return String.fromCharCode(a[0], a[1], a[2], a[3]);
    }

    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
  }

  function addHex(a, b, size) {
    var c = 0;

    for (var i = size; i >= 0; i--) {
      c += a[i] + b[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }

  function incHex(a, size) {
    var c = 1;

    for (var i = size; i >= 0 && c > 0; i--) {
      c += a[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }

  var MAX_NUM_SIZE = 16;
  var MAX_ENCODED_NUM_SIZE = 19;

  function BinaryCMapStream(data) {
    this.buffer = data;
    this.pos = 0;
    this.end = data.length;
    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
  }

  BinaryCMapStream.prototype = {
    readByte: function readByte() {
      if (this.pos >= this.end) {
        return -1;
      }

      return this.buffer[this.pos++];
    },
    readNumber: function readNumber() {
      var n = 0;
      var last;

      do {
        var b = this.readByte();

        if (b < 0) {
          throw new _util.FormatError("unexpected EOF in bcmap");
        }

        last = !(b & 0x80);
        n = n << 7 | b & 0x7f;
      } while (!last);

      return n;
    },
    readSigned: function readSigned() {
      var n = this.readNumber();
      return n & 1 ? ~(n >>> 1) : n >>> 1;
    },
    readHex: function readHex(num, size) {
      num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
      this.pos += size + 1;
    },
    readHexNumber: function readHexNumber(num, size) {
      var last;
      var stack = this.tmpBuf,
          sp = 0;

      do {
        var b = this.readByte();

        if (b < 0) {
          throw new _util.FormatError("unexpected EOF in bcmap");
        }

        last = !(b & 0x80);
        stack[sp++] = b & 0x7f;
      } while (!last);

      var i = size,
          buffer = 0,
          bufferSize = 0;

      while (i >= 0) {
        while (bufferSize < 8 && stack.length > 0) {
          buffer = stack[--sp] << bufferSize | buffer;
          bufferSize += 7;
        }

        num[i] = buffer & 255;
        i--;
        buffer >>= 8;
        bufferSize -= 8;
      }
    },
    readHexSigned: function readHexSigned(num, size) {
      this.readHexNumber(num, size);
      var sign = num[size] & 1 ? 255 : 0;
      var c = 0;

      for (var i = 0; i <= size; i++) {
        c = (c & 1) << 8 | num[i];
        num[i] = c >> 1 ^ sign;
      }
    },
    readString: function readString() {
      var len = this.readNumber();
      var s = "";

      for (var i = 0; i < len; i++) {
        s += String.fromCharCode(this.readNumber());
      }

      return s;
    }
  };

  function processBinaryCMap(data, cMap, extend) {
    return new Promise(function (resolve, reject) {
      var stream = new BinaryCMapStream(data);
      var header = stream.readByte();
      cMap.vertical = !!(header & 1);
      var useCMap = null;
      var start = new Uint8Array(MAX_NUM_SIZE);
      var end = new Uint8Array(MAX_NUM_SIZE);

      var _char = new Uint8Array(MAX_NUM_SIZE);

      var charCode = new Uint8Array(MAX_NUM_SIZE);
      var tmp = new Uint8Array(MAX_NUM_SIZE);
      var code;
      var b;

      while ((b = stream.readByte()) >= 0) {
        var type = b >> 5;

        if (type === 7) {
          switch (b & 0x1f) {
            case 0:
              stream.readString();
              break;

            case 1:
              useCMap = stream.readString();
              break;
          }

          continue;
        }

        var sequence = !!(b & 0x10);
        var dataSize = b & 15;

        if (dataSize + 1 > MAX_NUM_SIZE) {
          throw new Error("processBinaryCMap: Invalid dataSize.");
        }

        var ucs2DataSize = 1;
        var subitemsCount = stream.readNumber();
        var i;

        switch (type) {
          case 0:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));

            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            }

            break;

          case 1:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            stream.readNumber();

            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              stream.readNumber();
            }

            break;

          case 2:
            stream.readHex(_char, dataSize);
            code = stream.readNumber();
            cMap.mapOne(hexToInt(_char, dataSize), code);

            for (i = 1; i < subitemsCount; i++) {
              incHex(_char, dataSize);

              if (!sequence) {
                stream.readHexNumber(tmp, dataSize);
                addHex(_char, tmp, dataSize);
              }

              code = stream.readSigned() + (code + 1);
              cMap.mapOne(hexToInt(_char, dataSize), code);
            }

            break;

          case 3:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);

            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);

              if (!sequence) {
                stream.readHexNumber(start, dataSize);
                addHex(start, end, dataSize);
              } else {
                start.set(end);
              }

              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              code = stream.readNumber();
              cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            }

            break;

          case 4:
            stream.readHex(_char, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapOne(hexToInt(_char, ucs2DataSize), hexToStr(charCode, dataSize));

            for (i = 1; i < subitemsCount; i++) {
              incHex(_char, ucs2DataSize);

              if (!sequence) {
                stream.readHexNumber(tmp, ucs2DataSize);
                addHex(_char, tmp, ucs2DataSize);
              }

              incHex(charCode, dataSize);
              stream.readHexSigned(tmp, dataSize);
              addHex(charCode, tmp, dataSize);
              cMap.mapOne(hexToInt(_char, ucs2DataSize), hexToStr(charCode, dataSize));
            }

            break;

          case 5:
            stream.readHex(start, ucs2DataSize);
            stream.readHexNumber(end, ucs2DataSize);
            addHex(end, start, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));

            for (i = 1; i < subitemsCount; i++) {
              incHex(end, ucs2DataSize);

              if (!sequence) {
                stream.readHexNumber(start, ucs2DataSize);
                addHex(start, end, ucs2DataSize);
              } else {
                start.set(end);
              }

              stream.readHexNumber(end, ucs2DataSize);
              addHex(end, start, ucs2DataSize);
              stream.readHex(charCode, dataSize);
              cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            }

            break;

          default:
            reject(new Error("processBinaryCMap: Unknown type: " + type));
            return;
        }
      }

      if (useCMap) {
        resolve(extend(useCMap));
        return;
      }

      resolve(cMap);
    });
  }

  function BinaryCMapReader() {}

  BinaryCMapReader.prototype = {
    process: processBinaryCMap
  };
  return BinaryCMapReader;
}();

var CMapFactory = function CMapFactoryClosure() {
  function strToInt(str) {
    var a = 0;

    for (var i = 0; i < str.length; i++) {
      a = a << 8 | str.charCodeAt(i);
    }

    return a >>> 0;
  }

  function expectString(obj) {
    if (!(0, _util.isString)(obj)) {
      throw new _util.FormatError("Malformed CMap: expected string.");
    }
  }

  function expectInt(obj) {
    if (!Number.isInteger(obj)) {
      throw new _util.FormatError("Malformed CMap: expected int.");
    }
  }

  function parseBfChar(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endbfchar")) {
        return;
      }

      expectString(obj);
      var src = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var dst = obj;
      cMap.mapOne(src, dst);
    }
  }

  function parseBfRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endbfrange")) {
        return;
      }

      expectString(obj);
      var low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var high = strToInt(obj);
      obj = lexer.getObj();

      if (Number.isInteger(obj) || (0, _util.isString)(obj)) {
        var dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
        cMap.mapBfRange(low, high, dstLow);
      } else if ((0, _primitives.isCmd)(obj, "[")) {
        obj = lexer.getObj();
        var array = [];

        while (!(0, _primitives.isCmd)(obj, "]") && !(0, _primitives.isEOF)(obj)) {
          array.push(obj);
          obj = lexer.getObj();
        }

        cMap.mapBfRangeToArray(low, high, array);
      } else {
        break;
      }
    }

    throw new _util.FormatError("Invalid bf range.");
  }

  function parseCidChar(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcidchar")) {
        return;
      }

      expectString(obj);
      var src = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      var dst = obj;
      cMap.mapOne(src, dst);
    }
  }

  function parseCidRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcidrange")) {
        return;
      }

      expectString(obj);
      var low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var high = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      var dstLow = obj;
      cMap.mapCidRange(low, high, dstLow);
    }
  }

  function parseCodespaceRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
        return;
      }

      if (!(0, _util.isString)(obj)) {
        break;
      }

      var low = strToInt(obj);
      obj = lexer.getObj();

      if (!(0, _util.isString)(obj)) {
        break;
      }

      var high = strToInt(obj);
      cMap.addCodespaceRange(obj.length, low, high);
    }

    throw new _util.FormatError("Invalid codespace range.");
  }

  function parseWMode(cMap, lexer) {
    var obj = lexer.getObj();

    if (Number.isInteger(obj)) {
      cMap.vertical = !!obj;
    }
  }

  function parseCMapName(cMap, lexer) {
    var obj = lexer.getObj();

    if ((0, _primitives.isName)(obj) && (0, _util.isString)(obj.name)) {
      cMap.name = obj.name;
    }
  }

  function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
    var previous;
    var embeddedUseCMap;

    objLoop: while (true) {
      try {
        var obj = lexer.getObj();

        if ((0, _primitives.isEOF)(obj)) {
          break;
        } else if ((0, _primitives.isName)(obj)) {
          if (obj.name === "WMode") {
            parseWMode(cMap, lexer);
          } else if (obj.name === "CMapName") {
            parseCMapName(cMap, lexer);
          }

          previous = obj;
        } else if ((0, _primitives.isCmd)(obj)) {
          switch (obj.cmd) {
            case "endcmap":
              break objLoop;

            case "usecmap":
              if ((0, _primitives.isName)(previous)) {
                embeddedUseCMap = previous.name;
              }

              break;

            case "begincodespacerange":
              parseCodespaceRange(cMap, lexer);
              break;

            case "beginbfchar":
              parseBfChar(cMap, lexer);
              break;

            case "begincidchar":
              parseCidChar(cMap, lexer);
              break;

            case "beginbfrange":
              parseBfRange(cMap, lexer);
              break;

            case "begincidrange":
              parseCidRange(cMap, lexer);
              break;
          }
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Invalid cMap data: " + ex);
        continue;
      }
    }

    if (!useCMap && embeddedUseCMap) {
      useCMap = embeddedUseCMap;
    }

    if (useCMap) {
      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
    }

    return Promise.resolve(cMap);
  }

  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function (newCMap) {
      cMap.useCMap = newCMap;

      if (cMap.numCodespaceRanges === 0) {
        var useCodespaceRanges = cMap.useCMap.codespaceRanges;

        for (var i = 0; i < useCodespaceRanges.length; i++) {
          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
        }

        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
      }

      cMap.useCMap.forEach(function (key, value) {
        if (!cMap.contains(key)) {
          cMap.mapOne(key, cMap.useCMap.lookup(key));
        }
      });
      return cMap;
    });
  }

  function createBuiltInCMap(name, fetchBuiltInCMap) {
    if (name === "Identity-H") {
      return Promise.resolve(new IdentityCMap(false, 2));
    } else if (name === "Identity-V") {
      return Promise.resolve(new IdentityCMap(true, 2));
    }

    if (!BUILT_IN_CMAPS.includes(name)) {
      return Promise.reject(new Error("Unknown CMap name: " + name));
    }

    if (!fetchBuiltInCMap) {
      return Promise.reject(new Error("Built-in CMap parameters are not provided."));
    }

    return fetchBuiltInCMap(name).then(function (data) {
      var cMapData = data.cMapData,
          compressionType = data.compressionType;
      var cMap = new CMap(true);

      if (compressionType === _util.CMapCompressionType.BINARY) {
        return new BinaryCMapReader().process(cMapData, cMap, function (useCMap) {
          return extendCMap(cMap, fetchBuiltInCMap, useCMap);
        });
      }

      if (compressionType === _util.CMapCompressionType.NONE) {
        var lexer = new _parser.Lexer(new _stream.Stream(cMapData));
        return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
      }

      return Promise.reject(new Error("TODO: Only BINARY/NONE CMap compression is currently supported."));
    });
  }

  return {
    create: function create(params) {
      return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var encoding, fetchBuiltInCMap, useCMap, cMap, lexer;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                encoding = params.encoding;
                fetchBuiltInCMap = params.fetchBuiltInCMap;
                useCMap = params.useCMap;

                if (!(0, _primitives.isName)(encoding)) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", createBuiltInCMap(encoding.name, fetchBuiltInCMap));

              case 7:
                if (!(0, _primitives.isStream)(encoding)) {
                  _context.next = 11;
                  break;
                }

                cMap = new CMap();
                lexer = new _parser.Lexer(encoding);
                return _context.abrupt("return", parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function (parsedCMap) {
                  if (parsedCMap.isIdentityCMap) {
                    return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                  }

                  return parsedCMap;
                }));

              case 11:
                throw new Error("Encoding required.");

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  };
}();

exports.CMapFactory = CMapFactory;

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFontType = getFontType;
exports.ToUnicodeMap = exports.SEAC_ANALYSIS_ENABLED = exports.IdentityToUnicodeMap = exports.FontFlags = exports.Font = exports.ErrorFont = void 0;

var _util = __w_pdfjs_require__(4);

var _cff_parser = __w_pdfjs_require__(160);

var _glyphlist = __w_pdfjs_require__(163);

var _encodings = __w_pdfjs_require__(162);

var _standard_fonts = __w_pdfjs_require__(164);

var _unicode = __w_pdfjs_require__(165);

var _core_utils = __w_pdfjs_require__(138);

var _font_renderer = __w_pdfjs_require__(166);

var _cmap = __w_pdfjs_require__(158);

var _stream = __w_pdfjs_require__(142);

var _type1_parser = __w_pdfjs_require__(167);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]];
var PDF_GLYPH_SPACE_UNITS = 1000;
var SEAC_ANALYSIS_ENABLED = true;
exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
var EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isMonospace", "isSerifFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"];
var EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
var FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
exports.FontFlags = FontFlags;
var MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];

function adjustWidths(properties) {
  if (!properties.fontMatrix) {
    return;
  }

  if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
    return;
  }

  var scale = 0.001 / properties.fontMatrix[0];
  var glyphsWidths = properties.widths;

  for (var glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }

  properties.defaultWidth *= scale;
}

function adjustToUnicode(properties, builtInEncoding) {
  if (properties.hasIncludedToUnicodeMap) {
    return;
  }

  if (properties.hasEncoding) {
    return;
  }

  if (builtInEncoding === properties.defaultEncoding) {
    return;
  }

  if (properties.toUnicode instanceof IdentityToUnicodeMap) {
    return;
  }

  var toUnicode = [],
      glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

  for (var charCode in builtInEncoding) {
    var glyphName = builtInEncoding[charCode];
    var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);

    if (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }

  properties.toUnicode.amend(toUnicode);
}

function getFontType(type, subtype) {
  switch (type) {
    case "Type1":
      return subtype === "Type1C" ? _util.FontType.TYPE1C : _util.FontType.TYPE1;

    case "CIDFontType0":
      return subtype === "CIDFontType0C" ? _util.FontType.CIDFONTTYPE0C : _util.FontType.CIDFONTTYPE0;

    case "OpenType":
      return _util.FontType.OPENTYPE;

    case "TrueType":
      return _util.FontType.TRUETYPE;

    case "CIDFontType2":
      return _util.FontType.CIDFONTTYPE2;

    case "MMType1":
      return _util.FontType.MMTYPE1;

    case "Type0":
      return _util.FontType.TYPE0;

    default:
      return _util.FontType.UNKNOWN;
  }
}

function recoverGlyphName(name, glyphsUnicodeMap) {
  if (glyphsUnicodeMap[name] !== undefined) {
    return name;
  }

  var unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);

  if (unicode !== -1) {
    for (var key in glyphsUnicodeMap) {
      if (glyphsUnicodeMap[key] === unicode) {
        return key;
      }
    }
  }

  (0, _util.info)("Unable to recover a standard glyph name for: " + name);
  return name;
}

var Glyph = function GlyphClosure() {
  function Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.fontChar = fontChar;
    this.unicode = unicode;
    this.accent = accent;
    this.width = width;
    this.vmetric = vmetric;
    this.operatorListId = operatorListId;
    this.isSpace = isSpace;
    this.isInFont = isInFont;
  }

  Glyph.prototype.matchesForCache = function (fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
  };

  return Glyph;
}();

var ToUnicodeMap = function ToUnicodeMapClosure() {
  function ToUnicodeMap() {
    var cmap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    this._map = cmap;
  }

  ToUnicodeMap.prototype = {
    get length() {
      return this._map.length;
    },

    forEach: function forEach(callback) {
      for (var charCode in this._map) {
        callback(charCode, this._map[charCode].charCodeAt(0));
      }
    },
    has: function has(i) {
      return this._map[i] !== undefined;
    },
    get: function get(i) {
      return this._map[i];
    },
    charCodeOf: function charCodeOf(value) {
      var map = this._map;

      if (map.length <= 0x10000) {
        return map.indexOf(value);
      }

      for (var charCode in map) {
        if (map[charCode] === value) {
          return charCode | 0;
        }
      }

      return -1;
    },
    amend: function amend(map) {
      for (var charCode in map) {
        this._map[charCode] = map[charCode];
      }
    }
  };
  return ToUnicodeMap;
}();

exports.ToUnicodeMap = ToUnicodeMap;

var IdentityToUnicodeMap = function IdentityToUnicodeMapClosure() {
  function IdentityToUnicodeMap(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }

  IdentityToUnicodeMap.prototype = {
    get length() {
      return this.lastChar + 1 - this.firstChar;
    },

    forEach: function forEach(callback) {
      for (var i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
        callback(i, i);
      }
    },
    has: function has(i) {
      return this.firstChar <= i && i <= this.lastChar;
    },
    get: function get(i) {
      if (this.firstChar <= i && i <= this.lastChar) {
        return String.fromCharCode(i);
      }

      return undefined;
    },
    charCodeOf: function charCodeOf(v) {
      return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
    },
    amend: function amend(map) {
      (0, _util.unreachable)("Should not call amend()");
    }
  };
  return IdentityToUnicodeMap;
}();

exports.IdentityToUnicodeMap = IdentityToUnicodeMap;

var OpenTypeFileBuilder = function OpenTypeFileBuilderClosure() {
  function writeInt16(dest, offset, num) {
    dest[offset] = num >> 8 & 0xff;
    dest[offset + 1] = num & 0xff;
  }

  function writeInt32(dest, offset, num) {
    dest[offset] = num >> 24 & 0xff;
    dest[offset + 1] = num >> 16 & 0xff;
    dest[offset + 2] = num >> 8 & 0xff;
    dest[offset + 3] = num & 0xff;
  }

  function writeData(dest, offset, data) {
    var i, ii;

    if (data instanceof Uint8Array) {
      dest.set(data, offset);
    } else if (typeof data === "string") {
      for (i = 0, ii = data.length; i < ii; i++) {
        dest[offset++] = data.charCodeAt(i) & 0xff;
      }
    } else {
      for (i = 0, ii = data.length; i < ii; i++) {
        dest[offset++] = data[i] & 0xff;
      }
    }
  }

  function OpenTypeFileBuilder(sfnt) {
    this.sfnt = sfnt;
    this.tables = Object.create(null);
  }

  OpenTypeFileBuilder.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
    var maxPower2 = 1,
        log2 = 0;

    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log2++;
    }

    var searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log2,
      rangeShift: entrySize * entriesCount - searchRange
    };
  };

  var OTF_HEADER_SIZE = 12;
  var OTF_TABLE_ENTRY_SIZE = 16;
  OpenTypeFileBuilder.prototype = {
    toArray: function OpenTypeFileBuilder_toArray() {
      var sfnt = this.sfnt;
      var tables = this.tables;
      var tablesNames = Object.keys(tables);
      tablesNames.sort();
      var numTables = tablesNames.length;
      var i, j, jj, table, tableName;
      var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
      var tableOffsets = [offset];

      for (i = 0; i < numTables; i++) {
        table = tables[tablesNames[i]];
        var paddedLength = (table.length + 3 & ~3) >>> 0;
        offset += paddedLength;
        tableOffsets.push(offset);
      }

      var file = new Uint8Array(offset);

      for (i = 0; i < numTables; i++) {
        table = tables[tablesNames[i]];
        writeData(file, tableOffsets[i], table);
      }

      if (sfnt === "true") {
        sfnt = (0, _util.string32)(0x00010000);
      }

      file[0] = sfnt.charCodeAt(0) & 0xff;
      file[1] = sfnt.charCodeAt(1) & 0xff;
      file[2] = sfnt.charCodeAt(2) & 0xff;
      file[3] = sfnt.charCodeAt(3) & 0xff;
      writeInt16(file, 4, numTables);
      var searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
      writeInt16(file, 6, searchParams.range);
      writeInt16(file, 8, searchParams.entry);
      writeInt16(file, 10, searchParams.rangeShift);
      offset = OTF_HEADER_SIZE;

      for (i = 0; i < numTables; i++) {
        tableName = tablesNames[i];
        file[offset] = tableName.charCodeAt(0) & 0xff;
        file[offset + 1] = tableName.charCodeAt(1) & 0xff;
        file[offset + 2] = tableName.charCodeAt(2) & 0xff;
        file[offset + 3] = tableName.charCodeAt(3) & 0xff;
        var checksum = 0;

        for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
          var quad = (0, _core_utils.readUint32)(file, j);
          checksum = checksum + quad >>> 0;
        }

        writeInt32(file, offset + 4, checksum);
        writeInt32(file, offset + 8, tableOffsets[i]);
        writeInt32(file, offset + 12, tables[tableName].length);
        offset += OTF_TABLE_ENTRY_SIZE;
      }

      return file;
    },
    addTable: function OpenTypeFileBuilder_addTable(tag, data) {
      if (tag in this.tables) {
        throw new Error("Table " + tag + " already exists");
      }

      this.tables[tag] = data;
    }
  };
  return OpenTypeFileBuilder;
}();

var Font = function FontClosure() {
  function Font(name, file, properties) {
    var charCode;
    this.name = name;
    this.loadedName = properties.loadedName;
    this.isType3Font = properties.isType3Font;
    this.missingFile = false;
    this.glyphCache = Object.create(null);
    this.isSerifFont = !!(properties.flags & FontFlags.Serif);
    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
    var type = properties.type;
    var subtype = properties.subtype;
    this.type = type;
    this.subtype = subtype;
    var fallbackName = "sans-serif";

    if (this.isMonospace) {
      fallbackName = "monospace";
    } else if (this.isSerifFont) {
      fallbackName = "serif";
    }

    this.fallbackName = fallbackName;
    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.cMap = properties.cMap;
    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.fontMatrix = properties.fontMatrix;
    this.bbox = properties.bbox;
    this.defaultEncoding = properties.defaultEncoding;
    this.toUnicode = properties.toUnicode;
    this.fallbackToUnicode = properties.fallbackToUnicode || new ToUnicodeMap();
    this.toFontChar = [];

    if (properties.type === "Type3") {
      for (charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }

      this.fontType = _util.FontType.TYPE3;
      return;
    }

    this.cidEncoding = properties.cidEncoding;
    this.vertical = !!properties.vertical;

    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }

    if (!file || file.isEmpty) {
      if (file) {
        (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
      }

      this.fallbackToSystemFont(properties);
      return;
    }

    var _getFontFileType = getFontFileType(file, properties);

    var _getFontFileType2 = _slicedToArray(_getFontFileType, 2);

    type = _getFontFileType2[0];
    subtype = _getFontFileType2[1];

    if (type !== this.type || subtype !== this.subtype) {
      (0, _util.info)("Inconsistent font file Type/SubType, expected: " + "".concat(this.type, "/").concat(this.subtype, " but found: ").concat(type, "/").concat(subtype, "."));
    }

    try {
      var data;

      switch (type) {
        case "MMType1":
          (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");

        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          var cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
          adjustWidths(properties);
          data = this.convert(name, cff, properties);
          break;

        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          data = this.checkAndRepair(name, file, properties);

          if (this.isOpenType) {
            adjustWidths(properties);
            type = "OpenType";
          }

          break;

        default:
          throw new _util.FormatError("Font ".concat(type, " is not supported"));
      }
    } catch (e) {
      (0, _util.warn)(e);
      this.fallbackToSystemFont(properties);
      return;
    }

    this.data = data;
    this.fontType = getFontType(type, subtype);
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.seacMap = properties.seacMap;
  }

  function int16(b0, b1) {
    return (b0 << 8) + b1;
  }

  function writeSignedInt16(bytes, index, value) {
    bytes[index + 1] = value;
    bytes[index] = value >>> 8;
  }

  function signedInt16(b0, b1) {
    var value = (b0 << 8) + b1;
    return value & 1 << 15 ? value - 0x10000 : value;
  }

  function int32(b0, b1, b2, b3) {
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }

  function string16(value) {
    return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
  }

  function safeString16(value) {
    if (value > 0x7fff) {
      value = 0x7fff;
    } else if (value < -0x8000) {
      value = -0x8000;
    }

    return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
  }

  function isTrueTypeFile(file) {
    var header = file.peekBytes(4);
    return (0, _core_utils.readUint32)(header, 0) === 0x00010000 || (0, _util.bytesToString)(header) === "true";
  }

  function isTrueTypeCollectionFile(file) {
    var header = file.peekBytes(4);
    return (0, _util.bytesToString)(header) === "ttcf";
  }

  function isOpenTypeFile(file) {
    var header = file.peekBytes(4);
    return (0, _util.bytesToString)(header) === "OTTO";
  }

  function isType1File(file) {
    var header = file.peekBytes(2);

    if (header[0] === 0x25 && header[1] === 0x21) {
      return true;
    }

    if (header[0] === 0x80 && header[1] === 0x01) {
      return true;
    }

    return false;
  }

  function isCFFFile(file) {
    var header = file.peekBytes(4);

    if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
      return true;
    }

    return false;
  }

  function getFontFileType(file, _ref) {
    var type = _ref.type,
        subtype = _ref.subtype,
        composite = _ref.composite;
    var fileType, fileSubtype;

    if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
      if (composite) {
        fileType = "CIDFontType2";
      } else {
        fileType = "TrueType";
      }
    } else if (isOpenTypeFile(file)) {
      if (composite) {
        fileType = "CIDFontType2";
      } else {
        fileType = "OpenType";
      }
    } else if (isType1File(file)) {
      if (composite) {
        fileType = "CIDFontType0";
      } else {
        fileType = type === "MMType1" ? "MMType1" : "Type1";
      }
    } else if (isCFFFile(file)) {
      if (composite) {
        fileType = "CIDFontType0";
        fileSubtype = "CIDFontType0C";
      } else {
        fileType = type === "MMType1" ? "MMType1" : "Type1";
        fileSubtype = "Type1C";
      }
    } else {
      (0, _util.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
      fileType = type;
      fileSubtype = subtype;
    }

    return [fileType, fileSubtype];
  }

  function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
    var toFontChar = [],
        unicode;

    for (var i = 0, ii = encoding.length; i < ii; i++) {
      unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);

      if (unicode !== -1) {
        toFontChar[i] = unicode;
      }
    }

    for (var charCode in differences) {
      unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);

      if (unicode !== -1) {
        toFontChar[+charCode] = unicode;
      }
    }

    return toFontChar;
  }

  function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId) {
    var newMap = Object.create(null);
    var toFontChar = [];
    var privateUseAreaIndex = 0;
    var nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
    var privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];

    for (var originalCharCode in charCodeToGlyphId) {
      originalCharCode |= 0;
      var glyphId = charCodeToGlyphId[originalCharCode];

      if (!hasGlyph(glyphId)) {
        continue;
      }

      if (nextAvailableFontCharCode > privateUseOffetEnd) {
        privateUseAreaIndex++;

        if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
          (0, _util.warn)("Ran out of space in font private use area.");
          break;
        }

        nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
        privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
      }

      var fontCharCode = nextAvailableFontCharCode++;

      if (glyphId === 0) {
        glyphId = newGlyphZeroId;
      }

      newMap[fontCharCode] = glyphId;
      toFontChar[originalCharCode] = fontCharCode;
    }

    return {
      toFontChar: toFontChar,
      charCodeToGlyphId: newMap,
      nextAvailableFontCharCode: nextAvailableFontCharCode
    };
  }

  function getRanges(glyphs, numGlyphs) {
    var codes = [];

    for (var charCode in glyphs) {
      if (glyphs[charCode] >= numGlyphs) {
        continue;
      }

      codes.push({
        fontCharCode: charCode | 0,
        glyphId: glyphs[charCode]
      });
    }

    if (codes.length === 0) {
      codes.push({
        fontCharCode: 0,
        glyphId: 0
      });
    }

    codes.sort(function fontGetRangesSort(a, b) {
      return a.fontCharCode - b.fontCharCode;
    });
    var ranges = [];
    var length = codes.length;

    for (var n = 0; n < length;) {
      var start = codes[n].fontCharCode;
      var codeIndices = [codes[n].glyphId];
      ++n;
      var end = start;

      while (n < length && end + 1 === codes[n].fontCharCode) {
        codeIndices.push(codes[n].glyphId);
        ++end;
        ++n;

        if (end === 0xffff) {
          break;
        }
      }

      ranges.push([start, end, codeIndices]);
    }

    return ranges;
  }

  function createCmapTable(glyphs, numGlyphs) {
    var ranges = getRanges(glyphs, numGlyphs);
    var numTables = ranges[ranges.length - 1][1] > 0xffff ? 2 : 1;
    var cmap = "\x00\x00" + string16(numTables) + "\x00\x03" + "\x00\x01" + (0, _util.string32)(4 + numTables * 8);
    var i, ii, j, jj;

    for (i = ranges.length - 1; i >= 0; --i) {
      if (ranges[i][0] <= 0xffff) {
        break;
      }
    }

    var bmpLength = i + 1;

    if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
      ranges[i][1] = 0xfffe;
    }

    var trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
    var segCount = bmpLength + trailingRangesCount;
    var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
    var startCount = "";
    var endCount = "";
    var idDeltas = "";
    var idRangeOffsets = "";
    var glyphsIds = "";
    var bias = 0;
    var range, start, end, codes;

    for (i = 0, ii = bmpLength; i < ii; i++) {
      range = ranges[i];
      start = range[0];
      end = range[1];
      startCount += string16(start);
      endCount += string16(end);
      codes = range[2];
      var contiguous = true;

      for (j = 1, jj = codes.length; j < jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          contiguous = false;
          break;
        }
      }

      if (!contiguous) {
        var offset = (segCount - i) * 2 + bias * 2;
        bias += end - start + 1;
        idDeltas += string16(0);
        idRangeOffsets += string16(offset);

        for (j = 0, jj = codes.length; j < jj; ++j) {
          glyphsIds += string16(codes[j]);
        }
      } else {
        var startCode = codes[0];
        idDeltas += string16(startCode - start & 0xffff);
        idRangeOffsets += string16(0);
      }
    }

    if (trailingRangesCount > 0) {
      endCount += "\xFF\xFF";
      startCount += "\xFF\xFF";
      idDeltas += "\x00\x01";
      idRangeOffsets += "\x00\x00";
    }

    var format314 = "\x00\x00" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\x00\x00" + startCount + idDeltas + idRangeOffsets + glyphsIds;
    var format31012 = "";
    var header31012 = "";

    if (numTables > 1) {
      cmap += "\x00\x03" + "\x00\x0A" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
      format31012 = "";

      for (i = 0, ii = ranges.length; i < ii; i++) {
        range = ranges[i];
        start = range[0];
        codes = range[2];
        var code = codes[0];

        for (j = 1, jj = codes.length; j < jj; ++j) {
          if (codes[j] !== codes[j - 1] + 1) {
            end = range[0] + j - 1;
            format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
            start = end + 1;
            code = codes[j];
          }
        }

        format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
      }

      header31012 = "\x00\x0C" + "\x00\x00" + (0, _util.string32)(format31012.length + 16) + "\x00\x00\x00\x00" + (0, _util.string32)(format31012.length / 12);
    }

    return cmap + "\x00\x04" + string16(format314.length + 4) + format314 + header31012 + format31012;
  }

  function validateOS2Table(os2, file) {
    file.pos = (file.start || 0) + os2.offset;
    var version = file.getUint16();
    file.skip(60);
    var selection = file.getUint16();

    if (version < 4 && selection & 0x0300) {
      return false;
    }

    var firstChar = file.getUint16();
    var lastChar = file.getUint16();

    if (firstChar > lastChar) {
      return false;
    }

    file.skip(6);
    var usWinAscent = file.getUint16();

    if (usWinAscent === 0) {
      return false;
    }

    os2.data[8] = os2.data[9] = 0;
    return true;
  }

  function createOS2Table(properties, charstrings, override) {
    override = override || {
      unitsPerEm: 0,
      yMax: 0,
      yMin: 0,
      ascent: 0,
      descent: 0
    };
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;
    var firstCharIndex = null;
    var lastCharIndex = 0;

    if (charstrings) {
      for (var code in charstrings) {
        code |= 0;

        if (firstCharIndex > code || !firstCharIndex) {
          firstCharIndex = code;
        }

        if (lastCharIndex < code) {
          lastCharIndex = code;
        }

        var position = (0, _unicode.getUnicodeRangeFor)(code);

        if (position < 32) {
          ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
          ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
          ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
          ulUnicodeRange4 |= 1 << position - 96;
        } else {
          throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
        }
      }

      if (lastCharIndex > 0xffff) {
        lastCharIndex = 0xffff;
      }
    } else {
      firstCharIndex = 0;
      lastCharIndex = 255;
    }

    var bbox = properties.bbox || [0, 0, 0, 0];
    var unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
    var scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
    var typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
    var typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));

    if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
      typoDescent = -typoDescent;
    }

    var winAscent = override.yMax || typoAscent;
    var winDescent = -override.yMin || -typoDescent;
    return "\x00\x03" + "\x02\x24" + "\x01\xF4" + "\x00\x05" + "\x00\x00" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x00\x8C" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x01\xDF" + "\x00\x31" + "\x01\x02" + "\x00\x00" + "\x00\x00\x06" + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + "\x00\x00\x00\x00\x00\x00" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "\x2A\x32\x31\x2A" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\x00\x64" + string16(winAscent) + string16(winDescent) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\x00\x03";
  }

  function createPostTable(properties) {
    var angle = Math.floor(properties.italicAngle * Math.pow(2, 16));
    return "\x00\x03\x00\x00" + (0, _util.string32)(angle) + "\x00\x00" + "\x00\x00" + (0, _util.string32)(properties.fixedPitch) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00";
  }

  function createNameTable(name, proto) {
    if (!proto) {
      proto = [[], []];
    }

    var strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || "", proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
    var stringsUnicode = [];
    var i, ii, j, jj, str;

    for (i = 0, ii = strings.length; i < ii; i++) {
      str = proto[1][i] || strings[i];
      var strBufUnicode = [];

      for (j = 0, jj = str.length; j < jj; j++) {
        strBufUnicode.push(string16(str.charCodeAt(j)));
      }

      stringsUnicode.push(strBufUnicode.join(""));
    }

    var names = [strings, stringsUnicode];
    var platforms = ["\x00\x01", "\x00\x03"];
    var encodings = ["\x00\x00", "\x00\x01"];
    var languages = ["\x00\x00", "\x04\x09"];
    var namesRecordCount = strings.length * platforms.length;
    var nameTable = "\x00\x00" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
    var strOffset = 0;

    for (i = 0, ii = platforms.length; i < ii; i++) {
      var strs = names[i];

      for (j = 0, jj = strs.length; j < jj; j++) {
        str = strs[j];
        var nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
        nameTable += nameRecord;
        strOffset += str.length;
      }
    }

    nameTable += strings.join("") + stringsUnicode.join("");
    return nameTable;
  }

  Font.prototype = {
    name: null,
    font: null,
    mimetype: null,
    disableFontFace: false,

    get renderer() {
      var renderer = _font_renderer.FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);

      return (0, _util.shadow)(this, "renderer", renderer);
    },

    exportData: function exportData() {
      var extraProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var exportDataProperties = extraProperties ? [].concat(EXPORT_DATA_PROPERTIES, EXPORT_DATA_EXTRA_PROPERTIES) : EXPORT_DATA_PROPERTIES;
      var data = Object.create(null);
      var property, value;

      var _iterator = _createForOfIteratorHelper(exportDataProperties),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          property = _step.value;
          value = this[property];

          if (value !== undefined) {
            data[property] = value;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return data;
    },
    fallbackToSystemFont: function fallbackToSystemFont(properties) {
      var _this = this;

      this.missingFile = true;
      var name = this.name;
      var type = this.type;
      var subtype = this.subtype;
      var fontName = name.replace(/[,_]/g, "-").replace(/\s/g, "");
      var stdFontMap = (0, _standard_fonts.getStdFontMap)(),
          nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
      var isStandardFont = !!stdFontMap[fontName];
      var isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
      fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
      this.bold = fontName.search(/bold/gi) !== -1;
      this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
      this.black = name.search(/Black/g) !== -1;
      var isNarrow = name.search(/Narrow/g) !== -1;
      this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;

      if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
        var GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)(),
            cidToGidMap = properties.cidToGidMap;
        var map = [];

        for (var charCode in GlyphMapForStandardFonts) {
          map[+charCode] = GlyphMapForStandardFonts[charCode];
        }

        if (/Arial-?Black/i.test(name)) {
          var SupplementalGlyphMapForArialBlack = (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)();

          for (var _charCode in SupplementalGlyphMapForArialBlack) {
            map[+_charCode] = SupplementalGlyphMapForArialBlack[_charCode];
          }
        } else if (/Calibri/i.test(name)) {
          var SupplementalGlyphMapForCalibri = (0, _standard_fonts.getSupplementalGlyphMapForCalibri)();

          for (var _charCode2 in SupplementalGlyphMapForCalibri) {
            map[+_charCode2] = SupplementalGlyphMapForCalibri[_charCode2];
          }
        }

        if (cidToGidMap) {
          for (var _charCode3 in map) {
            var cid = map[_charCode3];

            if (cidToGidMap[cid] !== undefined) {
              map[+_charCode3] = cidToGidMap[cid];
            }
          }
        }

        var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;

        if (!isIdentityUnicode) {
          this.toUnicode.forEach(function (charCode, unicodeCharCode) {
            map[+charCode] = unicodeCharCode;
          });
        }

        this.toFontChar = map;
        this.toUnicode = new ToUnicodeMap(map);
      } else if (/Symbol/i.test(fontName)) {
        this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
      } else if (/Dingbats/i.test(fontName)) {
        if (/Wingdings/i.test(name)) {
          (0, _util.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
        }

        this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
      } else if (isStandardFont) {
        this.toFontChar = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
      } else {
        var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        var _map = [];
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          if (!_this.composite) {
            var glyphName = _this.differences[charCode] || _this.defaultEncoding[charCode];
            var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);

            if (unicode !== -1) {
              unicodeCharCode = unicode;
            }
          }

          _map[+charCode] = unicodeCharCode;
        });

        if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
          if (/Verdana/i.test(name)) {
            var _GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();

            for (var _charCode4 in _GlyphMapForStandardFonts) {
              _map[+_charCode4] = _GlyphMapForStandardFonts[_charCode4];
            }
          }
        }

        this.toFontChar = _map;
      }

      this.loadedName = fontName.split("-")[0];
      this.fontType = getFontType(type, subtype);
    },
    checkAndRepair: function Font_checkAndRepair(name, font, properties) {
      var VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];

      function readTables(file, numTables) {
        var tables = Object.create(null);
        tables["OS/2"] = null;
        tables.cmap = null;
        tables.head = null;
        tables.hhea = null;
        tables.hmtx = null;
        tables.maxp = null;
        tables.name = null;
        tables.post = null;

        for (var i = 0; i < numTables; i++) {
          var table = readTableEntry(file);

          if (!VALID_TABLES.includes(table.tag)) {
            continue;
          }

          if (table.length === 0) {
            continue;
          }

          tables[table.tag] = table;
        }

        return tables;
      }

      function readTableEntry(file) {
        var tag = (0, _util.bytesToString)(file.getBytes(4));
        var checksum = file.getInt32() >>> 0;
        var offset = file.getInt32() >>> 0;
        var length = file.getInt32() >>> 0;
        var previousPosition = file.pos;
        file.pos = file.start ? file.start : 0;
        file.skip(offset);
        var data = file.getBytes(length);
        file.pos = previousPosition;

        if (tag === "head") {
          data[8] = data[9] = data[10] = data[11] = 0;
          data[17] |= 0x20;
        }

        return {
          tag: tag,
          checksum: checksum,
          length: length,
          offset: offset,
          data: data
        };
      }

      function readOpenTypeHeader(ttf) {
        return {
          version: (0, _util.bytesToString)(ttf.getBytes(4)),
          numTables: ttf.getUint16(),
          searchRange: ttf.getUint16(),
          entrySelector: ttf.getUint16(),
          rangeShift: ttf.getUint16()
        };
      }

      function readTrueTypeCollectionHeader(ttc) {
        var ttcTag = (0, _util.bytesToString)(ttc.getBytes(4));
        (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
        var majorVersion = ttc.getUint16();
        var minorVersion = ttc.getUint16();
        var numFonts = ttc.getInt32() >>> 0;
        var offsetTable = [];

        for (var i = 0; i < numFonts; i++) {
          offsetTable.push(ttc.getInt32() >>> 0);
        }

        var header = {
          ttcTag: ttcTag,
          majorVersion: majorVersion,
          minorVersion: minorVersion,
          numFonts: numFonts,
          offsetTable: offsetTable
        };

        switch (majorVersion) {
          case 1:
            return header;

          case 2:
            header.dsigTag = ttc.getInt32() >>> 0;
            header.dsigLength = ttc.getInt32() >>> 0;
            header.dsigOffset = ttc.getInt32() >>> 0;
            return header;
        }

        throw new _util.FormatError("Invalid TrueType Collection majorVersion: ".concat(majorVersion, "."));
      }

      function readTrueTypeCollectionData(ttc, fontName) {
        var _readTrueTypeCollecti = readTrueTypeCollectionHeader(ttc),
            numFonts = _readTrueTypeCollecti.numFonts,
            offsetTable = _readTrueTypeCollecti.offsetTable;

        for (var i = 0; i < numFonts; i++) {
          ttc.pos = (ttc.start || 0) + offsetTable[i];
          var potentialHeader = readOpenTypeHeader(ttc);
          var potentialTables = readTables(ttc, potentialHeader.numTables);

          if (!potentialTables.name) {
            throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
          }

          var nameTable = readNameTable(potentialTables.name);

          for (var j = 0, jj = nameTable.length; j < jj; j++) {
            for (var k = 0, kk = nameTable[j].length; k < kk; k++) {
              var nameEntry = nameTable[j][k];

              if (nameEntry && nameEntry.replace(/\s/g, "") === fontName) {
                return {
                  header: potentialHeader,
                  tables: potentialTables
                };
              }
            }
          }
        }

        throw new _util.FormatError("TrueType Collection does not contain \"".concat(fontName, "\" font."));
      }

      function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
        if (!cmap) {
          (0, _util.warn)("No cmap table available.");
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }

        var segment;
        var start = (file.start ? file.start : 0) + cmap.offset;
        file.pos = start;
        file.skip(2);
        var numTables = file.getUint16();
        var potentialTable;
        var canBreak = false;

        for (var i = 0; i < numTables; i++) {
          var platformId = file.getUint16();
          var encodingId = file.getUint16();
          var offset = file.getInt32() >>> 0;
          var useTable = false;

          if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
            continue;
          }

          if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
            useTable = true;
          } else if (platformId === 1 && encodingId === 0) {
            useTable = true;
          } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
            useTable = true;

            if (!isSymbolicFont) {
              canBreak = true;
            }
          } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
            useTable = true;
            canBreak = true;
          }

          if (useTable) {
            potentialTable = {
              platformId: platformId,
              encodingId: encodingId,
              offset: offset
            };
          }

          if (canBreak) {
            break;
          }
        }

        if (potentialTable) {
          file.pos = start + potentialTable.offset;
        }

        if (!potentialTable || file.peekByte() === -1) {
          (0, _util.warn)("Could not find a preferred cmap table.");
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }

        var format = file.getUint16();
        file.skip(2 + 2);
        var hasShortCmap = false;
        var mappings = [];
        var j, glyphId;

        if (format === 0) {
          for (j = 0; j < 256; j++) {
            var index = file.getByte();

            if (!index) {
              continue;
            }

            mappings.push({
              charCode: j,
              glyphId: index
            });
          }

          hasShortCmap = true;
        } else if (format === 4) {
          var segCount = file.getUint16() >> 1;
          file.skip(6);
          var segIndex,
              segments = [];

          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments.push({
              end: file.getUint16()
            });
          }

          file.skip(2);

          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments[segIndex].start = file.getUint16();
          }

          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments[segIndex].delta = file.getUint16();
          }

          var offsetsCount = 0;

          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segment = segments[segIndex];
            var rangeOffset = file.getUint16();

            if (!rangeOffset) {
              segment.offsetIndex = -1;
              continue;
            }

            var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
            segment.offsetIndex = offsetIndex;
            offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
          }

          var offsets = [];

          for (j = 0; j < offsetsCount; j++) {
            offsets.push(file.getUint16());
          }

          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segment = segments[segIndex];
            start = segment.start;
            var end = segment.end;
            var delta = segment.delta;
            offsetIndex = segment.offsetIndex;

            for (j = start; j <= end; j++) {
              if (j === 0xffff) {
                continue;
              }

              glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
              glyphId = glyphId + delta & 0xffff;
              mappings.push({
                charCode: j,
                glyphId: glyphId
              });
            }
          }
        } else if (format === 6) {
          var firstCode = file.getUint16();
          var entryCount = file.getUint16();

          for (j = 0; j < entryCount; j++) {
            glyphId = file.getUint16();
            var charCode = firstCode + j;
            mappings.push({
              charCode: charCode,
              glyphId: glyphId
            });
          }
        } else {
          (0, _util.warn)("cmap table has unsupported format: " + format);
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }

        mappings.sort(function (a, b) {
          return a.charCode - b.charCode;
        });

        for (i = 1; i < mappings.length; i++) {
          if (mappings[i - 1].charCode === mappings[i].charCode) {
            mappings.splice(i, 1);
            i--;
          }
        }

        return {
          platformId: potentialTable.platformId,
          encodingId: potentialTable.encodingId,
          mappings: mappings,
          hasShortCmap: hasShortCmap
        };
      }

      function sanitizeMetrics(file, header, metrics, numGlyphs, dupFirstEntry) {
        if (!header) {
          if (metrics) {
            metrics.data = null;
          }

          return;
        }

        file.pos = (file.start ? file.start : 0) + header.offset;
        file.pos += 4;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 2;
        file.pos += 8;
        file.pos += 2;
        var numOfMetrics = file.getUint16();

        if (numOfMetrics > numGlyphs) {
          (0, _util.info)("The numOfMetrics (" + numOfMetrics + ") should not be " + "greater than the numGlyphs (" + numGlyphs + ")");
          numOfMetrics = numGlyphs;
          header.data[34] = (numOfMetrics & 0xff00) >> 8;
          header.data[35] = numOfMetrics & 0x00ff;
        }

        var numOfSidebearings = numGlyphs - numOfMetrics;
        var numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);

        if (numMissing > 0) {
          var entries = new Uint8Array(metrics.length + numMissing * 2);
          entries.set(metrics.data);

          if (dupFirstEntry) {
            entries[metrics.length] = metrics.data[2];
            entries[metrics.length + 1] = metrics.data[3];
          }

          metrics.data = entries;
        }
      }

      function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {
        var glyphProfile = {
          length: 0,
          sizeOfInstructions: 0
        };

        if (sourceEnd - sourceStart <= 12) {
          return glyphProfile;
        }

        var glyf = source.subarray(sourceStart, sourceEnd);
        var contoursCount = signedInt16(glyf[0], glyf[1]);

        if (contoursCount < 0) {
          contoursCount = -1;
          writeSignedInt16(glyf, 0, contoursCount);
          dest.set(glyf, destStart);
          glyphProfile.length = glyf.length;
          return glyphProfile;
        }

        var i,
            j = 10,
            flagsCount = 0;

        for (i = 0; i < contoursCount; i++) {
          var endPoint = glyf[j] << 8 | glyf[j + 1];
          flagsCount = endPoint + 1;
          j += 2;
        }

        var instructionsStart = j;
        var instructionsLength = glyf[j] << 8 | glyf[j + 1];
        glyphProfile.sizeOfInstructions = instructionsLength;
        j += 2 + instructionsLength;
        var instructionsEnd = j;
        var coordinatesLength = 0;

        for (i = 0; i < flagsCount; i++) {
          var flag = glyf[j++];

          if (flag & 0xc0) {
            glyf[j - 1] = flag & 0x3f;
          }

          var xLength = 2;

          if (flag & 2) {
            xLength = 1;
          } else if (flag & 16) {
            xLength = 0;
          }

          var yLength = 2;

          if (flag & 4) {
            yLength = 1;
          } else if (flag & 32) {
            yLength = 0;
          }

          var xyLength = xLength + yLength;
          coordinatesLength += xyLength;

          if (flag & 8) {
            var repeat = glyf[j++];
            i += repeat;
            coordinatesLength += repeat * xyLength;
          }
        }

        if (coordinatesLength === 0) {
          return glyphProfile;
        }

        var glyphDataLength = j + coordinatesLength;

        if (glyphDataLength > glyf.length) {
          return glyphProfile;
        }

        if (!hintsValid && instructionsLength > 0) {
          dest.set(glyf.subarray(0, instructionsStart), destStart);
          dest.set([0, 0], destStart + instructionsStart);
          dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
          glyphDataLength -= instructionsLength;

          if (glyf.length - glyphDataLength > 3) {
            glyphDataLength = glyphDataLength + 3 & ~3;
          }

          glyphProfile.length = glyphDataLength;
          return glyphProfile;
        }

        if (glyf.length - glyphDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
          dest.set(glyf.subarray(0, glyphDataLength), destStart);
          glyphProfile.length = glyphDataLength;
          return glyphProfile;
        }

        dest.set(glyf, destStart);
        glyphProfile.length = glyf.length;
        return glyphProfile;
      }

      function sanitizeHead(head, numGlyphs, locaLength) {
        var data = head.data;
        var version = int32(data[0], data[1], data[2], data[3]);

        if (version >> 16 !== 1) {
          (0, _util.info)("Attempting to fix invalid version in head table: " + version);
          data[0] = 0;
          data[1] = 1;
          data[2] = 0;
          data[3] = 0;
        }

        var indexToLocFormat = int16(data[50], data[51]);

        if (indexToLocFormat < 0 || indexToLocFormat > 1) {
          (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
          var numGlyphsPlusOne = numGlyphs + 1;

          if (locaLength === numGlyphsPlusOne << 1) {
            data[50] = 0;
            data[51] = 0;
          } else if (locaLength === numGlyphsPlusOne << 2) {
            data[50] = 0;
            data[51] = 1;
          } else {
            throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
          }
        }
      }

      function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) {
        var itemSize, itemDecode, itemEncode;

        if (isGlyphLocationsLong) {
          itemSize = 4;

          itemDecode = function fontItemDecodeLong(data, offset) {
            return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
          };

          itemEncode = function fontItemEncodeLong(data, offset, value) {
            data[offset] = value >>> 24 & 0xff;
            data[offset + 1] = value >> 16 & 0xff;
            data[offset + 2] = value >> 8 & 0xff;
            data[offset + 3] = value & 0xff;
          };
        } else {
          itemSize = 2;

          itemDecode = function fontItemDecode(data, offset) {
            return data[offset] << 9 | data[offset + 1] << 1;
          };

          itemEncode = function fontItemEncode(data, offset, value) {
            data[offset] = value >> 9 & 0xff;
            data[offset + 1] = value >> 1 & 0xff;
          };
        }

        var numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
        var locaDataSize = itemSize * (1 + numGlyphsOut);
        var locaData = new Uint8Array(locaDataSize);
        locaData.set(loca.data.subarray(0, locaDataSize));
        loca.data = locaData;
        var oldGlyfData = glyf.data;
        var oldGlyfDataLength = oldGlyfData.length;
        var newGlyfData = new Uint8Array(oldGlyfDataLength);
        var i, j;
        var locaEntries = [];

        for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
          var offset = itemDecode(locaData, j);

          if (offset > oldGlyfDataLength) {
            offset = oldGlyfDataLength;
          }

          locaEntries.push({
            index: i,
            offset: offset,
            endOffset: 0
          });
        }

        locaEntries.sort(function (a, b) {
          return a.offset - b.offset;
        });

        for (i = 0; i < numGlyphs; i++) {
          locaEntries[i].endOffset = locaEntries[i + 1].offset;
        }

        locaEntries.sort(function (a, b) {
          return a.index - b.index;
        });
        var missingGlyphs = Object.create(null);
        var writeOffset = 0;
        itemEncode(locaData, 0, writeOffset);

        for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
          var glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid);
          var newLength = glyphProfile.length;

          if (newLength === 0) {
            missingGlyphs[i] = true;
          }

          if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
            maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
          }

          writeOffset += newLength;
          itemEncode(locaData, j, writeOffset);
        }

        if (writeOffset === 0) {
          var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);

          for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
            itemEncode(locaData, j, simpleGlyph.length);
          }

          glyf.data = simpleGlyph;
        } else if (dupFirstEntry) {
          var firstEntryLength = itemDecode(locaData, itemSize);

          if (newGlyfData.length > firstEntryLength + writeOffset) {
            glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
          } else {
            glyf.data = new Uint8Array(firstEntryLength + writeOffset);
            glyf.data.set(newGlyfData.subarray(0, writeOffset));
          }

          glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
          itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
        } else {
          glyf.data = newGlyfData.subarray(0, writeOffset);
        }

        return {
          missingGlyphs: missingGlyphs,
          maxSizeOfInstructions: maxSizeOfInstructions
        };
      }

      function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
        var start = (font.start ? font.start : 0) + post.offset;
        font.pos = start;
        var length = post.length,
            end = start + length;
        var version = font.getInt32();
        font.skip(28);
        var glyphNames;
        var valid = true;
        var i;

        switch (version) {
          case 0x00010000:
            glyphNames = MacStandardGlyphOrdering;
            break;

          case 0x00020000:
            var numGlyphs = font.getUint16();

            if (numGlyphs !== maxpNumGlyphs) {
              valid = false;
              break;
            }

            var glyphNameIndexes = [];

            for (i = 0; i < numGlyphs; ++i) {
              var index = font.getUint16();

              if (index >= 32768) {
                valid = false;
                break;
              }

              glyphNameIndexes.push(index);
            }

            if (!valid) {
              break;
            }

            var customNames = [];
            var strBuf = [];

            while (font.pos < end) {
              var stringLength = font.getByte();
              strBuf.length = stringLength;

              for (i = 0; i < stringLength; ++i) {
                strBuf[i] = String.fromCharCode(font.getByte());
              }

              customNames.push(strBuf.join(""));
            }

            glyphNames = [];

            for (i = 0; i < numGlyphs; ++i) {
              var j = glyphNameIndexes[i];

              if (j < 258) {
                glyphNames.push(MacStandardGlyphOrdering[j]);
                continue;
              }

              glyphNames.push(customNames[j - 258]);
            }

            break;

          case 0x00030000:
            break;

          default:
            (0, _util.warn)("Unknown/unsupported post table version " + version);
            valid = false;

            if (propertiesObj.defaultEncoding) {
              glyphNames = propertiesObj.defaultEncoding;
            }

            break;
        }

        propertiesObj.glyphNames = glyphNames;
        return valid;
      }

      function readNameTable(nameTable) {
        var start = (font.start ? font.start : 0) + nameTable.offset;
        font.pos = start;
        var names = [[], []];
        var length = nameTable.length,
            end = start + length;
        var format = font.getUint16();
        var FORMAT_0_HEADER_LENGTH = 6;

        if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
          return names;
        }

        var numRecords = font.getUint16();
        var stringsStart = font.getUint16();
        var records = [];
        var NAME_RECORD_LENGTH = 12;
        var i, ii;

        for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
          var r = {
            platform: font.getUint16(),
            encoding: font.getUint16(),
            language: font.getUint16(),
            name: font.getUint16(),
            length: font.getUint16(),
            offset: font.getUint16()
          };

          if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 0x409) {
            records.push(r);
          }
        }

        for (i = 0, ii = records.length; i < ii; i++) {
          var record = records[i];

          if (record.length <= 0) {
            continue;
          }

          var pos = start + stringsStart + record.offset;

          if (pos + record.length > end) {
            continue;
          }

          font.pos = pos;
          var nameIndex = record.name;

          if (record.encoding) {
            var str = "";

            for (var j = 0, jj = record.length; j < jj; j += 2) {
              str += String.fromCharCode(font.getUint16());
            }

            names[1][nameIndex] = str;
          } else {
            names[0][nameIndex] = (0, _util.bytesToString)(font.getBytes(record.length));
          }
        }

        return names;
      }

      var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];

      function sanitizeTTProgram(table, ttContext) {
        var data = table.data;
        var i = 0,
            j,
            n,
            b,
            funcId,
            pc,
            lastEndf = 0,
            lastDeff = 0;
        var stack = [];
        var callstack = [];
        var functionsCalled = [];
        var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
        var inFDEF = false,
            ifLevel = 0,
            inELSE = 0;

        for (var ii = data.length; i < ii;) {
          var op = data[i++];

          if (op === 0x40) {
            n = data[i++];

            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (j = 0; j < n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if (op === 0x41) {
            n = data[i++];

            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (j = 0; j < n; j++) {
                b = data[i++];
                stack.push(b << 8 | data[i++]);
              }
            }
          } else if ((op & 0xf8) === 0xb0) {
            n = op - 0xb0 + 1;

            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (j = 0; j < n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if ((op & 0xf8) === 0xb8) {
            n = op - 0xb8 + 1;

            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (j = 0; j < n; j++) {
                b = data[i++];
                stack.push(b << 8 | data[i++]);
              }
            }
          } else if (op === 0x2b && !tooComplexToFollowFunctions) {
            if (!inFDEF && !inELSE) {
              funcId = stack[stack.length - 1];

              if (isNaN(funcId)) {
                (0, _util.info)("TT: CALL empty stack (or invalid entry).");
              } else {
                ttContext.functionsUsed[funcId] = true;

                if (funcId in ttContext.functionsStackDeltas) {
                  var newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];

                  if (newStackLength < 0) {
                    (0, _util.warn)("TT: CALL invalid functions stack delta.");
                    ttContext.hintsValid = false;
                    return;
                  }

                  stack.length = newStackLength;
                } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                  callstack.push({
                    data: data,
                    i: i,
                    stackTop: stack.length - 1
                  });
                  functionsCalled.push(funcId);
                  pc = ttContext.functionsDefined[funcId];

                  if (!pc) {
                    (0, _util.warn)("TT: CALL non-existent function");
                    ttContext.hintsValid = false;
                    return;
                  }

                  data = pc.data;
                  i = pc.i;
                }
              }
            }
          } else if (op === 0x2c && !tooComplexToFollowFunctions) {
            if (inFDEF || inELSE) {
              (0, _util.warn)("TT: nested FDEFs not allowed");
              tooComplexToFollowFunctions = true;
            }

            inFDEF = true;
            lastDeff = i;
            funcId = stack.pop();
            ttContext.functionsDefined[funcId] = {
              data: data,
              i: i
            };
          } else if (op === 0x2d) {
            if (inFDEF) {
              inFDEF = false;
              lastEndf = i;
            } else {
              pc = callstack.pop();

              if (!pc) {
                (0, _util.warn)("TT: ENDF bad stack");
                ttContext.hintsValid = false;
                return;
              }

              funcId = functionsCalled.pop();
              data = pc.data;
              i = pc.i;
              ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
            }
          } else if (op === 0x89) {
            if (inFDEF || inELSE) {
              (0, _util.warn)("TT: nested IDEFs not allowed");
              tooComplexToFollowFunctions = true;
            }

            inFDEF = true;
            lastDeff = i;
          } else if (op === 0x58) {
            ++ifLevel;
          } else if (op === 0x1b) {
            inELSE = ifLevel;
          } else if (op === 0x59) {
            if (inELSE === ifLevel) {
              inELSE = 0;
            }

            --ifLevel;
          } else if (op === 0x1c) {
            if (!inFDEF && !inELSE) {
              var offset = stack[stack.length - 1];

              if (offset > 0) {
                i += offset - 1;
              }
            }
          }

          if (!inFDEF && !inELSE) {
            var stackDelta = 0;

            if (op <= 0x8e) {
              stackDelta = TTOpsStackDeltas[op];
            } else if (op >= 0xc0 && op <= 0xdf) {
              stackDelta = -1;
            } else if (op >= 0xe0) {
              stackDelta = -2;
            }

            if (op >= 0x71 && op <= 0x75) {
              n = stack.pop();

              if (!isNaN(n)) {
                stackDelta = -n * 2;
              }
            }

            while (stackDelta < 0 && stack.length > 0) {
              stack.pop();
              stackDelta++;
            }

            while (stackDelta > 0) {
              stack.push(NaN);
              stackDelta--;
            }
          }
        }

        ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
        var content = [data];

        if (i > data.length) {
          content.push(new Uint8Array(i - data.length));
        }

        if (lastDeff > lastEndf) {
          (0, _util.warn)("TT: complementing a missing function tail");
          content.push(new Uint8Array([0x22, 0x2d]));
        }

        foldTTTable(table, content);
      }

      function checkInvalidFunctions(ttContext, maxFunctionDefs) {
        if (ttContext.tooComplexToFollowFunctions) {
          return;
        }

        if (ttContext.functionsDefined.length > maxFunctionDefs) {
          (0, _util.warn)("TT: more functions defined than expected");
          ttContext.hintsValid = false;
          return;
        }

        for (var j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
          if (j > maxFunctionDefs) {
            (0, _util.warn)("TT: invalid function id: " + j);
            ttContext.hintsValid = false;
            return;
          }

          if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
            (0, _util.warn)("TT: undefined function: " + j);
            ttContext.hintsValid = false;
            return;
          }
        }
      }

      function foldTTTable(table, content) {
        if (content.length > 1) {
          var newLength = 0;
          var j, jj;

          for (j = 0, jj = content.length; j < jj; j++) {
            newLength += content[j].length;
          }

          newLength = newLength + 3 & ~3;
          var result = new Uint8Array(newLength);
          var pos = 0;

          for (j = 0, jj = content.length; j < jj; j++) {
            result.set(content[j], pos);
            pos += content[j].length;
          }

          table.data = result;
          table.length = newLength;
        }
      }

      function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
        var ttContext = {
          functionsDefined: [],
          functionsUsed: [],
          functionsStackDeltas: [],
          tooComplexToFollowFunctions: false,
          hintsValid: true
        };

        if (fpgm) {
          sanitizeTTProgram(fpgm, ttContext);
        }

        if (prep) {
          sanitizeTTProgram(prep, ttContext);
        }

        if (fpgm) {
          checkInvalidFunctions(ttContext, maxFunctionDefs);
        }

        if (cvt && cvt.length & 1) {
          var cvtData = new Uint8Array(cvt.length + 1);
          cvtData.set(cvt.data);
          cvt.data = cvtData;
        }

        return ttContext.hintsValid;
      }

      font = new _stream.Stream(new Uint8Array(font.getBytes()));
      var header, tables;

      if (isTrueTypeCollectionFile(font)) {
        var ttcData = readTrueTypeCollectionData(font, this.name);
        header = ttcData.header;
        tables = ttcData.tables;
      } else {
        header = readOpenTypeHeader(font);
        tables = readTables(font, header.numTables);
      }

      var cff, cffFile;
      var isTrueType = !tables["CFF "];

      if (!isTrueType) {
        var isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));

        if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
          cffFile = new _stream.Stream(tables["CFF "].data);
          cff = new CFFFont(cffFile, properties);
          adjustWidths(properties);
          return this.convert(name, cff, properties);
        }

        delete tables.glyf;
        delete tables.loca;
        delete tables.fpgm;
        delete tables.prep;
        delete tables["cvt "];
        this.isOpenType = true;
      } else {
        if (!tables.loca) {
          throw new _util.FormatError('Required "loca" table is not found');
        }

        if (!tables.glyf) {
          (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
          tables.glyf = {
            tag: "glyf",
            data: new Uint8Array(0)
          };
        }

        this.isOpenType = false;
      }

      if (!tables.maxp) {
        throw new _util.FormatError('Required "maxp" table is not found');
      }

      font.pos = (font.start || 0) + tables.maxp.offset;
      var version = font.getInt32();
      var numGlyphs = font.getUint16();
      var numGlyphsOut = numGlyphs + 1;
      var dupFirstEntry = true;

      if (numGlyphsOut > 0xffff) {
        dupFirstEntry = false;
        numGlyphsOut = numGlyphs;
        (0, _util.warn)("Not enough space in glyfs to duplicate first glyph.");
      }

      var maxFunctionDefs = 0;
      var maxSizeOfInstructions = 0;

      if (version >= 0x00010000 && tables.maxp.length >= 22) {
        font.pos += 8;
        var maxZones = font.getUint16();

        if (maxZones > 2) {
          tables.maxp.data[14] = 0;
          tables.maxp.data[15] = 2;
        }

        font.pos += 4;
        maxFunctionDefs = font.getUint16();
        font.pos += 4;
        maxSizeOfInstructions = font.getUint16();
      }

      tables.maxp.data[4] = numGlyphsOut >> 8;
      tables.maxp.data[5] = numGlyphsOut & 255;
      var hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);

      if (!hintsValid) {
        delete tables.fpgm;
        delete tables.prep;
        delete tables["cvt "];
      }

      sanitizeMetrics(font, tables.hhea, tables.hmtx, numGlyphsOut, dupFirstEntry);

      if (!tables.head) {
        throw new _util.FormatError('Required "head" table is not found');
      }

      sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
      var missingGlyphs = Object.create(null);

      if (isTrueType) {
        var isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
        var glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
        missingGlyphs = glyphsInfo.missingGlyphs;

        if (version >= 0x00010000 && tables.maxp.length >= 22) {
          tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
          tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
        }
      }

      if (!tables.hhea) {
        throw new _util.FormatError('Required "hhea" table is not found');
      }

      if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
        tables.hhea.data[10] = 0xff;
        tables.hhea.data[11] = 0xff;
      }

      var metricsOverride = {
        unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
        yMax: int16(tables.head.data[42], tables.head.data[43]),
        yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
        ascent: int16(tables.hhea.data[4], tables.hhea.data[5]),
        descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7])
      };
      this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
      this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;

      if (tables.post) {
        readPostScriptTable(tables.post, properties, numGlyphs);
      }

      tables.post = {
        tag: "post",
        data: createPostTable(properties)
      };
      var charCodeToGlyphId = [];

      function hasGlyph(glyphId) {
        return !missingGlyphs[glyphId];
      }

      if (properties.composite) {
        var cidToGidMap = properties.cidToGidMap || [];
        var isCidToGidMapEmpty = cidToGidMap.length === 0;
        properties.cMap.forEach(function (charCode, cid) {
          if (cid > 0xffff) {
            throw new _util.FormatError("Max size of CID is 65,535");
          }

          var glyphId = -1;

          if (isCidToGidMapEmpty) {
            glyphId = cid;
          } else if (cidToGidMap[cid] !== undefined) {
            glyphId = cidToGidMap[cid];
          }

          if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
            charCodeToGlyphId[charCode] = glyphId;
          }
        });
      } else {
        var cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
        var cmapPlatformId = cmapTable.platformId;
        var cmapEncodingId = cmapTable.encodingId;
        var cmapMappings = cmapTable.mappings;
        var cmapMappingsLength = cmapMappings.length;
        var baseEncoding = [];

        if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
          baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
        }

        if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
          var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

          for (var charCode = 0; charCode < 256; charCode++) {
            var glyphName, standardGlyphName;

            if (this.differences && charCode in this.differences) {
              glyphName = this.differences[charCode];
            } else if (charCode in baseEncoding && baseEncoding[charCode] !== "") {
              glyphName = baseEncoding[charCode];
            } else {
              glyphName = _encodings.StandardEncoding[charCode];
            }

            if (!glyphName) {
              continue;
            }

            standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
            var unicodeOrCharCode;

            if (cmapPlatformId === 3 && cmapEncodingId === 1) {
              unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
            } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
              unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
            }

            for (var i = 0; i < cmapMappingsLength; ++i) {
              if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                continue;
              }

              charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
              break;
            }
          }
        } else if (cmapPlatformId === 0) {
          for (var _i2 = 0; _i2 < cmapMappingsLength; ++_i2) {
            charCodeToGlyphId[cmapMappings[_i2].charCode] = cmapMappings[_i2].glyphId;
          }
        } else {
          for (var _i3 = 0; _i3 < cmapMappingsLength; ++_i3) {
            var _charCode5 = cmapMappings[_i3].charCode;

            if (cmapPlatformId === 3 && _charCode5 >= 0xf000 && _charCode5 <= 0xf0ff) {
              _charCode5 &= 0xff;
            }

            charCodeToGlyphId[_charCode5] = cmapMappings[_i3].glyphId;
          }
        }

        if (properties.glyphNames && baseEncoding.length) {
          for (var _i4 = 0; _i4 < 256; ++_i4) {
            if (charCodeToGlyphId[_i4] === undefined && baseEncoding[_i4]) {
              glyphName = baseEncoding[_i4];
              var glyphId = properties.glyphNames.indexOf(glyphName);

              if (glyphId > 0 && hasGlyph(glyphId)) {
                charCodeToGlyphId[_i4] = glyphId;
              }
            }
          }
        }
      }

      if (charCodeToGlyphId.length === 0) {
        charCodeToGlyphId[0] = 0;
      }

      var glyphZeroId = numGlyphsOut - 1;

      if (!dupFirstEntry) {
        glyphZeroId = 0;
      }

      var newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      tables.cmap = {
        tag: "cmap",
        data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphsOut)
      };

      if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
        tables["OS/2"] = {
          tag: "OS/2",
          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }

      if (!isTrueType) {
        try {
          cffFile = new _stream.Stream(tables["CFF "].data);
          var parser = new _cff_parser.CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
          cff = parser.parse();
          cff.duplicateFirstGlyph();
          var compiler = new _cff_parser.CFFCompiler(cff);
          tables["CFF "].data = compiler.compile();
        } catch (e) {
          (0, _util.warn)("Failed to compile font " + properties.loadedName);
        }
      }

      if (!tables.name) {
        tables.name = {
          tag: "name",
          data: createNameTable(this.name)
        };
      } else {
        var namePrototype = readNameTable(tables.name);
        tables.name.data = createNameTable(name, namePrototype);
      }

      var builder = new OpenTypeFileBuilder(header.version);

      for (var tableTag in tables) {
        builder.addTable(tableTag, tables[tableTag].data);
      }

      return builder.toArray();
    },
    convert: function Font_convert(fontName, font, properties) {
      properties.fixedPitch = false;

      if (properties.builtInEncoding) {
        adjustToUnicode(properties, properties.builtInEncoding);
      }

      var glyphZeroId = 1;

      if (font instanceof CFFFont) {
        glyphZeroId = font.numGlyphs - 1;
      }

      var mapping = font.getGlyphMapping(properties);
      var newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      var numGlyphs = font.numGlyphs;

      function getCharCodes(charCodeToGlyphId, glyphId) {
        var charCodes = null;

        for (var charCode in charCodeToGlyphId) {
          if (glyphId === charCodeToGlyphId[charCode]) {
            if (!charCodes) {
              charCodes = [];
            }

            charCodes.push(charCode | 0);
          }
        }

        return charCodes;
      }

      function createCharCode(charCodeToGlyphId, glyphId) {
        for (var charCode in charCodeToGlyphId) {
          if (glyphId === charCodeToGlyphId[charCode]) {
            return charCode | 0;
          }
        }

        newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
        return newMapping.nextAvailableFontCharCode++;
      }

      var seacs = font.seacs;

      if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
        var matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
        var charset = font.getCharset();
        var seacMap = Object.create(null);

        for (var glyphId in seacs) {
          glyphId |= 0;
          var seac = seacs[glyphId];
          var baseGlyphName = _encodings.StandardEncoding[seac[2]];
          var accentGlyphName = _encodings.StandardEncoding[seac[3]];
          var baseGlyphId = charset.indexOf(baseGlyphName);
          var accentGlyphId = charset.indexOf(accentGlyphName);

          if (baseGlyphId < 0 || accentGlyphId < 0) {
            continue;
          }

          var accentOffset = {
            x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
            y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
          };
          var charCodes = getCharCodes(mapping, glyphId);

          if (!charCodes) {
            continue;
          }

          for (var i = 0, ii = charCodes.length; i < ii; i++) {
            var charCode = charCodes[i];
            var charCodeToGlyphId = newMapping.charCodeToGlyphId;
            var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
            var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
            seacMap[charCode] = {
              baseFontCharCode: baseFontCharCode,
              accentFontCharCode: accentFontCharCode,
              accentOffset: accentOffset
            };
          }
        }

        properties.seacMap = seacMap;
      }

      var unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
      var builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
      builder.addTable("CFF ", font.data);
      builder.addTable("OS/2", createOS2Table(properties, newMapping.charCodeToGlyphId));
      builder.addTable("cmap", createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
      builder.addTable("head", "\x00\x01\x00\x00" + "\x00\x00\x10\x00" + "\x00\x00\x00\x00" + "\x5F\x0F\x3C\xF5" + "\x00\x00" + safeString16(unitsPerEm) + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00" + safeString16(properties.descent) + "\x0F\xFF" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\x00\x11" + "\x00\x00" + "\x00\x00" + "\x00\x00");
      builder.addTable("hhea", "\x00\x01\x00\x00" + safeString16(properties.ascent) + safeString16(properties.descent) + "\x00\x00" + "\xFF\xFF" + "\x00\x00" + "\x00\x00" + "\x00\x00" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + string16(numGlyphs));
      builder.addTable("hmtx", function fontFieldsHmtx() {
        var charstrings = font.charstrings;
        var cffWidths = font.cff ? font.cff.widths : null;
        var hmtx = "\x00\x00\x00\x00";

        for (var _i5 = 1, _ii = numGlyphs; _i5 < _ii; _i5++) {
          var width = 0;

          if (charstrings) {
            var charstring = charstrings[_i5 - 1];
            width = "width" in charstring ? charstring.width : 0;
          } else if (cffWidths) {
            width = Math.ceil(cffWidths[_i5] || 0);
          }

          hmtx += string16(width) + string16(0);
        }

        return hmtx;
      }());
      builder.addTable("maxp", "\x00\x00\x50\x00" + string16(numGlyphs));
      builder.addTable("name", createNameTable(fontName));
      builder.addTable("post", createPostTable(properties));
      return builder.toArray();
    },

    get spaceWidth() {
      var possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
      var width;

      for (var i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
        var glyphName = possibleSpaceReplacements[i];

        if (glyphName in this.widths) {
          width = this.widths[glyphName];
          break;
        }

        var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        var glyphUnicode = glyphsUnicodeMap[glyphName];
        var charcode = 0;

        if (this.composite && this.cMap.contains(glyphUnicode)) {
          charcode = this.cMap.lookup(glyphUnicode);
        }

        if (!charcode && this.toUnicode) {
          charcode = this.toUnicode.charCodeOf(glyphUnicode);
        }

        if (charcode <= 0) {
          charcode = glyphUnicode;
        }

        width = this.widths[charcode];

        if (width) {
          break;
        }
      }

      width = width || this.defaultWidth;
      return (0, _util.shadow)(this, "spaceWidth", width);
    },

    _charToGlyph: function _charToGlyph(charcode) {
      var isSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var fontCharCode, width, operatorListId;
      var widthCode = charcode;

      if (this.cMap && this.cMap.contains(charcode)) {
        widthCode = this.cMap.lookup(charcode);
      }

      width = this.widths[widthCode];
      width = (0, _util.isNum)(width) ? width : this.defaultWidth;
      var vmetric = this.vmetrics && this.vmetrics[widthCode];
      var unicode = this.toUnicode.get(charcode) || this.fallbackToUnicode.get(charcode) || charcode;

      if (typeof unicode === "number") {
        unicode = String.fromCharCode(unicode);
      }

      var isInFont = (charcode in this.toFontChar);
      fontCharCode = this.toFontChar[charcode] || charcode;

      if (this.missingFile) {
        var glyphName = this.differences[charcode] || this.defaultEncoding[charcode];

        if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
          fontCharCode = 0x20;
        }

        fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
      }

      if (this.isType3Font) {
        operatorListId = fontCharCode;
      }

      var accent = null;

      if (this.seacMap && this.seacMap[charcode]) {
        isInFont = true;
        var seac = this.seacMap[charcode];
        fontCharCode = seac.baseFontCharCode;
        accent = {
          fontChar: String.fromCodePoint(seac.accentFontCharCode),
          offset: seac.accentOffset
        };
      }

      var fontChar = "";

      if (typeof fontCharCode === "number") {
        if (fontCharCode <= 0x10ffff) {
          fontChar = String.fromCodePoint(fontCharCode);
        } else {
          (0, _util.warn)("charToGlyph - invalid fontCharCode: ".concat(fontCharCode));
        }
      }

      var glyph = this.glyphCache[charcode];

      if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
        glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
        this.glyphCache[charcode] = glyph;
      }

      return glyph;
    },
    charsToGlyphs: function Font_charsToGlyphs(chars) {
      var charsCache = this.charsCache;
      var glyphs, glyph, charcode;

      if (charsCache) {
        glyphs = charsCache[chars];

        if (glyphs) {
          return glyphs;
        }
      }

      if (!charsCache) {
        charsCache = this.charsCache = Object.create(null);
      }

      glyphs = [];
      var charsCacheKey = chars;
      var i = 0,
          ii;

      if (this.cMap) {
        var c = Object.create(null);

        while (i < chars.length) {
          this.cMap.readCharCode(chars, i, c);
          charcode = c.charcode;
          var length = c.length;
          i += length;
          var isSpace = length === 1 && chars.charCodeAt(i - 1) === 0x20;
          glyph = this._charToGlyph(charcode, isSpace);
          glyphs.push(glyph);
        }
      } else {
        for (i = 0, ii = chars.length; i < ii; ++i) {
          charcode = chars.charCodeAt(i);
          glyph = this._charToGlyph(charcode, charcode === 0x20);
          glyphs.push(glyph);
        }
      }

      return charsCache[charsCacheKey] = glyphs;
    },
    getCharPositions: function getCharPositions(chars) {
      var positions = [];

      if (this.cMap) {
        var c = Object.create(null);
        var i = 0;

        while (i < chars.length) {
          this.cMap.readCharCode(chars, i, c);
          var length = c.length;
          positions.push([i, i + length]);
          i += length;
        }
      } else {
        for (var _i6 = 0, ii = chars.length; _i6 < ii; ++_i6) {
          positions.push([_i6, _i6 + 1]);
        }
      }

      return positions;
    },

    get glyphCacheValues() {
      return Object.values(this.glyphCache);
    },

    encodeString: function encodeString(str) {
      var buffers = [];
      var currentBuf = [];

      var hasCurrentBufErrors = function hasCurrentBufErrors() {
        return buffers.length % 2 === 1;
      };

      for (var i = 0, ii = str.length; i < ii; i++) {
        var unicode = str.codePointAt(i);

        if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
          i++;
        }

        if (this.toUnicode) {
          var _char = String.fromCodePoint(unicode);

          var charCode = this.toUnicode.charCodeOf(_char);

          if (charCode !== -1) {
            if (hasCurrentBufErrors()) {
              buffers.push(currentBuf.join(""));
              currentBuf.length = 0;
            }

            var charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;

            for (var j = charCodeLength - 1; j >= 0; j--) {
              currentBuf.push(String.fromCharCode(charCode >> 8 * j & 0xff));
            }

            continue;
          }
        }

        if (!hasCurrentBufErrors()) {
          buffers.push(currentBuf.join(""));
          currentBuf.length = 0;
        }

        currentBuf.push(String.fromCodePoint(unicode));
      }

      buffers.push(currentBuf.join(""));
      return buffers;
    }
  };
  return Font;
}();

exports.Font = Font;

var ErrorFont = function ErrorFontClosure() {
  function ErrorFont(error) {
    this.error = error;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }

  ErrorFont.prototype = {
    charsToGlyphs: function ErrorFont_charsToGlyphs() {
      return [];
    },
    encodeString: function ErrorFont_encodeString(chars) {
      return [chars];
    },
    exportData: function exportData() {
      var extraProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return {
        error: this.error
      };
    }
  };
  return ErrorFont;
}();

exports.ErrorFont = ErrorFont;

function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
  var charCodeToGlyphId = Object.create(null);
  var glyphId, charCode, baseEncoding;
  var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);

  if (properties.baseEncodingName) {
    baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);

    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  } else if (isSymbolicFont) {
    for (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } else {
    baseEncoding = _encodings.StandardEncoding;

    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }

  var differences = properties.differences,
      glyphsUnicodeMap;

  if (differences) {
    for (charCode in differences) {
      var glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);

      if (glyphId === -1) {
        if (!glyphsUnicodeMap) {
          glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        }

        var standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);

        if (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }

  return charCodeToGlyphId;
}

var Type1Font = function Type1FontClosure() {
  function findBlock(streamBytes, signature, startIndex) {
    var streamBytesLength = streamBytes.length;
    var signatureLength = signature.length;
    var scanLength = streamBytesLength - signatureLength;
    var i = startIndex,
        j,
        found = false;

    while (i < scanLength) {
      j = 0;

      while (j < signatureLength && streamBytes[i + j] === signature[j]) {
        j++;
      }

      if (j >= signatureLength) {
        i += j;

        while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
          i++;
        }

        found = true;
        break;
      }

      i++;
    }

    return {
      found: found,
      length: i
    };
  }

  function getHeaderBlock(stream, suggestedLength) {
    var EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];
    var streamStartPos = stream.pos;
    var headerBytes, headerBytesLength, block;

    try {
      headerBytes = stream.getBytes(suggestedLength);
      headerBytesLength = headerBytes.length;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
    }

    if (headerBytesLength === suggestedLength) {
      block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);

      if (block.found && block.length === suggestedLength) {
        return {
          stream: new _stream.Stream(headerBytes),
          length: suggestedLength
        };
      }
    }

    (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
    stream.pos = streamStartPos;
    var SCAN_BLOCK_LENGTH = 2048;
    var actualLength;

    while (true) {
      var scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);

      if (block.length === 0) {
        break;
      }

      stream.pos += block.length;

      if (block.found) {
        actualLength = stream.pos - streamStartPos;
        break;
      }
    }

    stream.pos = streamStartPos;

    if (actualLength) {
      return {
        stream: new _stream.Stream(stream.getBytes(actualLength)),
        length: actualLength
      };
    }

    (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
    return {
      stream: new _stream.Stream(stream.getBytes(suggestedLength)),
      length: suggestedLength
    };
  }

  function getEexecBlock(stream, suggestedLength) {
    var eexecBytes = stream.getBytes();
    return {
      stream: new _stream.Stream(eexecBytes),
      length: eexecBytes.length
    };
  }

  function Type1Font(name, file, properties) {
    var PFB_HEADER_SIZE = 6;
    var headerBlockLength = properties.length1;
    var eexecBlockLength = properties.length2;
    var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    var pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;

    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }

    var headerBlock = getHeaderBlock(file, headerBlockLength);
    var headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);

    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }

    var eexecBlock = getEexecBlock(file, eexecBlockLength);
    var eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
    var data = eexecBlockParser.extractFontProgram(properties);

    for (var key in data.properties) {
      properties[key] = data.properties[key];
    }

    var charstrings = data.charstrings;
    var type2Charstrings = this.getType2Charstrings(charstrings);
    var subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }

  Type1Font.prototype = {
    get numGlyphs() {
      return this.charstrings.length + 1;
    },

    getCharset: function Type1Font_getCharset() {
      var charset = [".notdef"];
      var charstrings = this.charstrings;

      for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
        charset.push(charstrings[glyphId].glyphName);
      }

      return charset;
    },
    getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
      var charstrings = this.charstrings;

      if (properties.composite) {
        var charCodeToGlyphId = Object.create(null);

        for (var _glyphId = 0, charstringsLen = charstrings.length; _glyphId < charstringsLen; _glyphId++) {
          var _charCode6 = properties.cMap.charCodeOf(_glyphId);

          charCodeToGlyphId[_charCode6] = _glyphId + 1;
        }

        return charCodeToGlyphId;
      }

      var glyphNames = [".notdef"],
          glyphId;

      for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
        glyphNames.push(charstrings[glyphId].glyphName);
      }

      var encoding = properties.builtInEncoding;

      if (encoding) {
        var builtInEncoding = Object.create(null);

        for (var charCode in encoding) {
          glyphId = glyphNames.indexOf(encoding[charCode]);

          if (glyphId >= 0) {
            builtInEncoding[charCode] = glyphId;
          }
        }
      }

      return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
    },
    hasGlyphId: function Type1Font_hasGlyphID(id) {
      if (id < 0 || id >= this.numGlyphs) {
        return false;
      }

      if (id === 0) {
        return true;
      }

      var glyph = this.charstrings[id - 1];
      return glyph.charstring.length > 0;
    },
    getSeacs: function Type1Font_getSeacs(charstrings) {
      var i, ii;
      var seacMap = [];

      for (i = 0, ii = charstrings.length; i < ii; i++) {
        var charstring = charstrings[i];

        if (charstring.seac) {
          seacMap[i + 1] = charstring.seac;
        }
      }

      return seacMap;
    },
    getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
      var type2Charstrings = [];

      for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
        type2Charstrings.push(type1Charstrings[i].charstring);
      }

      return type2Charstrings;
    },
    getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
      var bias = 0;
      var count = type1Subrs.length;

      if (count < 1133) {
        bias = 107;
      } else if (count < 33769) {
        bias = 1131;
      } else {
        bias = 32768;
      }

      var type2Subrs = [];
      var i;

      for (i = 0; i < bias; i++) {
        type2Subrs.push([0x0b]);
      }

      for (i = 0; i < count; i++) {
        type2Subrs.push(type1Subrs[i]);
      }

      return type2Subrs;
    },
    wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
      var cff = new _cff_parser.CFF();
      cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
      cff.names = [name];
      var topDict = new _cff_parser.CFFTopDict();
      topDict.setByName("version", 391);
      topDict.setByName("Notice", 392);
      topDict.setByName("FullName", 393);
      topDict.setByName("FamilyName", 394);
      topDict.setByName("Weight", 395);
      topDict.setByName("Encoding", null);
      topDict.setByName("FontMatrix", properties.fontMatrix);
      topDict.setByName("FontBBox", properties.bbox);
      topDict.setByName("charset", null);
      topDict.setByName("CharStrings", null);
      topDict.setByName("Private", null);
      cff.topDict = topDict;
      var strings = new _cff_parser.CFFStrings();
      strings.add("Version 0.11");
      strings.add("See original notice");
      strings.add(name);
      strings.add(name);
      strings.add("Medium");
      cff.strings = strings;
      cff.globalSubrIndex = new _cff_parser.CFFIndex();
      var count = glyphs.length;
      var charsetArray = [".notdef"];
      var i, ii;

      for (i = 0; i < count; i++) {
        var glyphName = charstrings[i].glyphName;

        var index = _cff_parser.CFFStandardStrings.indexOf(glyphName);

        if (index === -1) {
          strings.add(glyphName);
        }

        charsetArray.push(glyphName);
      }

      cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
      var charStringsIndex = new _cff_parser.CFFIndex();
      charStringsIndex.add([0x8b, 0x0e]);

      for (i = 0; i < count; i++) {
        charStringsIndex.add(glyphs[i]);
      }

      cff.charStrings = charStringsIndex;
      var privateDict = new _cff_parser.CFFPrivateDict();
      privateDict.setByName("Subrs", null);
      var fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];

      for (i = 0, ii = fields.length; i < ii; i++) {
        var field = fields[i];

        if (!(field in properties.privateData)) {
          continue;
        }

        var value = properties.privateData[field];

        if (Array.isArray(value)) {
          for (var j = value.length - 1; j > 0; j--) {
            value[j] -= value[j - 1];
          }
        }

        privateDict.setByName(field, value);
      }

      cff.topDict.privateDict = privateDict;
      var subrIndex = new _cff_parser.CFFIndex();

      for (i = 0, ii = subrs.length; i < ii; i++) {
        subrIndex.add(subrs[i]);
      }

      privateDict.subrsIndex = subrIndex;
      var compiler = new _cff_parser.CFFCompiler(cff);
      return compiler.compile();
    }
  };
  return Type1Font;
}();

var CFFFont = function CFFFontClosure() {
  function CFFFont(file, properties) {
    this.properties = properties;
    var parser = new _cff_parser.CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    this.cff.duplicateFirstGlyph();
    var compiler = new _cff_parser.CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;

    try {
      this.data = compiler.compile();
    } catch (e) {
      (0, _util.warn)("Failed to compile font " + properties.loadedName);
      this.data = file;
    }
  }

  CFFFont.prototype = {
    get numGlyphs() {
      return this.cff.charStrings.count;
    },

    getCharset: function CFFFont_getCharset() {
      return this.cff.charset.charset;
    },
    getGlyphMapping: function CFFFont_getGlyphMapping() {
      var cff = this.cff;
      var properties = this.properties;
      var charsets = cff.charset.charset;
      var charCodeToGlyphId;
      var glyphId;

      if (properties.composite) {
        charCodeToGlyphId = Object.create(null);
        var charCode;

        if (cff.isCIDFont) {
          for (glyphId = 0; glyphId < charsets.length; glyphId++) {
            var cid = charsets[glyphId];
            charCode = properties.cMap.charCodeOf(cid);
            charCodeToGlyphId[charCode] = glyphId;
          }
        } else {
          for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
            charCode = properties.cMap.charCodeOf(glyphId);
            charCodeToGlyphId[charCode] = glyphId;
          }
        }

        return charCodeToGlyphId;
      }

      var encoding = cff.encoding ? cff.encoding.encoding : null;
      charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
      return charCodeToGlyphId;
    },
    hasGlyphId: function CFFFont_hasGlyphID(id) {
      return this.cff.hasGlyphId(id);
    }
  };
  return CFFFont;
}();

/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFTopDict = exports.CFFStrings = exports.CFFStandardStrings = exports.CFFPrivateDict = exports.CFFParser = exports.CFFIndex = exports.CFFHeader = exports.CFFFDSelect = exports.CFFCompiler = exports.CFFCharset = exports.CFF = void 0;

var _util = __w_pdfjs_require__(4);

var _charsets = __w_pdfjs_require__(161);

var _encodings = __w_pdfjs_require__(162);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MAX_SUBR_NESTING = 10;
var CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
exports.CFFStandardStrings = CFFStandardStrings;
var NUM_STANDARD_CFF_STRINGS = 391;

var CFFParser = function CFFParserClosure() {
  var CharstringValidationData = [null, {
    id: "hstem",
    min: 2,
    stackClearing: true,
    stem: true
  }, null, {
    id: "vstem",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "vmoveto",
    min: 1,
    stackClearing: true
  }, {
    id: "rlineto",
    min: 2,
    resetStack: true
  }, {
    id: "hlineto",
    min: 1,
    resetStack: true
  }, {
    id: "vlineto",
    min: 1,
    resetStack: true
  }, {
    id: "rrcurveto",
    min: 6,
    resetStack: true
  }, null, {
    id: "callsubr",
    min: 1,
    undefStack: true
  }, {
    id: "return",
    min: 0,
    undefStack: true
  }, null, null, {
    id: "endchar",
    min: 0,
    stackClearing: true
  }, null, null, null, {
    id: "hstemhm",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "hintmask",
    min: 0,
    stackClearing: true
  }, {
    id: "cntrmask",
    min: 0,
    stackClearing: true
  }, {
    id: "rmoveto",
    min: 2,
    stackClearing: true
  }, {
    id: "hmoveto",
    min: 1,
    stackClearing: true
  }, {
    id: "vstemhm",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "rcurveline",
    min: 8,
    resetStack: true
  }, {
    id: "rlinecurve",
    min: 8,
    resetStack: true
  }, {
    id: "vvcurveto",
    min: 4,
    resetStack: true
  }, {
    id: "hhcurveto",
    min: 4,
    resetStack: true
  }, null, {
    id: "callgsubr",
    min: 1,
    undefStack: true
  }, {
    id: "vhcurveto",
    min: 4,
    resetStack: true
  }, {
    id: "hvcurveto",
    min: 4,
    resetStack: true
  }];
  var CharstringValidationData12 = [null, null, null, {
    id: "and",
    min: 2,
    stackDelta: -1
  }, {
    id: "or",
    min: 2,
    stackDelta: -1
  }, {
    id: "not",
    min: 1,
    stackDelta: 0
  }, null, null, null, {
    id: "abs",
    min: 1,
    stackDelta: 0
  }, {
    id: "add",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] + stack[index - 1];
    }
  }, {
    id: "sub",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] - stack[index - 1];
    }
  }, {
    id: "div",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] / stack[index - 1];
    }
  }, null, {
    id: "neg",
    min: 1,
    stackDelta: 0,
    stackFn: function stack_div(stack, index) {
      stack[index - 1] = -stack[index - 1];
    }
  }, {
    id: "eq",
    min: 2,
    stackDelta: -1
  }, null, null, {
    id: "drop",
    min: 1,
    stackDelta: -1
  }, null, {
    id: "put",
    min: 2,
    stackDelta: -2
  }, {
    id: "get",
    min: 1,
    stackDelta: 0
  }, {
    id: "ifelse",
    min: 4,
    stackDelta: -3
  }, {
    id: "random",
    min: 0,
    stackDelta: 1
  }, {
    id: "mul",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] * stack[index - 1];
    }
  }, null, {
    id: "sqrt",
    min: 1,
    stackDelta: 0
  }, {
    id: "dup",
    min: 1,
    stackDelta: 1
  }, {
    id: "exch",
    min: 2,
    stackDelta: 0
  }, {
    id: "index",
    min: 2,
    stackDelta: 0
  }, {
    id: "roll",
    min: 3,
    stackDelta: -2
  }, null, null, null, {
    id: "hflex",
    min: 7,
    resetStack: true
  }, {
    id: "flex",
    min: 13,
    resetStack: true
  }, {
    id: "hflex1",
    min: 9,
    resetStack: true
  }, {
    id: "flex1",
    min: 11,
    resetStack: true
  }];

  var CFFParser = /*#__PURE__*/function () {
    function CFFParser(file, properties, seacAnalysisEnabled) {
      _classCallCheck(this, CFFParser);

      this.bytes = file.getBytes();
      this.properties = properties;
      this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    }

    _createClass(CFFParser, [{
      key: "parse",
      value: function parse() {
        var properties = this.properties;
        var cff = new CFF();
        this.cff = cff;
        var header = this.parseHeader();
        var nameIndex = this.parseIndex(header.endPos);
        var topDictIndex = this.parseIndex(nameIndex.endPos);
        var stringIndex = this.parseIndex(topDictIndex.endPos);
        var globalSubrIndex = this.parseIndex(stringIndex.endPos);
        var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
        var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
        cff.header = header.obj;
        cff.names = this.parseNameIndex(nameIndex.obj);
        cff.strings = this.parseStringIndex(stringIndex.obj);
        cff.topDict = topDict;
        cff.globalSubrIndex = globalSubrIndex.obj;
        this.parsePrivateDict(cff.topDict);
        cff.isCIDFont = topDict.hasName("ROS");
        var charStringOffset = topDict.getByName("CharStrings");
        var charStringIndex = this.parseIndex(charStringOffset).obj;
        var fontMatrix = topDict.getByName("FontMatrix");

        if (fontMatrix) {
          properties.fontMatrix = fontMatrix;
        }

        var fontBBox = topDict.getByName("FontBBox");

        if (fontBBox) {
          properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
          properties.descent = Math.min(fontBBox[1], fontBBox[3]);
          properties.ascentScaled = true;
        }

        var charset, encoding;

        if (cff.isCIDFont) {
          var fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;

          for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
            var dictRaw = fdArrayIndex.get(i);
            var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
            this.parsePrivateDict(fontDict);
            cff.fdArray.push(fontDict);
          }

          encoding = null;
          charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
          cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
        } else {
          charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
          encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
        }

        cff.charset = charset;
        cff.encoding = encoding;
        var charStringsAndSeacs = this.parseCharStrings({
          charStrings: charStringIndex,
          localSubrIndex: topDict.privateDict.subrsIndex,
          globalSubrIndex: globalSubrIndex.obj,
          fdSelect: cff.fdSelect,
          fdArray: cff.fdArray,
          privateDict: topDict.privateDict
        });
        cff.charStrings = charStringsAndSeacs.charStrings;
        cff.seacs = charStringsAndSeacs.seacs;
        cff.widths = charStringsAndSeacs.widths;
        return cff;
      }
    }, {
      key: "parseHeader",
      value: function parseHeader() {
        var bytes = this.bytes;
        var bytesLength = bytes.length;
        var offset = 0;

        while (offset < bytesLength && bytes[offset] !== 1) {
          ++offset;
        }

        if (offset >= bytesLength) {
          throw new _util.FormatError("Invalid CFF header");
        }

        if (offset !== 0) {
          (0, _util.info)("cff data is shifted");
          bytes = bytes.subarray(offset);
          this.bytes = bytes;
        }

        var major = bytes[0];
        var minor = bytes[1];
        var hdrSize = bytes[2];
        var offSize = bytes[3];
        var header = new CFFHeader(major, minor, hdrSize, offSize);
        return {
          obj: header,
          endPos: hdrSize
        };
      }
    }, {
      key: "parseDict",
      value: function parseDict(dict) {
        var pos = 0;

        function parseOperand() {
          var value = dict[pos++];

          if (value === 30) {
            return parseFloatOperand();
          } else if (value === 28) {
            value = dict[pos++];
            value = (value << 24 | dict[pos++] << 16) >> 16;
            return value;
          } else if (value === 29) {
            value = dict[pos++];
            value = value << 8 | dict[pos++];
            value = value << 8 | dict[pos++];
            value = value << 8 | dict[pos++];
            return value;
          } else if (value >= 32 && value <= 246) {
            return value - 139;
          } else if (value >= 247 && value <= 250) {
            return (value - 247) * 256 + dict[pos++] + 108;
          } else if (value >= 251 && value <= 254) {
            return -((value - 251) * 256) - dict[pos++] - 108;
          }

          (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
          return NaN;
        }

        function parseFloatOperand() {
          var str = "";
          var eof = 15;
          var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
          var length = dict.length;

          while (pos < length) {
            var b = dict[pos++];
            var b1 = b >> 4;
            var b2 = b & 15;

            if (b1 === eof) {
              break;
            }

            str += lookup[b1];

            if (b2 === eof) {
              break;
            }

            str += lookup[b2];
          }

          return parseFloat(str);
        }

        var operands = [];
        var entries = [];
        pos = 0;
        var end = dict.length;

        while (pos < end) {
          var b = dict[pos];

          if (b <= 21) {
            if (b === 12) {
              b = b << 8 | dict[++pos];
            }

            entries.push([b, operands]);
            operands = [];
            ++pos;
          } else {
            operands.push(parseOperand());
          }
        }

        return entries;
      }
    }, {
      key: "parseIndex",
      value: function parseIndex(pos) {
        var cffIndex = new CFFIndex();
        var bytes = this.bytes;
        var count = bytes[pos++] << 8 | bytes[pos++];
        var offsets = [];
        var end = pos;
        var i, ii;

        if (count !== 0) {
          var offsetSize = bytes[pos++];
          var startPos = pos + (count + 1) * offsetSize - 1;

          for (i = 0, ii = count + 1; i < ii; ++i) {
            var offset = 0;

            for (var j = 0; j < offsetSize; ++j) {
              offset <<= 8;
              offset += bytes[pos++];
            }

            offsets.push(startPos + offset);
          }

          end = offsets[count];
        }

        for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
          var offsetStart = offsets[i];
          var offsetEnd = offsets[i + 1];
          cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
        }

        return {
          obj: cffIndex,
          endPos: end
        };
      }
    }, {
      key: "parseNameIndex",
      value: function parseNameIndex(index) {
        var names = [];

        for (var i = 0, ii = index.count; i < ii; ++i) {
          var name = index.get(i);
          names.push((0, _util.bytesToString)(name));
        }

        return names;
      }
    }, {
      key: "parseStringIndex",
      value: function parseStringIndex(index) {
        var strings = new CFFStrings();

        for (var i = 0, ii = index.count; i < ii; ++i) {
          var data = index.get(i);
          strings.add((0, _util.bytesToString)(data));
        }

        return strings;
      }
    }, {
      key: "createDict",
      value: function createDict(Type, dict, strings) {
        var cffDict = new Type(strings);

        for (var i = 0, ii = dict.length; i < ii; ++i) {
          var pair = dict[i];
          var key = pair[0];
          var value = pair[1];
          cffDict.setByKey(key, value);
        }

        return cffDict;
      }
    }, {
      key: "parseCharString",
      value: function parseCharString(state, data, localSubrIndex, globalSubrIndex) {
        if (!data || state.callDepth > MAX_SUBR_NESTING) {
          return false;
        }

        var stackSize = state.stackSize;
        var stack = state.stack;
        var length = data.length;

        for (var j = 0; j < length;) {
          var value = data[j++];
          var validationCommand = null;

          if (value === 12) {
            var q = data[j++];

            if (q === 0) {
              data[j - 2] = 139;
              data[j - 1] = 22;
              stackSize = 0;
            } else {
              validationCommand = CharstringValidationData12[q];
            }
          } else if (value === 28) {
            stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
            j += 2;
            stackSize++;
          } else if (value === 14) {
            if (stackSize >= 4) {
              stackSize -= 4;

              if (this.seacAnalysisEnabled) {
                state.seac = stack.slice(stackSize, stackSize + 4);
                return false;
              }
            }

            validationCommand = CharstringValidationData[value];
          } else if (value >= 32 && value <= 246) {
            stack[stackSize] = value - 139;
            stackSize++;
          } else if (value >= 247 && value <= 254) {
            stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
            j++;
            stackSize++;
          } else if (value === 255) {
            stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
            j += 4;
            stackSize++;
          } else if (value === 19 || value === 20) {
            state.hints += stackSize >> 1;
            j += state.hints + 7 >> 3;
            stackSize %= 2;
            validationCommand = CharstringValidationData[value];
          } else if (value === 10 || value === 29) {
            var subrsIndex;

            if (value === 10) {
              subrsIndex = localSubrIndex;
            } else {
              subrsIndex = globalSubrIndex;
            }

            if (!subrsIndex) {
              validationCommand = CharstringValidationData[value];
              (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
              return false;
            }

            var bias = 32768;

            if (subrsIndex.count < 1240) {
              bias = 107;
            } else if (subrsIndex.count < 33900) {
              bias = 1131;
            }

            var subrNumber = stack[--stackSize] + bias;

            if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
              validationCommand = CharstringValidationData[value];
              (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
              return false;
            }

            state.stackSize = stackSize;
            state.callDepth++;
            var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);

            if (!valid) {
              return false;
            }

            state.callDepth--;
            stackSize = state.stackSize;
            continue;
          } else if (value === 11) {
            state.stackSize = stackSize;
            return true;
          } else {
            validationCommand = CharstringValidationData[value];
          }

          if (validationCommand) {
            if (validationCommand.stem) {
              state.hints += stackSize >> 1;

              if (value === 3 || value === 23) {
                state.hasVStems = true;
              } else if (state.hasVStems && (value === 1 || value === 18)) {
                (0, _util.warn)("CFF stem hints are in wrong order");
                data[j - 1] = value === 1 ? 3 : 23;
              }
            }

            if ("min" in validationCommand) {
              if (!state.undefStack && stackSize < validationCommand.min) {
                (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                return false;
              }
            }

            if (state.firstStackClearing && validationCommand.stackClearing) {
              state.firstStackClearing = false;
              stackSize -= validationCommand.min;

              if (stackSize >= 2 && validationCommand.stem) {
                stackSize %= 2;
              } else if (stackSize > 1) {
                (0, _util.warn)("Found too many parameters for stack-clearing command");
              }

              if (stackSize > 0 && stack[stackSize - 1] >= 0) {
                state.width = stack[stackSize - 1];
              }
            }

            if ("stackDelta" in validationCommand) {
              if ("stackFn" in validationCommand) {
                validationCommand.stackFn(stack, stackSize);
              }

              stackSize += validationCommand.stackDelta;
            } else if (validationCommand.stackClearing) {
              stackSize = 0;
            } else if (validationCommand.resetStack) {
              stackSize = 0;
              state.undefStack = false;
            } else if (validationCommand.undefStack) {
              stackSize = 0;
              state.undefStack = true;
              state.firstStackClearing = false;
            }
          }
        }

        state.stackSize = stackSize;
        return true;
      }
    }, {
      key: "parseCharStrings",
      value: function parseCharStrings(_ref) {
        var charStrings = _ref.charStrings,
            localSubrIndex = _ref.localSubrIndex,
            globalSubrIndex = _ref.globalSubrIndex,
            fdSelect = _ref.fdSelect,
            fdArray = _ref.fdArray,
            privateDict = _ref.privateDict;
        var seacs = [];
        var widths = [];
        var count = charStrings.count;

        for (var i = 0; i < count; i++) {
          var charstring = charStrings.get(i);
          var state = {
            callDepth: 0,
            stackSize: 0,
            stack: [],
            undefStack: true,
            hints: 0,
            firstStackClearing: true,
            seac: null,
            width: null,
            hasVStems: false
          };
          var valid = true;
          var localSubrToUse = null;
          var privateDictToUse = privateDict;

          if (fdSelect && fdArray.length) {
            var fdIndex = fdSelect.getFDIndex(i);

            if (fdIndex === -1) {
              (0, _util.warn)("Glyph index is not in fd select.");
              valid = false;
            }

            if (fdIndex >= fdArray.length) {
              (0, _util.warn)("Invalid fd index for glyph index.");
              valid = false;
            }

            if (valid) {
              privateDictToUse = fdArray[fdIndex].privateDict;
              localSubrToUse = privateDictToUse.subrsIndex;
            }
          } else if (localSubrIndex) {
            localSubrToUse = localSubrIndex;
          }

          if (valid) {
            valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
          }

          if (state.width !== null) {
            var nominalWidth = privateDictToUse.getByName("nominalWidthX");
            widths[i] = nominalWidth + state.width;
          } else {
            var defaultWidth = privateDictToUse.getByName("defaultWidthX");
            widths[i] = defaultWidth;
          }

          if (state.seac !== null) {
            seacs[i] = state.seac;
          }

          if (!valid) {
            charStrings.set(i, new Uint8Array([14]));
          }
        }

        return {
          charStrings: charStrings,
          seacs: seacs,
          widths: widths
        };
      }
    }, {
      key: "emptyPrivateDictionary",
      value: function emptyPrivateDictionary(parentDict) {
        var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
        parentDict.setByKey(18, [0, 0]);
        parentDict.privateDict = privateDict;
      }
    }, {
      key: "parsePrivateDict",
      value: function parsePrivateDict(parentDict) {
        if (!parentDict.hasName("Private")) {
          this.emptyPrivateDictionary(parentDict);
          return;
        }

        var privateOffset = parentDict.getByName("Private");

        if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
          parentDict.removeByName("Private");
          return;
        }

        var size = privateOffset[0];
        var offset = privateOffset[1];

        if (size === 0 || offset >= this.bytes.length) {
          this.emptyPrivateDictionary(parentDict);
          return;
        }

        var privateDictEnd = offset + size;
        var dictData = this.bytes.subarray(offset, privateDictEnd);
        var dict = this.parseDict(dictData);
        var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
        parentDict.privateDict = privateDict;

        if (!privateDict.getByName("Subrs")) {
          return;
        }

        var subrsOffset = privateDict.getByName("Subrs");
        var relativeOffset = offset + subrsOffset;

        if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
          this.emptyPrivateDictionary(parentDict);
          return;
        }

        var subrsIndex = this.parseIndex(relativeOffset);
        privateDict.subrsIndex = subrsIndex.obj;
      }
    }, {
      key: "parseCharsets",
      value: function parseCharsets(pos, length, strings, cid) {
        if (pos === 0) {
          return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
        } else if (pos === 1) {
          return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
        } else if (pos === 2) {
          return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
        }

        var bytes = this.bytes;
        var start = pos;
        var format = bytes[pos++];
        var charset = [cid ? 0 : ".notdef"];
        var id, count, i;
        length -= 1;

        switch (format) {
          case 0:
            for (i = 0; i < length; i++) {
              id = bytes[pos++] << 8 | bytes[pos++];
              charset.push(cid ? id : strings.get(id));
            }

            break;

          case 1:
            while (charset.length <= length) {
              id = bytes[pos++] << 8 | bytes[pos++];
              count = bytes[pos++];

              for (i = 0; i <= count; i++) {
                charset.push(cid ? id++ : strings.get(id++));
              }
            }

            break;

          case 2:
            while (charset.length <= length) {
              id = bytes[pos++] << 8 | bytes[pos++];
              count = bytes[pos++] << 8 | bytes[pos++];

              for (i = 0; i <= count; i++) {
                charset.push(cid ? id++ : strings.get(id++));
              }
            }

            break;

          default:
            throw new _util.FormatError("Unknown charset format");
        }

        var end = pos;
        var raw = bytes.subarray(start, end);
        return new CFFCharset(false, format, charset, raw);
      }
    }, {
      key: "parseEncoding",
      value: function parseEncoding(pos, properties, strings, charset) {
        var encoding = Object.create(null);
        var bytes = this.bytes;
        var predefined = false;
        var format, i, ii;
        var raw = null;

        function readSupplement() {
          var supplementsCount = bytes[pos++];

          for (i = 0; i < supplementsCount; i++) {
            var code = bytes[pos++];
            var sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
            encoding[code] = charset.indexOf(strings.get(sid));
          }
        }

        if (pos === 0 || pos === 1) {
          predefined = true;
          format = pos;
          var baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;

          for (i = 0, ii = charset.length; i < ii; i++) {
            var index = baseEncoding.indexOf(charset[i]);

            if (index !== -1) {
              encoding[index] = i;
            }
          }
        } else {
          var dataStart = pos;
          format = bytes[pos++];

          switch (format & 0x7f) {
            case 0:
              var glyphsCount = bytes[pos++];

              for (i = 1; i <= glyphsCount; i++) {
                encoding[bytes[pos++]] = i;
              }

              break;

            case 1:
              var rangesCount = bytes[pos++];
              var gid = 1;

              for (i = 0; i < rangesCount; i++) {
                var start = bytes[pos++];
                var left = bytes[pos++];

                for (var j = start; j <= start + left; j++) {
                  encoding[j] = gid++;
                }
              }

              break;

            default:
              throw new _util.FormatError("Unknown encoding format: ".concat(format, " in CFF"));
          }

          var dataEnd = pos;

          if (format & 0x80) {
            bytes[dataStart] &= 0x7f;
            readSupplement();
          }

          raw = bytes.subarray(dataStart, dataEnd);
        }

        format = format & 0x7f;
        return new CFFEncoding(predefined, format, encoding, raw);
      }
    }, {
      key: "parseFDSelect",
      value: function parseFDSelect(pos, length) {
        var bytes = this.bytes;
        var format = bytes[pos++];
        var fdSelect = [];
        var i;

        switch (format) {
          case 0:
            for (i = 0; i < length; ++i) {
              var id = bytes[pos++];
              fdSelect.push(id);
            }

            break;

          case 3:
            var rangesCount = bytes[pos++] << 8 | bytes[pos++];

            for (i = 0; i < rangesCount; ++i) {
              var first = bytes[pos++] << 8 | bytes[pos++];

              if (i === 0 && first !== 0) {
                (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0" + " -- trying to recover.");
                first = 0;
              }

              var fdIndex = bytes[pos++];
              var next = bytes[pos] << 8 | bytes[pos + 1];

              for (var j = first; j < next; ++j) {
                fdSelect.push(fdIndex);
              }
            }

            pos += 2;
            break;

          default:
            throw new _util.FormatError("parseFDSelect: Unknown format \"".concat(format, "\"."));
        }

        if (fdSelect.length !== length) {
          throw new _util.FormatError("parseFDSelect: Invalid font data.");
        }

        return new CFFFDSelect(format, fdSelect);
      }
    }]);

    return CFFParser;
  }();

  return CFFParser;
}();

exports.CFFParser = CFFParser;

var CFF = /*#__PURE__*/function () {
  function CFF() {
    _classCallCheck(this, CFF);

    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }

  _createClass(CFF, [{
    key: "duplicateFirstGlyph",
    value: function duplicateFirstGlyph() {
      if (this.charStrings.count >= 65535) {
        (0, _util.warn)("Not enough space in charstrings to duplicate first glyph.");
        return;
      }

      var glyphZero = this.charStrings.get(0);
      this.charStrings.add(glyphZero);

      if (this.isCIDFont) {
        this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
      }
    }
  }, {
    key: "hasGlyphId",
    value: function hasGlyphId(id) {
      if (id < 0 || id >= this.charStrings.count) {
        return false;
      }

      var glyph = this.charStrings.get(id);
      return glyph.length > 0;
    }
  }]);

  return CFF;
}();

exports.CFF = CFF;

var CFFHeader = function CFFHeader(major, minor, hdrSize, offSize) {
  _classCallCheck(this, CFFHeader);

  this.major = major;
  this.minor = minor;
  this.hdrSize = hdrSize;
  this.offSize = offSize;
};

exports.CFFHeader = CFFHeader;

var CFFStrings = /*#__PURE__*/function () {
  function CFFStrings() {
    _classCallCheck(this, CFFStrings);

    this.strings = [];
  }

  _createClass(CFFStrings, [{
    key: "get",
    value: function get(index) {
      if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
        return CFFStandardStrings[index];
      }

      if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
        return this.strings[index - NUM_STANDARD_CFF_STRINGS];
      }

      return CFFStandardStrings[0];
    }
  }, {
    key: "getSID",
    value: function getSID(str) {
      var index = CFFStandardStrings.indexOf(str);

      if (index !== -1) {
        return index;
      }

      index = this.strings.indexOf(str);

      if (index !== -1) {
        return index + NUM_STANDARD_CFF_STRINGS;
      }

      return -1;
    }
  }, {
    key: "add",
    value: function add(value) {
      this.strings.push(value);
    }
  }, {
    key: "count",
    get: function get() {
      return this.strings.length;
    }
  }]);

  return CFFStrings;
}();

exports.CFFStrings = CFFStrings;

var CFFIndex = /*#__PURE__*/function () {
  function CFFIndex() {
    _classCallCheck(this, CFFIndex);

    this.objects = [];
    this.length = 0;
  }

  _createClass(CFFIndex, [{
    key: "add",
    value: function add(data) {
      this.length += data.length;
      this.objects.push(data);
    }
  }, {
    key: "set",
    value: function set(index, data) {
      this.length += data.length - this.objects[index].length;
      this.objects[index] = data;
    }
  }, {
    key: "get",
    value: function get(index) {
      return this.objects[index];
    }
  }, {
    key: "count",
    get: function get() {
      return this.objects.length;
    }
  }]);

  return CFFIndex;
}();

exports.CFFIndex = CFFIndex;

var CFFDict = /*#__PURE__*/function () {
  function CFFDict(tables, strings) {
    _classCallCheck(this, CFFDict);

    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = Object.create(null);
  }

  _createClass(CFFDict, [{
    key: "setByKey",
    value: function setByKey(key, value) {
      if (!(key in this.keyToNameMap)) {
        return false;
      }

      var valueLength = value.length;

      if (valueLength === 0) {
        return true;
      }

      for (var i = 0; i < valueLength; i++) {
        if (isNaN(value[i])) {
          (0, _util.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
          return true;
        }
      }

      var type = this.types[key];

      if (type === "num" || type === "sid" || type === "offset") {
        value = value[0];
      }

      this.values[key] = value;
      return true;
    }
  }, {
    key: "setByName",
    value: function setByName(name, value) {
      if (!(name in this.nameToKeyMap)) {
        throw new _util.FormatError("Invalid dictionary name \"".concat(name, "\""));
      }

      this.values[this.nameToKeyMap[name]] = value;
    }
  }, {
    key: "hasName",
    value: function hasName(name) {
      return this.nameToKeyMap[name] in this.values;
    }
  }, {
    key: "getByName",
    value: function getByName(name) {
      if (!(name in this.nameToKeyMap)) {
        throw new _util.FormatError("Invalid dictionary name ".concat(name, "\""));
      }

      var key = this.nameToKeyMap[name];

      if (!(key in this.values)) {
        return this.defaults[key];
      }

      return this.values[key];
    }
  }, {
    key: "removeByName",
    value: function removeByName(name) {
      delete this.values[this.nameToKeyMap[name]];
    }
  }], [{
    key: "createTables",
    value: function createTables(layout) {
      var tables = {
        keyToNameMap: {},
        nameToKeyMap: {},
        defaults: {},
        types: {},
        opcodes: {},
        order: []
      };

      for (var i = 0, ii = layout.length; i < ii; ++i) {
        var entry = layout[i];
        var key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
        tables.keyToNameMap[key] = entry[1];
        tables.nameToKeyMap[entry[1]] = key;
        tables.types[key] = entry[2];
        tables.defaults[key] = entry[3];
        tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
        tables.order.push(key);
      }

      return tables;
    }
  }]);

  return CFFDict;
}();

var CFFTopDict = function CFFTopDictClosure() {
  var layout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [0.001, 0, 0, 0.001, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
  var tables = null;

  var CFFTopDict = /*#__PURE__*/function (_CFFDict) {
    _inherits(CFFTopDict, _CFFDict);

    var _super = _createSuper(CFFTopDict);

    function CFFTopDict(strings) {
      var _this;

      _classCallCheck(this, CFFTopDict);

      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }

      _this = _super.call(this, tables, strings);
      _this.privateDict = null;
      return _this;
    }

    return CFFTopDict;
  }(CFFDict);

  return CFFTopDict;
}();

exports.CFFTopDict = CFFTopDict;

var CFFPrivateDict = function CFFPrivateDictClosure() {
  var layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
  var tables = null;

  var CFFPrivateDict = /*#__PURE__*/function (_CFFDict2) {
    _inherits(CFFPrivateDict, _CFFDict2);

    var _super2 = _createSuper(CFFPrivateDict);

    function CFFPrivateDict(strings) {
      var _this2;

      _classCallCheck(this, CFFPrivateDict);

      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }

      _this2 = _super2.call(this, tables, strings);
      _this2.subrsIndex = null;
      return _this2;
    }

    return CFFPrivateDict;
  }(CFFDict);

  return CFFPrivateDict;
}();

exports.CFFPrivateDict = CFFPrivateDict;
var CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};

var CFFCharset = function CFFCharset(predefined, format, charset, raw) {
  _classCallCheck(this, CFFCharset);

  this.predefined = predefined;
  this.format = format;
  this.charset = charset;
  this.raw = raw;
};

exports.CFFCharset = CFFCharset;

var CFFEncoding = function CFFEncoding(predefined, format, encoding, raw) {
  _classCallCheck(this, CFFEncoding);

  this.predefined = predefined;
  this.format = format;
  this.encoding = encoding;
  this.raw = raw;
};

var CFFFDSelect = /*#__PURE__*/function () {
  function CFFFDSelect(format, fdSelect) {
    _classCallCheck(this, CFFFDSelect);

    this.format = format;
    this.fdSelect = fdSelect;
  }

  _createClass(CFFFDSelect, [{
    key: "getFDIndex",
    value: function getFDIndex(glyphIndex) {
      if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
        return -1;
      }

      return this.fdSelect[glyphIndex];
    }
  }]);

  return CFFFDSelect;
}();

exports.CFFFDSelect = CFFFDSelect;

var CFFOffsetTracker = /*#__PURE__*/function () {
  function CFFOffsetTracker() {
    _classCallCheck(this, CFFOffsetTracker);

    this.offsets = Object.create(null);
  }

  _createClass(CFFOffsetTracker, [{
    key: "isTracking",
    value: function isTracking(key) {
      return key in this.offsets;
    }
  }, {
    key: "track",
    value: function track(key, location) {
      if (key in this.offsets) {
        throw new _util.FormatError("Already tracking location of ".concat(key));
      }

      this.offsets[key] = location;
    }
  }, {
    key: "offset",
    value: function offset(value) {
      for (var key in this.offsets) {
        this.offsets[key] += value;
      }
    }
  }, {
    key: "setEntryLocation",
    value: function setEntryLocation(key, values, output) {
      if (!(key in this.offsets)) {
        throw new _util.FormatError("Not tracking location of ".concat(key));
      }

      var data = output.data;
      var dataOffset = this.offsets[key];
      var size = 5;

      for (var i = 0, ii = values.length; i < ii; ++i) {
        var offset0 = i * size + dataOffset;
        var offset1 = offset0 + 1;
        var offset2 = offset0 + 2;
        var offset3 = offset0 + 3;
        var offset4 = offset0 + 4;

        if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
          throw new _util.FormatError("writing to an offset that is not empty");
        }

        var value = values[i];
        data[offset0] = 0x1d;
        data[offset1] = value >> 24 & 0xff;
        data[offset2] = value >> 16 & 0xff;
        data[offset3] = value >> 8 & 0xff;
        data[offset4] = value & 0xff;
      }
    }
  }]);

  return CFFOffsetTracker;
}();

var CFFCompiler = /*#__PURE__*/function () {
  function CFFCompiler(cff) {
    _classCallCheck(this, CFFCompiler);

    this.cff = cff;
  }

  _createClass(CFFCompiler, [{
    key: "compile",
    value: function compile() {
      var cff = this.cff;
      var output = {
        data: [],
        length: 0,
        add: function CFFCompiler_add(data) {
          this.data = this.data.concat(data);
          this.length = this.data.length;
        }
      };
      var header = this.compileHeader(cff.header);
      output.add(header);
      var nameIndex = this.compileNameIndex(cff.names);
      output.add(nameIndex);

      if (cff.isCIDFont) {
        if (cff.topDict.hasName("FontMatrix")) {
          var base = cff.topDict.getByName("FontMatrix");
          cff.topDict.removeByName("FontMatrix");

          for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
            var subDict = cff.fdArray[i];
            var matrix = base.slice(0);

            if (subDict.hasName("FontMatrix")) {
              matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
            }

            subDict.setByName("FontMatrix", matrix);
          }
        }
      }

      var xuid = cff.topDict.getByName("XUID");

      if (xuid && xuid.length > 16) {
        cff.topDict.removeByName("XUID");
      }

      cff.topDict.setByName("charset", 0);
      var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
      output.add(compiled.output);
      var topDictTracker = compiled.trackers[0];
      var stringIndex = this.compileStringIndex(cff.strings.strings);
      output.add(stringIndex);
      var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
      output.add(globalSubrIndex);

      if (cff.encoding && cff.topDict.hasName("Encoding")) {
        if (cff.encoding.predefined) {
          topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
        } else {
          var encoding = this.compileEncoding(cff.encoding);
          topDictTracker.setEntryLocation("Encoding", [output.length], output);
          output.add(encoding);
        }
      }

      var charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
      topDictTracker.setEntryLocation("charset", [output.length], output);
      output.add(charset);
      var charStrings = this.compileCharStrings(cff.charStrings);
      topDictTracker.setEntryLocation("CharStrings", [output.length], output);
      output.add(charStrings);

      if (cff.isCIDFont) {
        topDictTracker.setEntryLocation("FDSelect", [output.length], output);
        var fdSelect = this.compileFDSelect(cff.fdSelect);
        output.add(fdSelect);
        compiled = this.compileTopDicts(cff.fdArray, output.length, true);
        topDictTracker.setEntryLocation("FDArray", [output.length], output);
        output.add(compiled.output);
        var fontDictTrackers = compiled.trackers;
        this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
      }

      this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
      output.add([0]);
      return output.data;
    }
  }, {
    key: "encodeNumber",
    value: function encodeNumber(value) {
      if (Number.isInteger(value)) {
        return this.encodeInteger(value);
      }

      return this.encodeFloat(value);
    }
  }, {
    key: "encodeFloat",
    value: function encodeFloat(num) {
      var value = num.toString();
      var m = CFFCompiler.EncodeFloatRegExp.exec(value);

      if (m) {
        var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(num * epsilon) / epsilon).toString();
      }

      var nibbles = "";
      var i, ii;

      for (i = 0, ii = value.length; i < ii; ++i) {
        var a = value[i];

        if (a === "e") {
          nibbles += value[++i] === "-" ? "c" : "b";
        } else if (a === ".") {
          nibbles += "a";
        } else if (a === "-") {
          nibbles += "e";
        } else {
          nibbles += a;
        }
      }

      nibbles += nibbles.length & 1 ? "f" : "ff";
      var out = [30];

      for (i = 0, ii = nibbles.length; i < ii; i += 2) {
        out.push(parseInt(nibbles.substring(i, i + 2), 16));
      }

      return out;
    }
  }, {
    key: "encodeInteger",
    value: function encodeInteger(value) {
      var code;

      if (value >= -107 && value <= 107) {
        code = [value + 139];
      } else if (value >= 108 && value <= 1131) {
        value = value - 108;
        code = [(value >> 8) + 247, value & 0xff];
      } else if (value >= -1131 && value <= -108) {
        value = -value - 108;
        code = [(value >> 8) + 251, value & 0xff];
      } else if (value >= -32768 && value <= 32767) {
        code = [0x1c, value >> 8 & 0xff, value & 0xff];
      } else {
        code = [0x1d, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff];
      }

      return code;
    }
  }, {
    key: "compileHeader",
    value: function compileHeader(header) {
      return [header.major, header.minor, header.hdrSize, header.offSize];
    }
  }, {
    key: "compileNameIndex",
    value: function compileNameIndex(names) {
      var nameIndex = new CFFIndex();

      for (var i = 0, ii = names.length; i < ii; ++i) {
        var name = names[i];
        var length = Math.min(name.length, 127);
        var sanitizedName = new Array(length);

        for (var j = 0; j < length; j++) {
          var _char = name[j];

          if (_char < "!" || _char > "~" || _char === "[" || _char === "]" || _char === "(" || _char === ")" || _char === "{" || _char === "}" || _char === "<" || _char === ">" || _char === "/" || _char === "%") {
            _char = "_";
          }

          sanitizedName[j] = _char;
        }

        sanitizedName = sanitizedName.join("");

        if (sanitizedName === "") {
          sanitizedName = "Bad_Font_Name";
        }

        nameIndex.add((0, _util.stringToBytes)(sanitizedName));
      }

      return this.compileIndex(nameIndex);
    }
  }, {
    key: "compileTopDicts",
    value: function compileTopDicts(dicts, length, removeCidKeys) {
      var fontDictTrackers = [];
      var fdArrayIndex = new CFFIndex();

      for (var i = 0, ii = dicts.length; i < ii; ++i) {
        var fontDict = dicts[i];

        if (removeCidKeys) {
          fontDict.removeByName("CIDFontVersion");
          fontDict.removeByName("CIDFontRevision");
          fontDict.removeByName("CIDFontType");
          fontDict.removeByName("CIDCount");
          fontDict.removeByName("UIDBase");
        }

        var fontDictTracker = new CFFOffsetTracker();
        var fontDictData = this.compileDict(fontDict, fontDictTracker);
        fontDictTrackers.push(fontDictTracker);
        fdArrayIndex.add(fontDictData);
        fontDictTracker.offset(length);
      }

      fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
      return {
        trackers: fontDictTrackers,
        output: fdArrayIndex
      };
    }
  }, {
    key: "compilePrivateDicts",
    value: function compilePrivateDicts(dicts, trackers, output) {
      for (var i = 0, ii = dicts.length; i < ii; ++i) {
        var fontDict = dicts[i];
        var privateDict = fontDict.privateDict;

        if (!privateDict || !fontDict.hasName("Private")) {
          throw new _util.FormatError("There must be a private dictionary.");
        }

        var privateDictTracker = new CFFOffsetTracker();
        var privateDictData = this.compileDict(privateDict, privateDictTracker);
        var outputLength = output.length;
        privateDictTracker.offset(outputLength);

        if (!privateDictData.length) {
          outputLength = 0;
        }

        trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
        output.add(privateDictData);

        if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
          var subrs = this.compileIndex(privateDict.subrsIndex);
          privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
          output.add(subrs);
        }
      }
    }
  }, {
    key: "compileDict",
    value: function compileDict(dict, offsetTracker) {
      var out = [];
      var order = dict.order;

      for (var i = 0; i < order.length; ++i) {
        var key = order[i];

        if (!(key in dict.values)) {
          continue;
        }

        var values = dict.values[key];
        var types = dict.types[key];

        if (!Array.isArray(types)) {
          types = [types];
        }

        if (!Array.isArray(values)) {
          values = [values];
        }

        if (values.length === 0) {
          continue;
        }

        for (var j = 0, jj = types.length; j < jj; ++j) {
          var type = types[j];
          var value = values[j];

          switch (type) {
            case "num":
            case "sid":
              out = out.concat(this.encodeNumber(value));
              break;

            case "offset":
              var name = dict.keyToNameMap[key];

              if (!offsetTracker.isTracking(name)) {
                offsetTracker.track(name, out.length);
              }

              out = out.concat([0x1d, 0, 0, 0, 0]);
              break;

            case "array":
            case "delta":
              out = out.concat(this.encodeNumber(value));

              for (var k = 1, kk = values.length; k < kk; ++k) {
                out = out.concat(this.encodeNumber(values[k]));
              }

              break;

            default:
              throw new _util.FormatError("Unknown data type of ".concat(type));
          }
        }

        out = out.concat(dict.opcodes[key]);
      }

      return out;
    }
  }, {
    key: "compileStringIndex",
    value: function compileStringIndex(strings) {
      var stringIndex = new CFFIndex();

      for (var i = 0, ii = strings.length; i < ii; ++i) {
        stringIndex.add((0, _util.stringToBytes)(strings[i]));
      }

      return this.compileIndex(stringIndex);
    }
  }, {
    key: "compileGlobalSubrIndex",
    value: function compileGlobalSubrIndex() {
      var globalSubrIndex = this.cff.globalSubrIndex;
      this.out.writeByteArray(this.compileIndex(globalSubrIndex));
    }
  }, {
    key: "compileCharStrings",
    value: function compileCharStrings(charStrings) {
      var charStringsIndex = new CFFIndex();

      for (var i = 0; i < charStrings.count; i++) {
        var glyph = charStrings.get(i);

        if (glyph.length === 0) {
          charStringsIndex.add(new Uint8Array([0x8b, 0x0e]));
          continue;
        }

        charStringsIndex.add(glyph);
      }

      return this.compileIndex(charStringsIndex);
    }
  }, {
    key: "compileCharset",
    value: function compileCharset(charset, numGlyphs, strings, isCIDFont) {
      var out;
      var numGlyphsLessNotDef = numGlyphs - 1;

      if (isCIDFont) {
        out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 0xff, numGlyphsLessNotDef & 0xff]);
      } else {
        var length = 1 + numGlyphsLessNotDef * 2;
        out = new Uint8Array(length);
        out[0] = 0;
        var charsetIndex = 0;
        var numCharsets = charset.charset.length;
        var warned = false;

        for (var i = 1; i < out.length; i += 2) {
          var sid = 0;

          if (charsetIndex < numCharsets) {
            var name = charset.charset[charsetIndex++];
            sid = strings.getSID(name);

            if (sid === -1) {
              sid = 0;

              if (!warned) {
                warned = true;
                (0, _util.warn)("Couldn't find ".concat(name, " in CFF strings"));
              }
            }
          }

          out[i] = sid >> 8 & 0xff;
          out[i + 1] = sid & 0xff;
        }
      }

      return this.compileTypedArray(out);
    }
  }, {
    key: "compileEncoding",
    value: function compileEncoding(encoding) {
      return this.compileTypedArray(encoding.raw);
    }
  }, {
    key: "compileFDSelect",
    value: function compileFDSelect(fdSelect) {
      var format = fdSelect.format;
      var out, i;

      switch (format) {
        case 0:
          out = new Uint8Array(1 + fdSelect.fdSelect.length);
          out[0] = format;

          for (i = 0; i < fdSelect.fdSelect.length; i++) {
            out[i + 1] = fdSelect.fdSelect[i];
          }

          break;

        case 3:
          var start = 0;
          var lastFD = fdSelect.fdSelect[0];
          var ranges = [format, 0, 0, start >> 8 & 0xff, start & 0xff, lastFD];

          for (i = 1; i < fdSelect.fdSelect.length; i++) {
            var currentFD = fdSelect.fdSelect[i];

            if (currentFD !== lastFD) {
              ranges.push(i >> 8 & 0xff, i & 0xff, currentFD);
              lastFD = currentFD;
            }
          }

          var numRanges = (ranges.length - 3) / 3;
          ranges[1] = numRanges >> 8 & 0xff;
          ranges[2] = numRanges & 0xff;
          ranges.push(i >> 8 & 0xff, i & 0xff);
          out = new Uint8Array(ranges);
          break;
      }

      return this.compileTypedArray(out);
    }
  }, {
    key: "compileTypedArray",
    value: function compileTypedArray(data) {
      var out = [];

      for (var i = 0, ii = data.length; i < ii; ++i) {
        out[i] = data[i];
      }

      return out;
    }
  }, {
    key: "compileIndex",
    value: function compileIndex(index) {
      var trackers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var objects = index.objects;
      var count = objects.length;

      if (count === 0) {
        return [0, 0, 0];
      }

      var data = [count >> 8 & 0xff, count & 0xff];
      var lastOffset = 1,
          i;

      for (i = 0; i < count; ++i) {
        lastOffset += objects[i].length;
      }

      var offsetSize;

      if (lastOffset < 0x100) {
        offsetSize = 1;
      } else if (lastOffset < 0x10000) {
        offsetSize = 2;
      } else if (lastOffset < 0x1000000) {
        offsetSize = 3;
      } else {
        offsetSize = 4;
      }

      data.push(offsetSize);
      var relativeOffset = 1;

      for (i = 0; i < count + 1; i++) {
        if (offsetSize === 1) {
          data.push(relativeOffset & 0xff);
        } else if (offsetSize === 2) {
          data.push(relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
        } else if (offsetSize === 3) {
          data.push(relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
        } else {
          data.push(relativeOffset >>> 24 & 0xff, relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
        }

        if (objects[i]) {
          relativeOffset += objects[i].length;
        }
      }

      for (i = 0; i < count; i++) {
        if (trackers[i]) {
          trackers[i].offset(data.length);
        }

        for (var j = 0, jj = objects[i].length; j < jj; j++) {
          data.push(objects[i][j]);
        }
      }

      return data;
    }
  }], [{
    key: "EncodeFloatRegExp",
    get: function get() {
      return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
    }
  }]);

  return CFFCompiler;
}();

exports.CFFCompiler = CFFCompiler;

/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOAdobeCharset = exports.ExpertSubsetCharset = exports.ExpertCharset = void 0;
var ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
exports.ISOAdobeCharset = ISOAdobeCharset;
var ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertCharset = ExpertCharset;
var ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
exports.ExpertSubsetCharset = ExpertSubsetCharset;

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getEncoding = getEncoding;
exports.ZapfDingbatsEncoding = exports.WinAnsiEncoding = exports.SymbolSetEncoding = exports.StandardEncoding = exports.MacRomanEncoding = exports.ExpertEncoding = void 0;
var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertEncoding = ExpertEncoding;
var MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
var MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
exports.MacRomanEncoding = MacRomanEncoding;
var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
exports.StandardEncoding = StandardEncoding;
var WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
exports.WinAnsiEncoding = WinAnsiEncoding;
var SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
exports.SymbolSetEncoding = SymbolSetEncoding;
var ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;

function getEncoding(encodingName) {
  switch (encodingName) {
    case "WinAnsiEncoding":
      return WinAnsiEncoding;

    case "StandardEncoding":
      return StandardEncoding;

    case "MacRomanEncoding":
      return MacRomanEncoding;

    case "SymbolSetEncoding":
      return SymbolSetEncoding;

    case "ZapfDingbatsEncoding":
      return ZapfDingbatsEncoding;

    case "ExpertEncoding":
      return ExpertEncoding;

    case "MacExpertEncoding":
      return MacExpertEncoding;

    default:
      return null;
  }
}

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) => {

"use strict";
__w_pdfjs_require__.r(__webpack_exports__);
/* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, {
/* harmony export */   "getDingbatsGlyphsUnicode": () => (/* binding */ getDingbatsGlyphsUnicode),
/* harmony export */   "getGlyphsUnicode": () => (/* binding */ getGlyphsUnicode)
/* harmony export */ });
/* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(138);

var getGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "A",
  0x0041,
  "AE",
  0x00c6,
  "AEacute",
  0x01fc,
  "AEmacron",
  0x01e2,
  "AEsmall",
  0xf7e6,
  "Aacute",
  0x00c1,
  "Aacutesmall",
  0xf7e1,
  "Abreve",
  0x0102,
  "Abreveacute",
  0x1eae,
  "Abrevecyrillic",
  0x04d0,
  "Abrevedotbelow",
  0x1eb6,
  "Abrevegrave",
  0x1eb0,
  "Abrevehookabove",
  0x1eb2,
  "Abrevetilde",
  0x1eb4,
  "Acaron",
  0x01cd,
  "Acircle",
  0x24b6,
  "Acircumflex",
  0x00c2,
  "Acircumflexacute",
  0x1ea4,
  "Acircumflexdotbelow",
  0x1eac,
  "Acircumflexgrave",
  0x1ea6,
  "Acircumflexhookabove",
  0x1ea8,
  "Acircumflexsmall",
  0xf7e2,
  "Acircumflextilde",
  0x1eaa,
  "Acute",
  0xf6c9,
  "Acutesmall",
  0xf7b4,
  "Acyrillic",
  0x0410,
  "Adblgrave",
  0x0200,
  "Adieresis",
  0x00c4,
  "Adieresiscyrillic",
  0x04d2,
  "Adieresismacron",
  0x01de,
  "Adieresissmall",
  0xf7e4,
  "Adotbelow",
  0x1ea0,
  "Adotmacron",
  0x01e0,
  "Agrave",
  0x00c0,
  "Agravesmall",
  0xf7e0,
  "Ahookabove",
  0x1ea2,
  "Aiecyrillic",
  0x04d4,
  "Ainvertedbreve",
  0x0202,
  "Alpha",
  0x0391,
  "Alphatonos",
  0x0386,
  "Amacron",
  0x0100,
  "Amonospace",
  0xff21,
  "Aogonek",
  0x0104,
  "Aring",
  0x00c5,
  "Aringacute",
  0x01fa,
  "Aringbelow",
  0x1e00,
  "Aringsmall",
  0xf7e5,
  "Asmall",
  0xf761,
  "Atilde",
  0x00c3,
  "Atildesmall",
  0xf7e3,
  "Aybarmenian",
  0x0531,
  "B",
  0x0042,
  "Bcircle",
  0x24b7,
  "Bdotaccent",
  0x1e02,
  "Bdotbelow",
  0x1e04,
  "Becyrillic",
  0x0411,
  "Benarmenian",
  0x0532,
  "Beta",
  0x0392,
  "Bhook",
  0x0181,
  "Blinebelow",
  0x1e06,
  "Bmonospace",
  0xff22,
  "Brevesmall",
  0xf6f4,
  "Bsmall",
  0xf762,
  "Btopbar",
  0x0182,
  "C",
  0x0043,
  "Caarmenian",
  0x053e,
  "Cacute",
  0x0106,
  "Caron",
  0xf6ca,
  "Caronsmall",
  0xf6f5,
  "Ccaron",
  0x010c,
  "Ccedilla",
  0x00c7,
  "Ccedillaacute",
  0x1e08,
  "Ccedillasmall",
  0xf7e7,
  "Ccircle",
  0x24b8,
  "Ccircumflex",
  0x0108,
  "Cdot",
  0x010a,
  "Cdotaccent",
  0x010a,
  "Cedillasmall",
  0xf7b8,
  "Chaarmenian",
  0x0549,
  "Cheabkhasiancyrillic",
  0x04bc,
  "Checyrillic",
  0x0427,
  "Chedescenderabkhasiancyrillic",
  0x04be,
  "Chedescendercyrillic",
  0x04b6,
  "Chedieresiscyrillic",
  0x04f4,
  "Cheharmenian",
  0x0543,
  "Chekhakassiancyrillic",
  0x04cb,
  "Cheverticalstrokecyrillic",
  0x04b8,
  "Chi",
  0x03a7,
  "Chook",
  0x0187,
  "Circumflexsmall",
  0xf6f6,
  "Cmonospace",
  0xff23,
  "Coarmenian",
  0x0551,
  "Csmall",
  0xf763,
  "D",
  0x0044,
  "DZ",
  0x01f1,
  "DZcaron",
  0x01c4,
  "Daarmenian",
  0x0534,
  "Dafrican",
  0x0189,
  "Dcaron",
  0x010e,
  "Dcedilla",
  0x1e10,
  "Dcircle",
  0x24b9,
  "Dcircumflexbelow",
  0x1e12,
  "Dcroat",
  0x0110,
  "Ddotaccent",
  0x1e0a,
  "Ddotbelow",
  0x1e0c,
  "Decyrillic",
  0x0414,
  "Deicoptic",
  0x03ee,
  "Delta",
  0x2206,
  "Deltagreek",
  0x0394,
  "Dhook",
  0x018a,
  "Dieresis",
  0xf6cb,
  "DieresisAcute",
  0xf6cc,
  "DieresisGrave",
  0xf6cd,
  "Dieresissmall",
  0xf7a8,
  "Digammagreek",
  0x03dc,
  "Djecyrillic",
  0x0402,
  "Dlinebelow",
  0x1e0e,
  "Dmonospace",
  0xff24,
  "Dotaccentsmall",
  0xf6f7,
  "Dslash",
  0x0110,
  "Dsmall",
  0xf764,
  "Dtopbar",
  0x018b,
  "Dz",
  0x01f2,
  "Dzcaron",
  0x01c5,
  "Dzeabkhasiancyrillic",
  0x04e0,
  "Dzecyrillic",
  0x0405,
  "Dzhecyrillic",
  0x040f,
  "E",
  0x0045,
  "Eacute",
  0x00c9,
  "Eacutesmall",
  0xf7e9,
  "Ebreve",
  0x0114,
  "Ecaron",
  0x011a,
  "Ecedillabreve",
  0x1e1c,
  "Echarmenian",
  0x0535,
  "Ecircle",
  0x24ba,
  "Ecircumflex",
  0x00ca,
  "Ecircumflexacute",
  0x1ebe,
  "Ecircumflexbelow",
  0x1e18,
  "Ecircumflexdotbelow",
  0x1ec6,
  "Ecircumflexgrave",
  0x1ec0,
  "Ecircumflexhookabove",
  0x1ec2,
  "Ecircumflexsmall",
  0xf7ea,
  "Ecircumflextilde",
  0x1ec4,
  "Ecyrillic",
  0x0404,
  "Edblgrave",
  0x0204,
  "Edieresis",
  0x00cb,
  "Edieresissmall",
  0xf7eb,
  "Edot",
  0x0116,
  "Edotaccent",
  0x0116,
  "Edotbelow",
  0x1eb8,
  "Efcyrillic",
  0x0424,
  "Egrave",
  0x00c8,
  "Egravesmall",
  0xf7e8,
  "Eharmenian",
  0x0537,
  "Ehookabove",
  0x1eba,
  "Eightroman",
  0x2167,
  "Einvertedbreve",
  0x0206,
  "Eiotifiedcyrillic",
  0x0464,
  "Elcyrillic",
  0x041b,
  "Elevenroman",
  0x216a,
  "Emacron",
  0x0112,
  "Emacronacute",
  0x1e16,
  "Emacrongrave",
  0x1e14,
  "Emcyrillic",
  0x041c,
  "Emonospace",
  0xff25,
  "Encyrillic",
  0x041d,
  "Endescendercyrillic",
  0x04a2,
  "Eng",
  0x014a,
  "Enghecyrillic",
  0x04a4,
  "Enhookcyrillic",
  0x04c7,
  "Eogonek",
  0x0118,
  "Eopen",
  0x0190,
  "Epsilon",
  0x0395,
  "Epsilontonos",
  0x0388,
  "Ercyrillic",
  0x0420,
  "Ereversed",
  0x018e,
  "Ereversedcyrillic",
  0x042d,
  "Escyrillic",
  0x0421,
  "Esdescendercyrillic",
  0x04aa,
  "Esh",
  0x01a9,
  "Esmall",
  0xf765,
  "Eta",
  0x0397,
  "Etarmenian",
  0x0538,
  "Etatonos",
  0x0389,
  "Eth",
  0x00d0,
  "Ethsmall",
  0xf7f0,
  "Etilde",
  0x1ebc,
  "Etildebelow",
  0x1e1a,
  "Euro",
  0x20ac,
  "Ezh",
  0x01b7,
  "Ezhcaron",
  0x01ee,
  "Ezhreversed",
  0x01b8,
  "F",
  0x0046,
  "Fcircle",
  0x24bb,
  "Fdotaccent",
  0x1e1e,
  "Feharmenian",
  0x0556,
  "Feicoptic",
  0x03e4,
  "Fhook",
  0x0191,
  "Fitacyrillic",
  0x0472,
  "Fiveroman",
  0x2164,
  "Fmonospace",
  0xff26,
  "Fourroman",
  0x2163,
  "Fsmall",
  0xf766,
  "G",
  0x0047,
  "GBsquare",
  0x3387,
  "Gacute",
  0x01f4,
  "Gamma",
  0x0393,
  "Gammaafrican",
  0x0194,
  "Gangiacoptic",
  0x03ea,
  "Gbreve",
  0x011e,
  "Gcaron",
  0x01e6,
  "Gcedilla",
  0x0122,
  "Gcircle",
  0x24bc,
  "Gcircumflex",
  0x011c,
  "Gcommaaccent",
  0x0122,
  "Gdot",
  0x0120,
  "Gdotaccent",
  0x0120,
  "Gecyrillic",
  0x0413,
  "Ghadarmenian",
  0x0542,
  "Ghemiddlehookcyrillic",
  0x0494,
  "Ghestrokecyrillic",
  0x0492,
  "Gheupturncyrillic",
  0x0490,
  "Ghook",
  0x0193,
  "Gimarmenian",
  0x0533,
  "Gjecyrillic",
  0x0403,
  "Gmacron",
  0x1e20,
  "Gmonospace",
  0xff27,
  "Grave",
  0xf6ce,
  "Gravesmall",
  0xf760,
  "Gsmall",
  0xf767,
  "Gsmallhook",
  0x029b,
  "Gstroke",
  0x01e4,
  "H",
  0x0048,
  "H18533",
  0x25cf,
  "H18543",
  0x25aa,
  "H18551",
  0x25ab,
  "H22073",
  0x25a1,
  "HPsquare",
  0x33cb,
  "Haabkhasiancyrillic",
  0x04a8,
  "Hadescendercyrillic",
  0x04b2,
  "Hardsigncyrillic",
  0x042a,
  "Hbar",
  0x0126,
  "Hbrevebelow",
  0x1e2a,
  "Hcedilla",
  0x1e28,
  "Hcircle",
  0x24bd,
  "Hcircumflex",
  0x0124,
  "Hdieresis",
  0x1e26,
  "Hdotaccent",
  0x1e22,
  "Hdotbelow",
  0x1e24,
  "Hmonospace",
  0xff28,
  "Hoarmenian",
  0x0540,
  "Horicoptic",
  0x03e8,
  "Hsmall",
  0xf768,
  "Hungarumlaut",
  0xf6cf,
  "Hungarumlautsmall",
  0xf6f8,
  "Hzsquare",
  0x3390,
  "I",
  0x0049,
  "IAcyrillic",
  0x042f,
  "IJ",
  0x0132,
  "IUcyrillic",
  0x042e,
  "Iacute",
  0x00cd,
  "Iacutesmall",
  0xf7ed,
  "Ibreve",
  0x012c,
  "Icaron",
  0x01cf,
  "Icircle",
  0x24be,
  "Icircumflex",
  0x00ce,
  "Icircumflexsmall",
  0xf7ee,
  "Icyrillic",
  0x0406,
  "Idblgrave",
  0x0208,
  "Idieresis",
  0x00cf,
  "Idieresisacute",
  0x1e2e,
  "Idieresiscyrillic",
  0x04e4,
  "Idieresissmall",
  0xf7ef,
  "Idot",
  0x0130,
  "Idotaccent",
  0x0130,
  "Idotbelow",
  0x1eca,
  "Iebrevecyrillic",
  0x04d6,
  "Iecyrillic",
  0x0415,
  "Ifraktur",
  0x2111,
  "Igrave",
  0x00cc,
  "Igravesmall",
  0xf7ec,
  "Ihookabove",
  0x1ec8,
  "Iicyrillic",
  0x0418,
  "Iinvertedbreve",
  0x020a,
  "Iishortcyrillic",
  0x0419,
  "Imacron",
  0x012a,
  "Imacroncyrillic",
  0x04e2,
  "Imonospace",
  0xff29,
  "Iniarmenian",
  0x053b,
  "Iocyrillic",
  0x0401,
  "Iogonek",
  0x012e,
  "Iota",
  0x0399,
  "Iotaafrican",
  0x0196,
  "Iotadieresis",
  0x03aa,
  "Iotatonos",
  0x038a,
  "Ismall",
  0xf769,
  "Istroke",
  0x0197,
  "Itilde",
  0x0128,
  "Itildebelow",
  0x1e2c,
  "Izhitsacyrillic",
  0x0474,
  "Izhitsadblgravecyrillic",
  0x0476,
  "J",
  0x004a,
  "Jaarmenian",
  0x0541,
  "Jcircle",
  0x24bf,
  "Jcircumflex",
  0x0134,
  "Jecyrillic",
  0x0408,
  "Jheharmenian",
  0x054b,
  "Jmonospace",
  0xff2a,
  "Jsmall",
  0xf76a,
  "K",
  0x004b,
  "KBsquare",
  0x3385,
  "KKsquare",
  0x33cd,
  "Kabashkircyrillic",
  0x04a0,
  "Kacute",
  0x1e30,
  "Kacyrillic",
  0x041a,
  "Kadescendercyrillic",
  0x049a,
  "Kahookcyrillic",
  0x04c3,
  "Kappa",
  0x039a,
  "Kastrokecyrillic",
  0x049e,
  "Kaverticalstrokecyrillic",
  0x049c,
  "Kcaron",
  0x01e8,
  "Kcedilla",
  0x0136,
  "Kcircle",
  0x24c0,
  "Kcommaaccent",
  0x0136,
  "Kdotbelow",
  0x1e32,
  "Keharmenian",
  0x0554,
  "Kenarmenian",
  0x053f,
  "Khacyrillic",
  0x0425,
  "Kheicoptic",
  0x03e6,
  "Khook",
  0x0198,
  "Kjecyrillic",
  0x040c,
  "Klinebelow",
  0x1e34,
  "Kmonospace",
  0xff2b,
  "Koppacyrillic",
  0x0480,
  "Koppagreek",
  0x03de,
  "Ksicyrillic",
  0x046e,
  "Ksmall",
  0xf76b,
  "L",
  0x004c,
  "LJ",
  0x01c7,
  "LL",
  0xf6bf,
  "Lacute",
  0x0139,
  "Lambda",
  0x039b,
  "Lcaron",
  0x013d,
  "Lcedilla",
  0x013b,
  "Lcircle",
  0x24c1,
  "Lcircumflexbelow",
  0x1e3c,
  "Lcommaaccent",
  0x013b,
  "Ldot",
  0x013f,
  "Ldotaccent",
  0x013f,
  "Ldotbelow",
  0x1e36,
  "Ldotbelowmacron",
  0x1e38,
  "Liwnarmenian",
  0x053c,
  "Lj",
  0x01c8,
  "Ljecyrillic",
  0x0409,
  "Llinebelow",
  0x1e3a,
  "Lmonospace",
  0xff2c,
  "Lslash",
  0x0141,
  "Lslashsmall",
  0xf6f9,
  "Lsmall",
  0xf76c,
  "M",
  0x004d,
  "MBsquare",
  0x3386,
  "Macron",
  0xf6d0,
  "Macronsmall",
  0xf7af,
  "Macute",
  0x1e3e,
  "Mcircle",
  0x24c2,
  "Mdotaccent",
  0x1e40,
  "Mdotbelow",
  0x1e42,
  "Menarmenian",
  0x0544,
  "Mmonospace",
  0xff2d,
  "Msmall",
  0xf76d,
  "Mturned",
  0x019c,
  "Mu",
  0x039c,
  "N",
  0x004e,
  "NJ",
  0x01ca,
  "Nacute",
  0x0143,
  "Ncaron",
  0x0147,
  "Ncedilla",
  0x0145,
  "Ncircle",
  0x24c3,
  "Ncircumflexbelow",
  0x1e4a,
  "Ncommaaccent",
  0x0145,
  "Ndotaccent",
  0x1e44,
  "Ndotbelow",
  0x1e46,
  "Nhookleft",
  0x019d,
  "Nineroman",
  0x2168,
  "Nj",
  0x01cb,
  "Njecyrillic",
  0x040a,
  "Nlinebelow",
  0x1e48,
  "Nmonospace",
  0xff2e,
  "Nowarmenian",
  0x0546,
  "Nsmall",
  0xf76e,
  "Ntilde",
  0x00d1,
  "Ntildesmall",
  0xf7f1,
  "Nu",
  0x039d,
  "O",
  0x004f,
  "OE",
  0x0152,
  "OEsmall",
  0xf6fa,
  "Oacute",
  0x00d3,
  "Oacutesmall",
  0xf7f3,
  "Obarredcyrillic",
  0x04e8,
  "Obarreddieresiscyrillic",
  0x04ea,
  "Obreve",
  0x014e,
  "Ocaron",
  0x01d1,
  "Ocenteredtilde",
  0x019f,
  "Ocircle",
  0x24c4,
  "Ocircumflex",
  0x00d4,
  "Ocircumflexacute",
  0x1ed0,
  "Ocircumflexdotbelow",
  0x1ed8,
  "Ocircumflexgrave",
  0x1ed2,
  "Ocircumflexhookabove",
  0x1ed4,
  "Ocircumflexsmall",
  0xf7f4,
  "Ocircumflextilde",
  0x1ed6,
  "Ocyrillic",
  0x041e,
  "Odblacute",
  0x0150,
  "Odblgrave",
  0x020c,
  "Odieresis",
  0x00d6,
  "Odieresiscyrillic",
  0x04e6,
  "Odieresissmall",
  0xf7f6,
  "Odotbelow",
  0x1ecc,
  "Ogoneksmall",
  0xf6fb,
  "Ograve",
  0x00d2,
  "Ogravesmall",
  0xf7f2,
  "Oharmenian",
  0x0555,
  "Ohm",
  0x2126,
  "Ohookabove",
  0x1ece,
  "Ohorn",
  0x01a0,
  "Ohornacute",
  0x1eda,
  "Ohorndotbelow",
  0x1ee2,
  "Ohorngrave",
  0x1edc,
  "Ohornhookabove",
  0x1ede,
  "Ohorntilde",
  0x1ee0,
  "Ohungarumlaut",
  0x0150,
  "Oi",
  0x01a2,
  "Oinvertedbreve",
  0x020e,
  "Omacron",
  0x014c,
  "Omacronacute",
  0x1e52,
  "Omacrongrave",
  0x1e50,
  "Omega",
  0x2126,
  "Omegacyrillic",
  0x0460,
  "Omegagreek",
  0x03a9,
  "Omegaroundcyrillic",
  0x047a,
  "Omegatitlocyrillic",
  0x047c,
  "Omegatonos",
  0x038f,
  "Omicron",
  0x039f,
  "Omicrontonos",
  0x038c,
  "Omonospace",
  0xff2f,
  "Oneroman",
  0x2160,
  "Oogonek",
  0x01ea,
  "Oogonekmacron",
  0x01ec,
  "Oopen",
  0x0186,
  "Oslash",
  0x00d8,
  "Oslashacute",
  0x01fe,
  "Oslashsmall",
  0xf7f8,
  "Osmall",
  0xf76f,
  "Ostrokeacute",
  0x01fe,
  "Otcyrillic",
  0x047e,
  "Otilde",
  0x00d5,
  "Otildeacute",
  0x1e4c,
  "Otildedieresis",
  0x1e4e,
  "Otildesmall",
  0xf7f5,
  "P",
  0x0050,
  "Pacute",
  0x1e54,
  "Pcircle",
  0x24c5,
  "Pdotaccent",
  0x1e56,
  "Pecyrillic",
  0x041f,
  "Peharmenian",
  0x054a,
  "Pemiddlehookcyrillic",
  0x04a6,
  "Phi",
  0x03a6,
  "Phook",
  0x01a4,
  "Pi",
  0x03a0,
  "Piwrarmenian",
  0x0553,
  "Pmonospace",
  0xff30,
  "Psi",
  0x03a8,
  "Psicyrillic",
  0x0470,
  "Psmall",
  0xf770,
  "Q",
  0x0051,
  "Qcircle",
  0x24c6,
  "Qmonospace",
  0xff31,
  "Qsmall",
  0xf771,
  "R",
  0x0052,
  "Raarmenian",
  0x054c,
  "Racute",
  0x0154,
  "Rcaron",
  0x0158,
  "Rcedilla",
  0x0156,
  "Rcircle",
  0x24c7,
  "Rcommaaccent",
  0x0156,
  "Rdblgrave",
  0x0210,
  "Rdotaccent",
  0x1e58,
  "Rdotbelow",
  0x1e5a,
  "Rdotbelowmacron",
  0x1e5c,
  "Reharmenian",
  0x0550,
  "Rfraktur",
  0x211c,
  "Rho",
  0x03a1,
  "Ringsmall",
  0xf6fc,
  "Rinvertedbreve",
  0x0212,
  "Rlinebelow",
  0x1e5e,
  "Rmonospace",
  0xff32,
  "Rsmall",
  0xf772,
  "Rsmallinverted",
  0x0281,
  "Rsmallinvertedsuperior",
  0x02b6,
  "S",
  0x0053,
  "SF010000",
  0x250c,
  "SF020000",
  0x2514,
  "SF030000",
  0x2510,
  "SF040000",
  0x2518,
  "SF050000",
  0x253c,
  "SF060000",
  0x252c,
  "SF070000",
  0x2534,
  "SF080000",
  0x251c,
  "SF090000",
  0x2524,
  "SF100000",
  0x2500,
  "SF110000",
  0x2502,
  "SF190000",
  0x2561,
  "SF200000",
  0x2562,
  "SF210000",
  0x2556,
  "SF220000",
  0x2555,
  "SF230000",
  0x2563,
  "SF240000",
  0x2551,
  "SF250000",
  0x2557,
  "SF260000",
  0x255d,
  "SF270000",
  0x255c,
  "SF280000",
  0x255b,
  "SF360000",
  0x255e,
  "SF370000",
  0x255f,
  "SF380000",
  0x255a,
  "SF390000",
  0x2554,
  "SF400000",
  0x2569,
  "SF410000",
  0x2566,
  "SF420000",
  0x2560,
  "SF430000",
  0x2550,
  "SF440000",
  0x256c,
  "SF450000",
  0x2567,
  "SF460000",
  0x2568,
  "SF470000",
  0x2564,
  "SF480000",
  0x2565,
  "SF490000",
  0x2559,
  "SF500000",
  0x2558,
  "SF510000",
  0x2552,
  "SF520000",
  0x2553,
  "SF530000",
  0x256b,
  "SF540000",
  0x256a,
  "Sacute",
  0x015a,
  "Sacutedotaccent",
  0x1e64,
  "Sampigreek",
  0x03e0,
  "Scaron",
  0x0160,
  "Scarondotaccent",
  0x1e66,
  "Scaronsmall",
  0xf6fd,
  "Scedilla",
  0x015e,
  "Schwa",
  0x018f,
  "Schwacyrillic",
  0x04d8,
  "Schwadieresiscyrillic",
  0x04da,
  "Scircle",
  0x24c8,
  "Scircumflex",
  0x015c,
  "Scommaaccent",
  0x0218,
  "Sdotaccent",
  0x1e60,
  "Sdotbelow",
  0x1e62,
  "Sdotbelowdotaccent",
  0x1e68,
  "Seharmenian",
  0x054d,
  "Sevenroman",
  0x2166,
  "Shaarmenian",
  0x0547,
  "Shacyrillic",
  0x0428,
  "Shchacyrillic",
  0x0429,
  "Sheicoptic",
  0x03e2,
  "Shhacyrillic",
  0x04ba,
  "Shimacoptic",
  0x03ec,
  "Sigma",
  0x03a3,
  "Sixroman",
  0x2165,
  "Smonospace",
  0xff33,
  "Softsigncyrillic",
  0x042c,
  "Ssmall",
  0xf773,
  "Stigmagreek",
  0x03da,
  "T",
  0x0054,
  "Tau",
  0x03a4,
  "Tbar",
  0x0166,
  "Tcaron",
  0x0164,
  "Tcedilla",
  0x0162,
  "Tcircle",
  0x24c9,
  "Tcircumflexbelow",
  0x1e70,
  "Tcommaaccent",
  0x0162,
  "Tdotaccent",
  0x1e6a,
  "Tdotbelow",
  0x1e6c,
  "Tecyrillic",
  0x0422,
  "Tedescendercyrillic",
  0x04ac,
  "Tenroman",
  0x2169,
  "Tetsecyrillic",
  0x04b4,
  "Theta",
  0x0398,
  "Thook",
  0x01ac,
  "Thorn",
  0x00de,
  "Thornsmall",
  0xf7fe,
  "Threeroman",
  0x2162,
  "Tildesmall",
  0xf6fe,
  "Tiwnarmenian",
  0x054f,
  "Tlinebelow",
  0x1e6e,
  "Tmonospace",
  0xff34,
  "Toarmenian",
  0x0539,
  "Tonefive",
  0x01bc,
  "Tonesix",
  0x0184,
  "Tonetwo",
  0x01a7,
  "Tretroflexhook",
  0x01ae,
  "Tsecyrillic",
  0x0426,
  "Tshecyrillic",
  0x040b,
  "Tsmall",
  0xf774,
  "Twelveroman",
  0x216b,
  "Tworoman",
  0x2161,
  "U",
  0x0055,
  "Uacute",
  0x00da,
  "Uacutesmall",
  0xf7fa,
  "Ubreve",
  0x016c,
  "Ucaron",
  0x01d3,
  "Ucircle",
  0x24ca,
  "Ucircumflex",
  0x00db,
  "Ucircumflexbelow",
  0x1e76,
  "Ucircumflexsmall",
  0xf7fb,
  "Ucyrillic",
  0x0423,
  "Udblacute",
  0x0170,
  "Udblgrave",
  0x0214,
  "Udieresis",
  0x00dc,
  "Udieresisacute",
  0x01d7,
  "Udieresisbelow",
  0x1e72,
  "Udieresiscaron",
  0x01d9,
  "Udieresiscyrillic",
  0x04f0,
  "Udieresisgrave",
  0x01db,
  "Udieresismacron",
  0x01d5,
  "Udieresissmall",
  0xf7fc,
  "Udotbelow",
  0x1ee4,
  "Ugrave",
  0x00d9,
  "Ugravesmall",
  0xf7f9,
  "Uhookabove",
  0x1ee6,
  "Uhorn",
  0x01af,
  "Uhornacute",
  0x1ee8,
  "Uhorndotbelow",
  0x1ef0,
  "Uhorngrave",
  0x1eea,
  "Uhornhookabove",
  0x1eec,
  "Uhorntilde",
  0x1eee,
  "Uhungarumlaut",
  0x0170,
  "Uhungarumlautcyrillic",
  0x04f2,
  "Uinvertedbreve",
  0x0216,
  "Ukcyrillic",
  0x0478,
  "Umacron",
  0x016a,
  "Umacroncyrillic",
  0x04ee,
  "Umacrondieresis",
  0x1e7a,
  "Umonospace",
  0xff35,
  "Uogonek",
  0x0172,
  "Upsilon",
  0x03a5,
  "Upsilon1",
  0x03d2,
  "Upsilonacutehooksymbolgreek",
  0x03d3,
  "Upsilonafrican",
  0x01b1,
  "Upsilondieresis",
  0x03ab,
  "Upsilondieresishooksymbolgreek",
  0x03d4,
  "Upsilonhooksymbol",
  0x03d2,
  "Upsilontonos",
  0x038e,
  "Uring",
  0x016e,
  "Ushortcyrillic",
  0x040e,
  "Usmall",
  0xf775,
  "Ustraightcyrillic",
  0x04ae,
  "Ustraightstrokecyrillic",
  0x04b0,
  "Utilde",
  0x0168,
  "Utildeacute",
  0x1e78,
  "Utildebelow",
  0x1e74,
  "V",
  0x0056,
  "Vcircle",
  0x24cb,
  "Vdotbelow",
  0x1e7e,
  "Vecyrillic",
  0x0412,
  "Vewarmenian",
  0x054e,
  "Vhook",
  0x01b2,
  "Vmonospace",
  0xff36,
  "Voarmenian",
  0x0548,
  "Vsmall",
  0xf776,
  "Vtilde",
  0x1e7c,
  "W",
  0x0057,
  "Wacute",
  0x1e82,
  "Wcircle",
  0x24cc,
  "Wcircumflex",
  0x0174,
  "Wdieresis",
  0x1e84,
  "Wdotaccent",
  0x1e86,
  "Wdotbelow",
  0x1e88,
  "Wgrave",
  0x1e80,
  "Wmonospace",
  0xff37,
  "Wsmall",
  0xf777,
  "X",
  0x0058,
  "Xcircle",
  0x24cd,
  "Xdieresis",
  0x1e8c,
  "Xdotaccent",
  0x1e8a,
  "Xeharmenian",
  0x053d,
  "Xi",
  0x039e,
  "Xmonospace",
  0xff38,
  "Xsmall",
  0xf778,
  "Y",
  0x0059,
  "Yacute",
  0x00dd,
  "Yacutesmall",
  0xf7fd,
  "Yatcyrillic",
  0x0462,
  "Ycircle",
  0x24ce,
  "Ycircumflex",
  0x0176,
  "Ydieresis",
  0x0178,
  "Ydieresissmall",
  0xf7ff,
  "Ydotaccent",
  0x1e8e,
  "Ydotbelow",
  0x1ef4,
  "Yericyrillic",
  0x042b,
  "Yerudieresiscyrillic",
  0x04f8,
  "Ygrave",
  0x1ef2,
  "Yhook",
  0x01b3,
  "Yhookabove",
  0x1ef6,
  "Yiarmenian",
  0x0545,
  "Yicyrillic",
  0x0407,
  "Yiwnarmenian",
  0x0552,
  "Ymonospace",
  0xff39,
  "Ysmall",
  0xf779,
  "Ytilde",
  0x1ef8,
  "Yusbigcyrillic",
  0x046a,
  "Yusbigiotifiedcyrillic",
  0x046c,
  "Yuslittlecyrillic",
  0x0466,
  "Yuslittleiotifiedcyrillic",
  0x0468,
  "Z",
  0x005a,
  "Zaarmenian",
  0x0536,
  "Zacute",
  0x0179,
  "Zcaron",
  0x017d,
  "Zcaronsmall",
  0xf6ff,
  "Zcircle",
  0x24cf,
  "Zcircumflex",
  0x1e90,
  "Zdot",
  0x017b,
  "Zdotaccent",
  0x017b,
  "Zdotbelow",
  0x1e92,
  "Zecyrillic",
  0x0417,
  "Zedescendercyrillic",
  0x0498,
  "Zedieresiscyrillic",
  0x04de,
  "Zeta",
  0x0396,
  "Zhearmenian",
  0x053a,
  "Zhebrevecyrillic",
  0x04c1,
  "Zhecyrillic",
  0x0416,
  "Zhedescendercyrillic",
  0x0496,
  "Zhedieresiscyrillic",
  0x04dc,
  "Zlinebelow",
  0x1e94,
  "Zmonospace",
  0xff3a,
  "Zsmall",
  0xf77a,
  "Zstroke",
  0x01b5,
  "a",
  0x0061,
  "aabengali",
  0x0986,
  "aacute",
  0x00e1,
  "aadeva",
  0x0906,
  "aagujarati",
  0x0a86,
  "aagurmukhi",
  0x0a06,
  "aamatragurmukhi",
  0x0a3e,
  "aarusquare",
  0x3303,
  "aavowelsignbengali",
  0x09be,
  "aavowelsigndeva",
  0x093e,
  "aavowelsigngujarati",
  0x0abe,
  "abbreviationmarkarmenian",
  0x055f,
  "abbreviationsigndeva",
  0x0970,
  "abengali",
  0x0985,
  "abopomofo",
  0x311a,
  "abreve",
  0x0103,
  "abreveacute",
  0x1eaf,
  "abrevecyrillic",
  0x04d1,
  "abrevedotbelow",
  0x1eb7,
  "abrevegrave",
  0x1eb1,
  "abrevehookabove",
  0x1eb3,
  "abrevetilde",
  0x1eb5,
  "acaron",
  0x01ce,
  "acircle",
  0x24d0,
  "acircumflex",
  0x00e2,
  "acircumflexacute",
  0x1ea5,
  "acircumflexdotbelow",
  0x1ead,
  "acircumflexgrave",
  0x1ea7,
  "acircumflexhookabove",
  0x1ea9,
  "acircumflextilde",
  0x1eab,
  "acute",
  0x00b4,
  "acutebelowcmb",
  0x0317,
  "acutecmb",
  0x0301,
  "acutecomb",
  0x0301,
  "acutedeva",
  0x0954,
  "acutelowmod",
  0x02cf,
  "acutetonecmb",
  0x0341,
  "acyrillic",
  0x0430,
  "adblgrave",
  0x0201,
  "addakgurmukhi",
  0x0a71,
  "adeva",
  0x0905,
  "adieresis",
  0x00e4,
  "adieresiscyrillic",
  0x04d3,
  "adieresismacron",
  0x01df,
  "adotbelow",
  0x1ea1,
  "adotmacron",
  0x01e1,
  "ae",
  0x00e6,
  "aeacute",
  0x01fd,
  "aekorean",
  0x3150,
  "aemacron",
  0x01e3,
  "afii00208",
  0x2015,
  "afii08941",
  0x20a4,
  "afii10017",
  0x0410,
  "afii10018",
  0x0411,
  "afii10019",
  0x0412,
  "afii10020",
  0x0413,
  "afii10021",
  0x0414,
  "afii10022",
  0x0415,
  "afii10023",
  0x0401,
  "afii10024",
  0x0416,
  "afii10025",
  0x0417,
  "afii10026",
  0x0418,
  "afii10027",
  0x0419,
  "afii10028",
  0x041a,
  "afii10029",
  0x041b,
  "afii10030",
  0x041c,
  "afii10031",
  0x041d,
  "afii10032",
  0x041e,
  "afii10033",
  0x041f,
  "afii10034",
  0x0420,
  "afii10035",
  0x0421,
  "afii10036",
  0x0422,
  "afii10037",
  0x0423,
  "afii10038",
  0x0424,
  "afii10039",
  0x0425,
  "afii10040",
  0x0426,
  "afii10041",
  0x0427,
  "afii10042",
  0x0428,
  "afii10043",
  0x0429,
  "afii10044",
  0x042a,
  "afii10045",
  0x042b,
  "afii10046",
  0x042c,
  "afii10047",
  0x042d,
  "afii10048",
  0x042e,
  "afii10049",
  0x042f,
  "afii10050",
  0x0490,
  "afii10051",
  0x0402,
  "afii10052",
  0x0403,
  "afii10053",
  0x0404,
  "afii10054",
  0x0405,
  "afii10055",
  0x0406,
  "afii10056",
  0x0407,
  "afii10057",
  0x0408,
  "afii10058",
  0x0409,
  "afii10059",
  0x040a,
  "afii10060",
  0x040b,
  "afii10061",
  0x040c,
  "afii10062",
  0x040e,
  "afii10063",
  0xf6c4,
  "afii10064",
  0xf6c5,
  "afii10065",
  0x0430,
  "afii10066",
  0x0431,
  "afii10067",
  0x0432,
  "afii10068",
  0x0433,
  "afii10069",
  0x0434,
  "afii10070",
  0x0435,
  "afii10071",
  0x0451,
  "afii10072",
  0x0436,
  "afii10073",
  0x0437,
  "afii10074",
  0x0438,
  "afii10075",
  0x0439,
  "afii10076",
  0x043a,
  "afii10077",
  0x043b,
  "afii10078",
  0x043c,
  "afii10079",
  0x043d,
  "afii10080",
  0x043e,
  "afii10081",
  0x043f,
  "afii10082",
  0x0440,
  "afii10083",
  0x0441,
  "afii10084",
  0x0442,
  "afii10085",
  0x0443,
  "afii10086",
  0x0444,
  "afii10087",
  0x0445,
  "afii10088",
  0x0446,
  "afii10089",
  0x0447,
  "afii10090",
  0x0448,
  "afii10091",
  0x0449,
  "afii10092",
  0x044a,
  "afii10093",
  0x044b,
  "afii10094",
  0x044c,
  "afii10095",
  0x044d,
  "afii10096",
  0x044e,
  "afii10097",
  0x044f,
  "afii10098",
  0x0491,
  "afii10099",
  0x0452,
  "afii10100",
  0x0453,
  "afii10101",
  0x0454,
  "afii10102",
  0x0455,
  "afii10103",
  0x0456,
  "afii10104",
  0x0457,
  "afii10105",
  0x0458,
  "afii10106",
  0x0459,
  "afii10107",
  0x045a,
  "afii10108",
  0x045b,
  "afii10109",
  0x045c,
  "afii10110",
  0x045e,
  "afii10145",
  0x040f,
  "afii10146",
  0x0462,
  "afii10147",
  0x0472,
  "afii10148",
  0x0474,
  "afii10192",
  0xf6c6,
  "afii10193",
  0x045f,
  "afii10194",
  0x0463,
  "afii10195",
  0x0473,
  "afii10196",
  0x0475,
  "afii10831",
  0xf6c7,
  "afii10832",
  0xf6c8,
  "afii10846",
  0x04d9,
  "afii299",
  0x200e,
  "afii300",
  0x200f,
  "afii301",
  0x200d,
  "afii57381",
  0x066a,
  "afii57388",
  0x060c,
  "afii57392",
  0x0660,
  "afii57393",
  0x0661,
  "afii57394",
  0x0662,
  "afii57395",
  0x0663,
  "afii57396",
  0x0664,
  "afii57397",
  0x0665,
  "afii57398",
  0x0666,
  "afii57399",
  0x0667,
  "afii57400",
  0x0668,
  "afii57401",
  0x0669,
  "afii57403",
  0x061b,
  "afii57407",
  0x061f,
  "afii57409",
  0x0621,
  "afii57410",
  0x0622,
  "afii57411",
  0x0623,
  "afii57412",
  0x0624,
  "afii57413",
  0x0625,
  "afii57414",
  0x0626,
  "afii57415",
  0x0627,
  "afii57416",
  0x0628,
  "afii57417",
  0x0629,
  "afii57418",
  0x062a,
  "afii57419",
  0x062b,
  "afii57420",
  0x062c,
  "afii57421",
  0x062d,
  "afii57422",
  0x062e,
  "afii57423",
  0x062f,
  "afii57424",
  0x0630,
  "afii57425",
  0x0631,
  "afii57426",
  0x0632,
  "afii57427",
  0x0633,
  "afii57428",
  0x0634,
  "afii57429",
  0x0635,
  "afii57430",
  0x0636,
  "afii57431",
  0x0637,
  "afii57432",
  0x0638,
  "afii57433",
  0x0639,
  "afii57434",
  0x063a,
  "afii57440",
  0x0640,
  "afii57441",
  0x0641,
  "afii57442",
  0x0642,
  "afii57443",
  0x0643,
  "afii57444",
  0x0644,
  "afii57445",
  0x0645,
  "afii57446",
  0x0646,
  "afii57448",
  0x0648,
  "afii57449",
  0x0649,
  "afii57450",
  0x064a,
  "afii57451",
  0x064b,
  "afii57452",
  0x064c,
  "afii57453",
  0x064d,
  "afii57454",
  0x064e,
  "afii57455",
  0x064f,
  "afii57456",
  0x0650,
  "afii57457",
  0x0651,
  "afii57458",
  0x0652,
  "afii57470",
  0x0647,
  "afii57505",
  0x06a4,
  "afii57506",
  0x067e,
  "afii57507",
  0x0686,
  "afii57508",
  0x0698,
  "afii57509",
  0x06af,
  "afii57511",
  0x0679,
  "afii57512",
  0x0688,
  "afii57513",
  0x0691,
  "afii57514",
  0x06ba,
  "afii57519",
  0x06d2,
  "afii57534",
  0x06d5,
  "afii57636",
  0x20aa,
  "afii57645",
  0x05be,
  "afii57658",
  0x05c3,
  "afii57664",
  0x05d0,
  "afii57665",
  0x05d1,
  "afii57666",
  0x05d2,
  "afii57667",
  0x05d3,
  "afii57668",
  0x05d4,
  "afii57669",
  0x05d5,
  "afii57670",
  0x05d6,
  "afii57671",
  0x05d7,
  "afii57672",
  0x05d8,
  "afii57673",
  0x05d9,
  "afii57674",
  0x05da,
  "afii57675",
  0x05db,
  "afii57676",
  0x05dc,
  "afii57677",
  0x05dd,
  "afii57678",
  0x05de,
  "afii57679",
  0x05df,
  "afii57680",
  0x05e0,
  "afii57681",
  0x05e1,
  "afii57682",
  0x05e2,
  "afii57683",
  0x05e3,
  "afii57684",
  0x05e4,
  "afii57685",
  0x05e5,
  "afii57686",
  0x05e6,
  "afii57687",
  0x05e7,
  "afii57688",
  0x05e8,
  "afii57689",
  0x05e9,
  "afii57690",
  0x05ea,
  "afii57694",
  0xfb2a,
  "afii57695",
  0xfb2b,
  "afii57700",
  0xfb4b,
  "afii57705",
  0xfb1f,
  "afii57716",
  0x05f0,
  "afii57717",
  0x05f1,
  "afii57718",
  0x05f2,
  "afii57723",
  0xfb35,
  "afii57793",
  0x05b4,
  "afii57794",
  0x05b5,
  "afii57795",
  0x05b6,
  "afii57796",
  0x05bb,
  "afii57797",
  0x05b8,
  "afii57798",
  0x05b7,
  "afii57799",
  0x05b0,
  "afii57800",
  0x05b2,
  "afii57801",
  0x05b1,
  "afii57802",
  0x05b3,
  "afii57803",
  0x05c2,
  "afii57804",
  0x05c1,
  "afii57806",
  0x05b9,
  "afii57807",
  0x05bc,
  "afii57839",
  0x05bd,
  "afii57841",
  0x05bf,
  "afii57842",
  0x05c0,
  "afii57929",
  0x02bc,
  "afii61248",
  0x2105,
  "afii61289",
  0x2113,
  "afii61352",
  0x2116,
  "afii61573",
  0x202c,
  "afii61574",
  0x202d,
  "afii61575",
  0x202e,
  "afii61664",
  0x200c,
  "afii63167",
  0x066d,
  "afii64937",
  0x02bd,
  "agrave",
  0x00e0,
  "agujarati",
  0x0a85,
  "agurmukhi",
  0x0a05,
  "ahiragana",
  0x3042,
  "ahookabove",
  0x1ea3,
  "aibengali",
  0x0990,
  "aibopomofo",
  0x311e,
  "aideva",
  0x0910,
  "aiecyrillic",
  0x04d5,
  "aigujarati",
  0x0a90,
  "aigurmukhi",
  0x0a10,
  "aimatragurmukhi",
  0x0a48,
  "ainarabic",
  0x0639,
  "ainfinalarabic",
  0xfeca,
  "aininitialarabic",
  0xfecb,
  "ainmedialarabic",
  0xfecc,
  "ainvertedbreve",
  0x0203,
  "aivowelsignbengali",
  0x09c8,
  "aivowelsigndeva",
  0x0948,
  "aivowelsigngujarati",
  0x0ac8,
  "akatakana",
  0x30a2,
  "akatakanahalfwidth",
  0xff71,
  "akorean",
  0x314f,
  "alef",
  0x05d0,
  "alefarabic",
  0x0627,
  "alefdageshhebrew",
  0xfb30,
  "aleffinalarabic",
  0xfe8e,
  "alefhamzaabovearabic",
  0x0623,
  "alefhamzaabovefinalarabic",
  0xfe84,
  "alefhamzabelowarabic",
  0x0625,
  "alefhamzabelowfinalarabic",
  0xfe88,
  "alefhebrew",
  0x05d0,
  "aleflamedhebrew",
  0xfb4f,
  "alefmaddaabovearabic",
  0x0622,
  "alefmaddaabovefinalarabic",
  0xfe82,
  "alefmaksuraarabic",
  0x0649,
  "alefmaksurafinalarabic",
  0xfef0,
  "alefmaksurainitialarabic",
  0xfef3,
  "alefmaksuramedialarabic",
  0xfef4,
  "alefpatahhebrew",
  0xfb2e,
  "alefqamatshebrew",
  0xfb2f,
  "aleph",
  0x2135,
  "allequal",
  0x224c,
  "alpha",
  0x03b1,
  "alphatonos",
  0x03ac,
  "amacron",
  0x0101,
  "amonospace",
  0xff41,
  "ampersand",
  0x0026,
  "ampersandmonospace",
  0xff06,
  "ampersandsmall",
  0xf726,
  "amsquare",
  0x33c2,
  "anbopomofo",
  0x3122,
  "angbopomofo",
  0x3124,
  "angbracketleft",
  0x3008,
  "angbracketright",
  0x3009,
  "angkhankhuthai",
  0x0e5a,
  "angle",
  0x2220,
  "anglebracketleft",
  0x3008,
  "anglebracketleftvertical",
  0xfe3f,
  "anglebracketright",
  0x3009,
  "anglebracketrightvertical",
  0xfe40,
  "angleleft",
  0x2329,
  "angleright",
  0x232a,
  "angstrom",
  0x212b,
  "anoteleia",
  0x0387,
  "anudattadeva",
  0x0952,
  "anusvarabengali",
  0x0982,
  "anusvaradeva",
  0x0902,
  "anusvaragujarati",
  0x0a82,
  "aogonek",
  0x0105,
  "apaatosquare",
  0x3300,
  "aparen",
  0x249c,
  "apostrophearmenian",
  0x055a,
  "apostrophemod",
  0x02bc,
  "apple",
  0xf8ff,
  "approaches",
  0x2250,
  "approxequal",
  0x2248,
  "approxequalorimage",
  0x2252,
  "approximatelyequal",
  0x2245,
  "araeaekorean",
  0x318e,
  "araeakorean",
  0x318d,
  "arc",
  0x2312,
  "arighthalfring",
  0x1e9a,
  "aring",
  0x00e5,
  "aringacute",
  0x01fb,
  "aringbelow",
  0x1e01,
  "arrowboth",
  0x2194,
  "arrowdashdown",
  0x21e3,
  "arrowdashleft",
  0x21e0,
  "arrowdashright",
  0x21e2,
  "arrowdashup",
  0x21e1,
  "arrowdblboth",
  0x21d4,
  "arrowdbldown",
  0x21d3,
  "arrowdblleft",
  0x21d0,
  "arrowdblright",
  0x21d2,
  "arrowdblup",
  0x21d1,
  "arrowdown",
  0x2193,
  "arrowdownleft",
  0x2199,
  "arrowdownright",
  0x2198,
  "arrowdownwhite",
  0x21e9,
  "arrowheaddownmod",
  0x02c5,
  "arrowheadleftmod",
  0x02c2,
  "arrowheadrightmod",
  0x02c3,
  "arrowheadupmod",
  0x02c4,
  "arrowhorizex",
  0xf8e7,
  "arrowleft",
  0x2190,
  "arrowleftdbl",
  0x21d0,
  "arrowleftdblstroke",
  0x21cd,
  "arrowleftoverright",
  0x21c6,
  "arrowleftwhite",
  0x21e6,
  "arrowright",
  0x2192,
  "arrowrightdblstroke",
  0x21cf,
  "arrowrightheavy",
  0x279e,
  "arrowrightoverleft",
  0x21c4,
  "arrowrightwhite",
  0x21e8,
  "arrowtableft",
  0x21e4,
  "arrowtabright",
  0x21e5,
  "arrowup",
  0x2191,
  "arrowupdn",
  0x2195,
  "arrowupdnbse",
  0x21a8,
  "arrowupdownbase",
  0x21a8,
  "arrowupleft",
  0x2196,
  "arrowupleftofdown",
  0x21c5,
  "arrowupright",
  0x2197,
  "arrowupwhite",
  0x21e7,
  "arrowvertex",
  0xf8e6,
  "asciicircum",
  0x005e,
  "asciicircummonospace",
  0xff3e,
  "asciitilde",
  0x007e,
  "asciitildemonospace",
  0xff5e,
  "ascript",
  0x0251,
  "ascriptturned",
  0x0252,
  "asmallhiragana",
  0x3041,
  "asmallkatakana",
  0x30a1,
  "asmallkatakanahalfwidth",
  0xff67,
  "asterisk",
  0x002a,
  "asteriskaltonearabic",
  0x066d,
  "asteriskarabic",
  0x066d,
  "asteriskmath",
  0x2217,
  "asteriskmonospace",
  0xff0a,
  "asterisksmall",
  0xfe61,
  "asterism",
  0x2042,
  "asuperior",
  0xf6e9,
  "asymptoticallyequal",
  0x2243,
  "at",
  0x0040,
  "atilde",
  0x00e3,
  "atmonospace",
  0xff20,
  "atsmall",
  0xfe6b,
  "aturned",
  0x0250,
  "aubengali",
  0x0994,
  "aubopomofo",
  0x3120,
  "audeva",
  0x0914,
  "augujarati",
  0x0a94,
  "augurmukhi",
  0x0a14,
  "aulengthmarkbengali",
  0x09d7,
  "aumatragurmukhi",
  0x0a4c,
  "auvowelsignbengali",
  0x09cc,
  "auvowelsigndeva",
  0x094c,
  "auvowelsigngujarati",
  0x0acc,
  "avagrahadeva",
  0x093d,
  "aybarmenian",
  0x0561,
  "ayin",
  0x05e2,
  "ayinaltonehebrew",
  0xfb20,
  "ayinhebrew",
  0x05e2,
  "b",
  0x0062,
  "babengali",
  0x09ac,
  "backslash",
  0x005c,
  "backslashmonospace",
  0xff3c,
  "badeva",
  0x092c,
  "bagujarati",
  0x0aac,
  "bagurmukhi",
  0x0a2c,
  "bahiragana",
  0x3070,
  "bahtthai",
  0x0e3f,
  "bakatakana",
  0x30d0,
  "bar",
  0x007c,
  "barmonospace",
  0xff5c,
  "bbopomofo",
  0x3105,
  "bcircle",
  0x24d1,
  "bdotaccent",
  0x1e03,
  "bdotbelow",
  0x1e05,
  "beamedsixteenthnotes",
  0x266c,
  "because",
  0x2235,
  "becyrillic",
  0x0431,
  "beharabic",
  0x0628,
  "behfinalarabic",
  0xfe90,
  "behinitialarabic",
  0xfe91,
  "behiragana",
  0x3079,
  "behmedialarabic",
  0xfe92,
  "behmeeminitialarabic",
  0xfc9f,
  "behmeemisolatedarabic",
  0xfc08,
  "behnoonfinalarabic",
  0xfc6d,
  "bekatakana",
  0x30d9,
  "benarmenian",
  0x0562,
  "bet",
  0x05d1,
  "beta",
  0x03b2,
  "betasymbolgreek",
  0x03d0,
  "betdagesh",
  0xfb31,
  "betdageshhebrew",
  0xfb31,
  "bethebrew",
  0x05d1,
  "betrafehebrew",
  0xfb4c,
  "bhabengali",
  0x09ad,
  "bhadeva",
  0x092d,
  "bhagujarati",
  0x0aad,
  "bhagurmukhi",
  0x0a2d,
  "bhook",
  0x0253,
  "bihiragana",
  0x3073,
  "bikatakana",
  0x30d3,
  "bilabialclick",
  0x0298,
  "bindigurmukhi",
  0x0a02,
  "birusquare",
  0x3331,
  "blackcircle",
  0x25cf,
  "blackdiamond",
  0x25c6,
  "blackdownpointingtriangle",
  0x25bc,
  "blackleftpointingpointer",
  0x25c4,
  "blackleftpointingtriangle",
  0x25c0,
  "blacklenticularbracketleft",
  0x3010,
  "blacklenticularbracketleftvertical",
  0xfe3b,
  "blacklenticularbracketright",
  0x3011,
  "blacklenticularbracketrightvertical",
  0xfe3c,
  "blacklowerlefttriangle",
  0x25e3,
  "blacklowerrighttriangle",
  0x25e2,
  "blackrectangle",
  0x25ac,
  "blackrightpointingpointer",
  0x25ba,
  "blackrightpointingtriangle",
  0x25b6,
  "blacksmallsquare",
  0x25aa,
  "blacksmilingface",
  0x263b,
  "blacksquare",
  0x25a0,
  "blackstar",
  0x2605,
  "blackupperlefttriangle",
  0x25e4,
  "blackupperrighttriangle",
  0x25e5,
  "blackuppointingsmalltriangle",
  0x25b4,
  "blackuppointingtriangle",
  0x25b2,
  "blank",
  0x2423,
  "blinebelow",
  0x1e07,
  "block",
  0x2588,
  "bmonospace",
  0xff42,
  "bobaimaithai",
  0x0e1a,
  "bohiragana",
  0x307c,
  "bokatakana",
  0x30dc,
  "bparen",
  0x249d,
  "bqsquare",
  0x33c3,
  "braceex",
  0xf8f4,
  "braceleft",
  0x007b,
  "braceleftbt",
  0xf8f3,
  "braceleftmid",
  0xf8f2,
  "braceleftmonospace",
  0xff5b,
  "braceleftsmall",
  0xfe5b,
  "bracelefttp",
  0xf8f1,
  "braceleftvertical",
  0xfe37,
  "braceright",
  0x007d,
  "bracerightbt",
  0xf8fe,
  "bracerightmid",
  0xf8fd,
  "bracerightmonospace",
  0xff5d,
  "bracerightsmall",
  0xfe5c,
  "bracerighttp",
  0xf8fc,
  "bracerightvertical",
  0xfe38,
  "bracketleft",
  0x005b,
  "bracketleftbt",
  0xf8f0,
  "bracketleftex",
  0xf8ef,
  "bracketleftmonospace",
  0xff3b,
  "bracketlefttp",
  0xf8ee,
  "bracketright",
  0x005d,
  "bracketrightbt",
  0xf8fb,
  "bracketrightex",
  0xf8fa,
  "bracketrightmonospace",
  0xff3d,
  "bracketrighttp",
  0xf8f9,
  "breve",
  0x02d8,
  "brevebelowcmb",
  0x032e,
  "brevecmb",
  0x0306,
  "breveinvertedbelowcmb",
  0x032f,
  "breveinvertedcmb",
  0x0311,
  "breveinverteddoublecmb",
  0x0361,
  "bridgebelowcmb",
  0x032a,
  "bridgeinvertedbelowcmb",
  0x033a,
  "brokenbar",
  0x00a6,
  "bstroke",
  0x0180,
  "bsuperior",
  0xf6ea,
  "btopbar",
  0x0183,
  "buhiragana",
  0x3076,
  "bukatakana",
  0x30d6,
  "bullet",
  0x2022,
  "bulletinverse",
  0x25d8,
  "bulletoperator",
  0x2219,
  "bullseye",
  0x25ce,
  "c",
  0x0063,
  "caarmenian",
  0x056e,
  "cabengali",
  0x099a,
  "cacute",
  0x0107,
  "cadeva",
  0x091a,
  "cagujarati",
  0x0a9a,
  "cagurmukhi",
  0x0a1a,
  "calsquare",
  0x3388,
  "candrabindubengali",
  0x0981,
  "candrabinducmb",
  0x0310,
  "candrabindudeva",
  0x0901,
  "candrabindugujarati",
  0x0a81,
  "capslock",
  0x21ea,
  "careof",
  0x2105,
  "caron",
  0x02c7,
  "caronbelowcmb",
  0x032c,
  "caroncmb",
  0x030c,
  "carriagereturn",
  0x21b5,
  "cbopomofo",
  0x3118,
  "ccaron",
  0x010d,
  "ccedilla",
  0x00e7,
  "ccedillaacute",
  0x1e09,
  "ccircle",
  0x24d2,
  "ccircumflex",
  0x0109,
  "ccurl",
  0x0255,
  "cdot",
  0x010b,
  "cdotaccent",
  0x010b,
  "cdsquare",
  0x33c5,
  "cedilla",
  0x00b8,
  "cedillacmb",
  0x0327,
  "cent",
  0x00a2,
  "centigrade",
  0x2103,
  "centinferior",
  0xf6df,
  "centmonospace",
  0xffe0,
  "centoldstyle",
  0xf7a2,
  "centsuperior",
  0xf6e0,
  "chaarmenian",
  0x0579,
  "chabengali",
  0x099b,
  "chadeva",
  0x091b,
  "chagujarati",
  0x0a9b,
  "chagurmukhi",
  0x0a1b,
  "chbopomofo",
  0x3114,
  "cheabkhasiancyrillic",
  0x04bd,
  "checkmark",
  0x2713,
  "checyrillic",
  0x0447,
  "chedescenderabkhasiancyrillic",
  0x04bf,
  "chedescendercyrillic",
  0x04b7,
  "chedieresiscyrillic",
  0x04f5,
  "cheharmenian",
  0x0573,
  "chekhakassiancyrillic",
  0x04cc,
  "cheverticalstrokecyrillic",
  0x04b9,
  "chi",
  0x03c7,
  "chieuchacirclekorean",
  0x3277,
  "chieuchaparenkorean",
  0x3217,
  "chieuchcirclekorean",
  0x3269,
  "chieuchkorean",
  0x314a,
  "chieuchparenkorean",
  0x3209,
  "chochangthai",
  0x0e0a,
  "chochanthai",
  0x0e08,
  "chochingthai",
  0x0e09,
  "chochoethai",
  0x0e0c,
  "chook",
  0x0188,
  "cieucacirclekorean",
  0x3276,
  "cieucaparenkorean",
  0x3216,
  "cieuccirclekorean",
  0x3268,
  "cieuckorean",
  0x3148,
  "cieucparenkorean",
  0x3208,
  "cieucuparenkorean",
  0x321c,
  "circle",
  0x25cb,
  "circlecopyrt",
  0x00a9,
  "circlemultiply",
  0x2297,
  "circleot",
  0x2299,
  "circleplus",
  0x2295,
  "circlepostalmark",
  0x3036,
  "circlewithlefthalfblack",
  0x25d0,
  "circlewithrighthalfblack",
  0x25d1,
  "circumflex",
  0x02c6,
  "circumflexbelowcmb",
  0x032d,
  "circumflexcmb",
  0x0302,
  "clear",
  0x2327,
  "clickalveolar",
  0x01c2,
  "clickdental",
  0x01c0,
  "clicklateral",
  0x01c1,
  "clickretroflex",
  0x01c3,
  "club",
  0x2663,
  "clubsuitblack",
  0x2663,
  "clubsuitwhite",
  0x2667,
  "cmcubedsquare",
  0x33a4,
  "cmonospace",
  0xff43,
  "cmsquaredsquare",
  0x33a0,
  "coarmenian",
  0x0581,
  "colon",
  0x003a,
  "colonmonetary",
  0x20a1,
  "colonmonospace",
  0xff1a,
  "colonsign",
  0x20a1,
  "colonsmall",
  0xfe55,
  "colontriangularhalfmod",
  0x02d1,
  "colontriangularmod",
  0x02d0,
  "comma",
  0x002c,
  "commaabovecmb",
  0x0313,
  "commaaboverightcmb",
  0x0315,
  "commaaccent",
  0xf6c3,
  "commaarabic",
  0x060c,
  "commaarmenian",
  0x055d,
  "commainferior",
  0xf6e1,
  "commamonospace",
  0xff0c,
  "commareversedabovecmb",
  0x0314,
  "commareversedmod",
  0x02bd,
  "commasmall",
  0xfe50,
  "commasuperior",
  0xf6e2,
  "commaturnedabovecmb",
  0x0312,
  "commaturnedmod",
  0x02bb,
  "compass",
  0x263c,
  "congruent",
  0x2245,
  "contourintegral",
  0x222e,
  "control",
  0x2303,
  "controlACK",
  0x0006,
  "controlBEL",
  0x0007,
  "controlBS",
  0x0008,
  "controlCAN",
  0x0018,
  "controlCR",
  0x000d,
  "controlDC1",
  0x0011,
  "controlDC2",
  0x0012,
  "controlDC3",
  0x0013,
  "controlDC4",
  0x0014,
  "controlDEL",
  0x007f,
  "controlDLE",
  0x0010,
  "controlEM",
  0x0019,
  "controlENQ",
  0x0005,
  "controlEOT",
  0x0004,
  "controlESC",
  0x001b,
  "controlETB",
  0x0017,
  "controlETX",
  0x0003,
  "controlFF",
  0x000c,
  "controlFS",
  0x001c,
  "controlGS",
  0x001d,
  "controlHT",
  0x0009,
  "controlLF",
  0x000a,
  "controlNAK",
  0x0015,
  "controlNULL",
  0x0000,
  "controlRS",
  0x001e,
  "controlSI",
  0x000f,
  "controlSO",
  0x000e,
  "controlSOT",
  0x0002,
  "controlSTX",
  0x0001,
  "controlSUB",
  0x001a,
  "controlSYN",
  0x0016,
  "controlUS",
  0x001f,
  "controlVT",
  0x000b,
  "copyright",
  0x00a9,
  "copyrightsans",
  0xf8e9,
  "copyrightserif",
  0xf6d9,
  "cornerbracketleft",
  0x300c,
  "cornerbracketlefthalfwidth",
  0xff62,
  "cornerbracketleftvertical",
  0xfe41,
  "cornerbracketright",
  0x300d,
  "cornerbracketrighthalfwidth",
  0xff63,
  "cornerbracketrightvertical",
  0xfe42,
  "corporationsquare",
  0x337f,
  "cosquare",
  0x33c7,
  "coverkgsquare",
  0x33c6,
  "cparen",
  0x249e,
  "cruzeiro",
  0x20a2,
  "cstretched",
  0x0297,
  "curlyand",
  0x22cf,
  "curlyor",
  0x22ce,
  "currency",
  0x00a4,
  "cyrBreve",
  0xf6d1,
  "cyrFlex",
  0xf6d2,
  "cyrbreve",
  0xf6d4,
  "cyrflex",
  0xf6d5,
  "d",
  0x0064,
  "daarmenian",
  0x0564,
  "dabengali",
  0x09a6,
  "dadarabic",
  0x0636,
  "dadeva",
  0x0926,
  "dadfinalarabic",
  0xfebe,
  "dadinitialarabic",
  0xfebf,
  "dadmedialarabic",
  0xfec0,
  "dagesh",
  0x05bc,
  "dageshhebrew",
  0x05bc,
  "dagger",
  0x2020,
  "daggerdbl",
  0x2021,
  "dagujarati",
  0x0aa6,
  "dagurmukhi",
  0x0a26,
  "dahiragana",
  0x3060,
  "dakatakana",
  0x30c0,
  "dalarabic",
  0x062f,
  "dalet",
  0x05d3,
  "daletdagesh",
  0xfb33,
  "daletdageshhebrew",
  0xfb33,
  "dalethebrew",
  0x05d3,
  "dalfinalarabic",
  0xfeaa,
  "dammaarabic",
  0x064f,
  "dammalowarabic",
  0x064f,
  "dammatanaltonearabic",
  0x064c,
  "dammatanarabic",
  0x064c,
  "danda",
  0x0964,
  "dargahebrew",
  0x05a7,
  "dargalefthebrew",
  0x05a7,
  "dasiapneumatacyrilliccmb",
  0x0485,
  "dblGrave",
  0xf6d3,
  "dblanglebracketleft",
  0x300a,
  "dblanglebracketleftvertical",
  0xfe3d,
  "dblanglebracketright",
  0x300b,
  "dblanglebracketrightvertical",
  0xfe3e,
  "dblarchinvertedbelowcmb",
  0x032b,
  "dblarrowleft",
  0x21d4,
  "dblarrowright",
  0x21d2,
  "dbldanda",
  0x0965,
  "dblgrave",
  0xf6d6,
  "dblgravecmb",
  0x030f,
  "dblintegral",
  0x222c,
  "dbllowline",
  0x2017,
  "dbllowlinecmb",
  0x0333,
  "dbloverlinecmb",
  0x033f,
  "dblprimemod",
  0x02ba,
  "dblverticalbar",
  0x2016,
  "dblverticallineabovecmb",
  0x030e,
  "dbopomofo",
  0x3109,
  "dbsquare",
  0x33c8,
  "dcaron",
  0x010f,
  "dcedilla",
  0x1e11,
  "dcircle",
  0x24d3,
  "dcircumflexbelow",
  0x1e13,
  "dcroat",
  0x0111,
  "ddabengali",
  0x09a1,
  "ddadeva",
  0x0921,
  "ddagujarati",
  0x0aa1,
  "ddagurmukhi",
  0x0a21,
  "ddalarabic",
  0x0688,
  "ddalfinalarabic",
  0xfb89,
  "dddhadeva",
  0x095c,
  "ddhabengali",
  0x09a2,
  "ddhadeva",
  0x0922,
  "ddhagujarati",
  0x0aa2,
  "ddhagurmukhi",
  0x0a22,
  "ddotaccent",
  0x1e0b,
  "ddotbelow",
  0x1e0d,
  "decimalseparatorarabic",
  0x066b,
  "decimalseparatorpersian",
  0x066b,
  "decyrillic",
  0x0434,
  "degree",
  0x00b0,
  "dehihebrew",
  0x05ad,
  "dehiragana",
  0x3067,
  "deicoptic",
  0x03ef,
  "dekatakana",
  0x30c7,
  "deleteleft",
  0x232b,
  "deleteright",
  0x2326,
  "delta",
  0x03b4,
  "deltaturned",
  0x018d,
  "denominatorminusonenumeratorbengali",
  0x09f8,
  "dezh",
  0x02a4,
  "dhabengali",
  0x09a7,
  "dhadeva",
  0x0927,
  "dhagujarati",
  0x0aa7,
  "dhagurmukhi",
  0x0a27,
  "dhook",
  0x0257,
  "dialytikatonos",
  0x0385,
  "dialytikatonoscmb",
  0x0344,
  "diamond",
  0x2666,
  "diamondsuitwhite",
  0x2662,
  "dieresis",
  0x00a8,
  "dieresisacute",
  0xf6d7,
  "dieresisbelowcmb",
  0x0324,
  "dieresiscmb",
  0x0308,
  "dieresisgrave",
  0xf6d8,
  "dieresistonos",
  0x0385,
  "dihiragana",
  0x3062,
  "dikatakana",
  0x30c2,
  "dittomark",
  0x3003,
  "divide",
  0x00f7,
  "divides",
  0x2223,
  "divisionslash",
  0x2215,
  "djecyrillic",
  0x0452,
  "dkshade",
  0x2593,
  "dlinebelow",
  0x1e0f,
  "dlsquare",
  0x3397,
  "dmacron",
  0x0111,
  "dmonospace",
  0xff44,
  "dnblock",
  0x2584,
  "dochadathai",
  0x0e0e,
  "dodekthai",
  0x0e14,
  "dohiragana",
  0x3069,
  "dokatakana",
  0x30c9,
  "dollar",
  0x0024,
  "dollarinferior",
  0xf6e3,
  "dollarmonospace",
  0xff04,
  "dollaroldstyle",
  0xf724,
  "dollarsmall",
  0xfe69,
  "dollarsuperior",
  0xf6e4,
  "dong",
  0x20ab,
  "dorusquare",
  0x3326,
  "dotaccent",
  0x02d9,
  "dotaccentcmb",
  0x0307,
  "dotbelowcmb",
  0x0323,
  "dotbelowcomb",
  0x0323,
  "dotkatakana",
  0x30fb,
  "dotlessi",
  0x0131,
  "dotlessj",
  0xf6be,
  "dotlessjstrokehook",
  0x0284,
  "dotmath",
  0x22c5,
  "dottedcircle",
  0x25cc,
  "doubleyodpatah",
  0xfb1f,
  "doubleyodpatahhebrew",
  0xfb1f,
  "downtackbelowcmb",
  0x031e,
  "downtackmod",
  0x02d5,
  "dparen",
  0x249f,
  "dsuperior",
  0xf6eb,
  "dtail",
  0x0256,
  "dtopbar",
  0x018c,
  "duhiragana",
  0x3065,
  "dukatakana",
  0x30c5,
  "dz",
  0x01f3,
  "dzaltone",
  0x02a3,
  "dzcaron",
  0x01c6,
  "dzcurl",
  0x02a5,
  "dzeabkhasiancyrillic",
  0x04e1,
  "dzecyrillic",
  0x0455,
  "dzhecyrillic",
  0x045f,
  "e",
  0x0065,
  "eacute",
  0x00e9,
  "earth",
  0x2641,
  "ebengali",
  0x098f,
  "ebopomofo",
  0x311c,
  "ebreve",
  0x0115,
  "ecandradeva",
  0x090d,
  "ecandragujarati",
  0x0a8d,
  "ecandravowelsigndeva",
  0x0945,
  "ecandravowelsigngujarati",
  0x0ac5,
  "ecaron",
  0x011b,
  "ecedillabreve",
  0x1e1d,
  "echarmenian",
  0x0565,
  "echyiwnarmenian",
  0x0587,
  "ecircle",
  0x24d4,
  "ecircumflex",
  0x00ea,
  "ecircumflexacute",
  0x1ebf,
  "ecircumflexbelow",
  0x1e19,
  "ecircumflexdotbelow",
  0x1ec7,
  "ecircumflexgrave",
  0x1ec1,
  "ecircumflexhookabove",
  0x1ec3,
  "ecircumflextilde",
  0x1ec5,
  "ecyrillic",
  0x0454,
  "edblgrave",
  0x0205,
  "edeva",
  0x090f,
  "edieresis",
  0x00eb,
  "edot",
  0x0117,
  "edotaccent",
  0x0117,
  "edotbelow",
  0x1eb9,
  "eegurmukhi",
  0x0a0f,
  "eematragurmukhi",
  0x0a47,
  "efcyrillic",
  0x0444,
  "egrave",
  0x00e8,
  "egujarati",
  0x0a8f,
  "eharmenian",
  0x0567,
  "ehbopomofo",
  0x311d,
  "ehiragana",
  0x3048,
  "ehookabove",
  0x1ebb,
  "eibopomofo",
  0x311f,
  "eight",
  0x0038,
  "eightarabic",
  0x0668,
  "eightbengali",
  0x09ee,
  "eightcircle",
  0x2467,
  "eightcircleinversesansserif",
  0x2791,
  "eightdeva",
  0x096e,
  "eighteencircle",
  0x2471,
  "eighteenparen",
  0x2485,
  "eighteenperiod",
  0x2499,
  "eightgujarati",
  0x0aee,
  "eightgurmukhi",
  0x0a6e,
  "eighthackarabic",
  0x0668,
  "eighthangzhou",
  0x3028,
  "eighthnotebeamed",
  0x266b,
  "eightideographicparen",
  0x3227,
  "eightinferior",
  0x2088,
  "eightmonospace",
  0xff18,
  "eightoldstyle",
  0xf738,
  "eightparen",
  0x247b,
  "eightperiod",
  0x248f,
  "eightpersian",
  0x06f8,
  "eightroman",
  0x2177,
  "eightsuperior",
  0x2078,
  "eightthai",
  0x0e58,
  "einvertedbreve",
  0x0207,
  "eiotifiedcyrillic",
  0x0465,
  "ekatakana",
  0x30a8,
  "ekatakanahalfwidth",
  0xff74,
  "ekonkargurmukhi",
  0x0a74,
  "ekorean",
  0x3154,
  "elcyrillic",
  0x043b,
  "element",
  0x2208,
  "elevencircle",
  0x246a,
  "elevenparen",
  0x247e,
  "elevenperiod",
  0x2492,
  "elevenroman",
  0x217a,
  "ellipsis",
  0x2026,
  "ellipsisvertical",
  0x22ee,
  "emacron",
  0x0113,
  "emacronacute",
  0x1e17,
  "emacrongrave",
  0x1e15,
  "emcyrillic",
  0x043c,
  "emdash",
  0x2014,
  "emdashvertical",
  0xfe31,
  "emonospace",
  0xff45,
  "emphasismarkarmenian",
  0x055b,
  "emptyset",
  0x2205,
  "enbopomofo",
  0x3123,
  "encyrillic",
  0x043d,
  "endash",
  0x2013,
  "endashvertical",
  0xfe32,
  "endescendercyrillic",
  0x04a3,
  "eng",
  0x014b,
  "engbopomofo",
  0x3125,
  "enghecyrillic",
  0x04a5,
  "enhookcyrillic",
  0x04c8,
  "enspace",
  0x2002,
  "eogonek",
  0x0119,
  "eokorean",
  0x3153,
  "eopen",
  0x025b,
  "eopenclosed",
  0x029a,
  "eopenreversed",
  0x025c,
  "eopenreversedclosed",
  0x025e,
  "eopenreversedhook",
  0x025d,
  "eparen",
  0x24a0,
  "epsilon",
  0x03b5,
  "epsilontonos",
  0x03ad,
  "equal",
  0x003d,
  "equalmonospace",
  0xff1d,
  "equalsmall",
  0xfe66,
  "equalsuperior",
  0x207c,
  "equivalence",
  0x2261,
  "erbopomofo",
  0x3126,
  "ercyrillic",
  0x0440,
  "ereversed",
  0x0258,
  "ereversedcyrillic",
  0x044d,
  "escyrillic",
  0x0441,
  "esdescendercyrillic",
  0x04ab,
  "esh",
  0x0283,
  "eshcurl",
  0x0286,
  "eshortdeva",
  0x090e,
  "eshortvowelsigndeva",
  0x0946,
  "eshreversedloop",
  0x01aa,
  "eshsquatreversed",
  0x0285,
  "esmallhiragana",
  0x3047,
  "esmallkatakana",
  0x30a7,
  "esmallkatakanahalfwidth",
  0xff6a,
  "estimated",
  0x212e,
  "esuperior",
  0xf6ec,
  "eta",
  0x03b7,
  "etarmenian",
  0x0568,
  "etatonos",
  0x03ae,
  "eth",
  0x00f0,
  "etilde",
  0x1ebd,
  "etildebelow",
  0x1e1b,
  "etnahtafoukhhebrew",
  0x0591,
  "etnahtafoukhlefthebrew",
  0x0591,
  "etnahtahebrew",
  0x0591,
  "etnahtalefthebrew",
  0x0591,
  "eturned",
  0x01dd,
  "eukorean",
  0x3161,
  "euro",
  0x20ac,
  "evowelsignbengali",
  0x09c7,
  "evowelsigndeva",
  0x0947,
  "evowelsigngujarati",
  0x0ac7,
  "exclam",
  0x0021,
  "exclamarmenian",
  0x055c,
  "exclamdbl",
  0x203c,
  "exclamdown",
  0x00a1,
  "exclamdownsmall",
  0xf7a1,
  "exclammonospace",
  0xff01,
  "exclamsmall",
  0xf721,
  "existential",
  0x2203,
  "ezh",
  0x0292,
  "ezhcaron",
  0x01ef,
  "ezhcurl",
  0x0293,
  "ezhreversed",
  0x01b9,
  "ezhtail",
  0x01ba,
  "f",
  0x0066,
  "fadeva",
  0x095e,
  "fagurmukhi",
  0x0a5e,
  "fahrenheit",
  0x2109,
  "fathaarabic",
  0x064e,
  "fathalowarabic",
  0x064e,
  "fathatanarabic",
  0x064b,
  "fbopomofo",
  0x3108,
  "fcircle",
  0x24d5,
  "fdotaccent",
  0x1e1f,
  "feharabic",
  0x0641,
  "feharmenian",
  0x0586,
  "fehfinalarabic",
  0xfed2,
  "fehinitialarabic",
  0xfed3,
  "fehmedialarabic",
  0xfed4,
  "feicoptic",
  0x03e5,
  "female",
  0x2640,
  "ff",
  0xfb00,
  "f_f",
  0xfb00,
  "ffi",
  0xfb03,
  "ffl",
  0xfb04,
  "fi",
  0xfb01,
  "fifteencircle",
  0x246e,
  "fifteenparen",
  0x2482,
  "fifteenperiod",
  0x2496,
  "figuredash",
  0x2012,
  "filledbox",
  0x25a0,
  "filledrect",
  0x25ac,
  "finalkaf",
  0x05da,
  "finalkafdagesh",
  0xfb3a,
  "finalkafdageshhebrew",
  0xfb3a,
  "finalkafhebrew",
  0x05da,
  "finalmem",
  0x05dd,
  "finalmemhebrew",
  0x05dd,
  "finalnun",
  0x05df,
  "finalnunhebrew",
  0x05df,
  "finalpe",
  0x05e3,
  "finalpehebrew",
  0x05e3,
  "finaltsadi",
  0x05e5,
  "finaltsadihebrew",
  0x05e5,
  "firsttonechinese",
  0x02c9,
  "fisheye",
  0x25c9,
  "fitacyrillic",
  0x0473,
  "five",
  0x0035,
  "fivearabic",
  0x0665,
  "fivebengali",
  0x09eb,
  "fivecircle",
  0x2464,
  "fivecircleinversesansserif",
  0x278e,
  "fivedeva",
  0x096b,
  "fiveeighths",
  0x215d,
  "fivegujarati",
  0x0aeb,
  "fivegurmukhi",
  0x0a6b,
  "fivehackarabic",
  0x0665,
  "fivehangzhou",
  0x3025,
  "fiveideographicparen",
  0x3224,
  "fiveinferior",
  0x2085,
  "fivemonospace",
  0xff15,
  "fiveoldstyle",
  0xf735,
  "fiveparen",
  0x2478,
  "fiveperiod",
  0x248c,
  "fivepersian",
  0x06f5,
  "fiveroman",
  0x2174,
  "fivesuperior",
  0x2075,
  "fivethai",
  0x0e55,
  "fl",
  0xfb02,
  "florin",
  0x0192,
  "fmonospace",
  0xff46,
  "fmsquare",
  0x3399,
  "fofanthai",
  0x0e1f,
  "fofathai",
  0x0e1d,
  "fongmanthai",
  0x0e4f,
  "forall",
  0x2200,
  "four",
  0x0034,
  "fourarabic",
  0x0664,
  "fourbengali",
  0x09ea,
  "fourcircle",
  0x2463,
  "fourcircleinversesansserif",
  0x278d,
  "fourdeva",
  0x096a,
  "fourgujarati",
  0x0aea,
  "fourgurmukhi",
  0x0a6a,
  "fourhackarabic",
  0x0664,
  "fourhangzhou",
  0x3024,
  "fourideographicparen",
  0x3223,
  "fourinferior",
  0x2084,
  "fourmonospace",
  0xff14,
  "fournumeratorbengali",
  0x09f7,
  "fouroldstyle",
  0xf734,
  "fourparen",
  0x2477,
  "fourperiod",
  0x248b,
  "fourpersian",
  0x06f4,
  "fourroman",
  0x2173,
  "foursuperior",
  0x2074,
  "fourteencircle",
  0x246d,
  "fourteenparen",
  0x2481,
  "fourteenperiod",
  0x2495,
  "fourthai",
  0x0e54,
  "fourthtonechinese",
  0x02cb,
  "fparen",
  0x24a1,
  "fraction",
  0x2044,
  "franc",
  0x20a3,
  "g",
  0x0067,
  "gabengali",
  0x0997,
  "gacute",
  0x01f5,
  "gadeva",
  0x0917,
  "gafarabic",
  0x06af,
  "gaffinalarabic",
  0xfb93,
  "gafinitialarabic",
  0xfb94,
  "gafmedialarabic",
  0xfb95,
  "gagujarati",
  0x0a97,
  "gagurmukhi",
  0x0a17,
  "gahiragana",
  0x304c,
  "gakatakana",
  0x30ac,
  "gamma",
  0x03b3,
  "gammalatinsmall",
  0x0263,
  "gammasuperior",
  0x02e0,
  "gangiacoptic",
  0x03eb,
  "gbopomofo",
  0x310d,
  "gbreve",
  0x011f,
  "gcaron",
  0x01e7,
  "gcedilla",
  0x0123,
  "gcircle",
  0x24d6,
  "gcircumflex",
  0x011d,
  "gcommaaccent",
  0x0123,
  "gdot",
  0x0121,
  "gdotaccent",
  0x0121,
  "gecyrillic",
  0x0433,
  "gehiragana",
  0x3052,
  "gekatakana",
  0x30b2,
  "geometricallyequal",
  0x2251,
  "gereshaccenthebrew",
  0x059c,
  "gereshhebrew",
  0x05f3,
  "gereshmuqdamhebrew",
  0x059d,
  "germandbls",
  0x00df,
  "gershayimaccenthebrew",
  0x059e,
  "gershayimhebrew",
  0x05f4,
  "getamark",
  0x3013,
  "ghabengali",
  0x0998,
  "ghadarmenian",
  0x0572,
  "ghadeva",
  0x0918,
  "ghagujarati",
  0x0a98,
  "ghagurmukhi",
  0x0a18,
  "ghainarabic",
  0x063a,
  "ghainfinalarabic",
  0xfece,
  "ghaininitialarabic",
  0xfecf,
  "ghainmedialarabic",
  0xfed0,
  "ghemiddlehookcyrillic",
  0x0495,
  "ghestrokecyrillic",
  0x0493,
  "gheupturncyrillic",
  0x0491,
  "ghhadeva",
  0x095a,
  "ghhagurmukhi",
  0x0a5a,
  "ghook",
  0x0260,
  "ghzsquare",
  0x3393,
  "gihiragana",
  0x304e,
  "gikatakana",
  0x30ae,
  "gimarmenian",
  0x0563,
  "gimel",
  0x05d2,
  "gimeldagesh",
  0xfb32,
  "gimeldageshhebrew",
  0xfb32,
  "gimelhebrew",
  0x05d2,
  "gjecyrillic",
  0x0453,
  "glottalinvertedstroke",
  0x01be,
  "glottalstop",
  0x0294,
  "glottalstopinverted",
  0x0296,
  "glottalstopmod",
  0x02c0,
  "glottalstopreversed",
  0x0295,
  "glottalstopreversedmod",
  0x02c1,
  "glottalstopreversedsuperior",
  0x02e4,
  "glottalstopstroke",
  0x02a1,
  "glottalstopstrokereversed",
  0x02a2,
  "gmacron",
  0x1e21,
  "gmonospace",
  0xff47,
  "gohiragana",
  0x3054,
  "gokatakana",
  0x30b4,
  "gparen",
  0x24a2,
  "gpasquare",
  0x33ac,
  "gradient",
  0x2207,
  "grave",
  0x0060,
  "gravebelowcmb",
  0x0316,
  "gravecmb",
  0x0300,
  "gravecomb",
  0x0300,
  "gravedeva",
  0x0953,
  "gravelowmod",
  0x02ce,
  "gravemonospace",
  0xff40,
  "gravetonecmb",
  0x0340,
  "greater",
  0x003e,
  "greaterequal",
  0x2265,
  "greaterequalorless",
  0x22db,
  "greatermonospace",
  0xff1e,
  "greaterorequivalent",
  0x2273,
  "greaterorless",
  0x2277,
  "greateroverequal",
  0x2267,
  "greatersmall",
  0xfe65,
  "gscript",
  0x0261,
  "gstroke",
  0x01e5,
  "guhiragana",
  0x3050,
  "guillemotleft",
  0x00ab,
  "guillemotright",
  0x00bb,
  "guilsinglleft",
  0x2039,
  "guilsinglright",
  0x203a,
  "gukatakana",
  0x30b0,
  "guramusquare",
  0x3318,
  "gysquare",
  0x33c9,
  "h",
  0x0068,
  "haabkhasiancyrillic",
  0x04a9,
  "haaltonearabic",
  0x06c1,
  "habengali",
  0x09b9,
  "hadescendercyrillic",
  0x04b3,
  "hadeva",
  0x0939,
  "hagujarati",
  0x0ab9,
  "hagurmukhi",
  0x0a39,
  "haharabic",
  0x062d,
  "hahfinalarabic",
  0xfea2,
  "hahinitialarabic",
  0xfea3,
  "hahiragana",
  0x306f,
  "hahmedialarabic",
  0xfea4,
  "haitusquare",
  0x332a,
  "hakatakana",
  0x30cf,
  "hakatakanahalfwidth",
  0xff8a,
  "halantgurmukhi",
  0x0a4d,
  "hamzaarabic",
  0x0621,
  "hamzalowarabic",
  0x0621,
  "hangulfiller",
  0x3164,
  "hardsigncyrillic",
  0x044a,
  "harpoonleftbarbup",
  0x21bc,
  "harpoonrightbarbup",
  0x21c0,
  "hasquare",
  0x33ca,
  "hatafpatah",
  0x05b2,
  "hatafpatah16",
  0x05b2,
  "hatafpatah23",
  0x05b2,
  "hatafpatah2f",
  0x05b2,
  "hatafpatahhebrew",
  0x05b2,
  "hatafpatahnarrowhebrew",
  0x05b2,
  "hatafpatahquarterhebrew",
  0x05b2,
  "hatafpatahwidehebrew",
  0x05b2,
  "hatafqamats",
  0x05b3,
  "hatafqamats1b",
  0x05b3,
  "hatafqamats28",
  0x05b3,
  "hatafqamats34",
  0x05b3,
  "hatafqamatshebrew",
  0x05b3,
  "hatafqamatsnarrowhebrew",
  0x05b3,
  "hatafqamatsquarterhebrew",
  0x05b3,
  "hatafqamatswidehebrew",
  0x05b3,
  "hatafsegol",
  0x05b1,
  "hatafsegol17",
  0x05b1,
  "hatafsegol24",
  0x05b1,
  "hatafsegol30",
  0x05b1,
  "hatafsegolhebrew",
  0x05b1,
  "hatafsegolnarrowhebrew",
  0x05b1,
  "hatafsegolquarterhebrew",
  0x05b1,
  "hatafsegolwidehebrew",
  0x05b1,
  "hbar",
  0x0127,
  "hbopomofo",
  0x310f,
  "hbrevebelow",
  0x1e2b,
  "hcedilla",
  0x1e29,
  "hcircle",
  0x24d7,
  "hcircumflex",
  0x0125,
  "hdieresis",
  0x1e27,
  "hdotaccent",
  0x1e23,
  "hdotbelow",
  0x1e25,
  "he",
  0x05d4,
  "heart",
  0x2665,
  "heartsuitblack",
  0x2665,
  "heartsuitwhite",
  0x2661,
  "hedagesh",
  0xfb34,
  "hedageshhebrew",
  0xfb34,
  "hehaltonearabic",
  0x06c1,
  "heharabic",
  0x0647,
  "hehebrew",
  0x05d4,
  "hehfinalaltonearabic",
  0xfba7,
  "hehfinalalttwoarabic",
  0xfeea,
  "hehfinalarabic",
  0xfeea,
  "hehhamzaabovefinalarabic",
  0xfba5,
  "hehhamzaaboveisolatedarabic",
  0xfba4,
  "hehinitialaltonearabic",
  0xfba8,
  "hehinitialarabic",
  0xfeeb,
  "hehiragana",
  0x3078,
  "hehmedialaltonearabic",
  0xfba9,
  "hehmedialarabic",
  0xfeec,
  "heiseierasquare",
  0x337b,
  "hekatakana",
  0x30d8,
  "hekatakanahalfwidth",
  0xff8d,
  "hekutaarusquare",
  0x3336,
  "henghook",
  0x0267,
  "herutusquare",
  0x3339,
  "het",
  0x05d7,
  "hethebrew",
  0x05d7,
  "hhook",
  0x0266,
  "hhooksuperior",
  0x02b1,
  "hieuhacirclekorean",
  0x327b,
  "hieuhaparenkorean",
  0x321b,
  "hieuhcirclekorean",
  0x326d,
  "hieuhkorean",
  0x314e,
  "hieuhparenkorean",
  0x320d,
  "hihiragana",
  0x3072,
  "hikatakana",
  0x30d2,
  "hikatakanahalfwidth",
  0xff8b,
  "hiriq",
  0x05b4,
  "hiriq14",
  0x05b4,
  "hiriq21",
  0x05b4,
  "hiriq2d",
  0x05b4,
  "hiriqhebrew",
  0x05b4,
  "hiriqnarrowhebrew",
  0x05b4,
  "hiriqquarterhebrew",
  0x05b4,
  "hiriqwidehebrew",
  0x05b4,
  "hlinebelow",
  0x1e96,
  "hmonospace",
  0xff48,
  "hoarmenian",
  0x0570,
  "hohipthai",
  0x0e2b,
  "hohiragana",
  0x307b,
  "hokatakana",
  0x30db,
  "hokatakanahalfwidth",
  0xff8e,
  "holam",
  0x05b9,
  "holam19",
  0x05b9,
  "holam26",
  0x05b9,
  "holam32",
  0x05b9,
  "holamhebrew",
  0x05b9,
  "holamnarrowhebrew",
  0x05b9,
  "holamquarterhebrew",
  0x05b9,
  "holamwidehebrew",
  0x05b9,
  "honokhukthai",
  0x0e2e,
  "hookabovecomb",
  0x0309,
  "hookcmb",
  0x0309,
  "hookpalatalizedbelowcmb",
  0x0321,
  "hookretroflexbelowcmb",
  0x0322,
  "hoonsquare",
  0x3342,
  "horicoptic",
  0x03e9,
  "horizontalbar",
  0x2015,
  "horncmb",
  0x031b,
  "hotsprings",
  0x2668,
  "house",
  0x2302,
  "hparen",
  0x24a3,
  "hsuperior",
  0x02b0,
  "hturned",
  0x0265,
  "huhiragana",
  0x3075,
  "huiitosquare",
  0x3333,
  "hukatakana",
  0x30d5,
  "hukatakanahalfwidth",
  0xff8c,
  "hungarumlaut",
  0x02dd,
  "hungarumlautcmb",
  0x030b,
  "hv",
  0x0195,
  "hyphen",
  0x002d,
  "hypheninferior",
  0xf6e5,
  "hyphenmonospace",
  0xff0d,
  "hyphensmall",
  0xfe63,
  "hyphensuperior",
  0xf6e6,
  "hyphentwo",
  0x2010,
  "i",
  0x0069,
  "iacute",
  0x00ed,
  "iacyrillic",
  0x044f,
  "ibengali",
  0x0987,
  "ibopomofo",
  0x3127,
  "ibreve",
  0x012d,
  "icaron",
  0x01d0,
  "icircle",
  0x24d8,
  "icircumflex",
  0x00ee,
  "icyrillic",
  0x0456,
  "idblgrave",
  0x0209,
  "ideographearthcircle",
  0x328f,
  "ideographfirecircle",
  0x328b,
  "ideographicallianceparen",
  0x323f,
  "ideographiccallparen",
  0x323a,
  "ideographiccentrecircle",
  0x32a5,
  "ideographicclose",
  0x3006,
  "ideographiccomma",
  0x3001,
  "ideographiccommaleft",
  0xff64,
  "ideographiccongratulationparen",
  0x3237,
  "ideographiccorrectcircle",
  0x32a3,
  "ideographicearthparen",
  0x322f,
  "ideographicenterpriseparen",
  0x323d,
  "ideographicexcellentcircle",
  0x329d,
  "ideographicfestivalparen",
  0x3240,
  "ideographicfinancialcircle",
  0x3296,
  "ideographicfinancialparen",
  0x3236,
  "ideographicfireparen",
  0x322b,
  "ideographichaveparen",
  0x3232,
  "ideographichighcircle",
  0x32a4,
  "ideographiciterationmark",
  0x3005,
  "ideographiclaborcircle",
  0x3298,
  "ideographiclaborparen",
  0x3238,
  "ideographicleftcircle",
  0x32a7,
  "ideographiclowcircle",
  0x32a6,
  "ideographicmedicinecircle",
  0x32a9,
  "ideographicmetalparen",
  0x322e,
  "ideographicmoonparen",
  0x322a,
  "ideographicnameparen",
  0x3234,
  "ideographicperiod",
  0x3002,
  "ideographicprintcircle",
  0x329e,
  "ideographicreachparen",
  0x3243,
  "ideographicrepresentparen",
  0x3239,
  "ideographicresourceparen",
  0x323e,
  "ideographicrightcircle",
  0x32a8,
  "ideographicsecretcircle",
  0x3299,
  "ideographicselfparen",
  0x3242,
  "ideographicsocietyparen",
  0x3233,
  "ideographicspace",
  0x3000,
  "ideographicspecialparen",
  0x3235,
  "ideographicstockparen",
  0x3231,
  "ideographicstudyparen",
  0x323b,
  "ideographicsunparen",
  0x3230,
  "ideographicsuperviseparen",
  0x323c,
  "ideographicwaterparen",
  0x322c,
  "ideographicwoodparen",
  0x322d,
  "ideographiczero",
  0x3007,
  "ideographmetalcircle",
  0x328e,
  "ideographmooncircle",
  0x328a,
  "ideographnamecircle",
  0x3294,
  "ideographsuncircle",
  0x3290,
  "ideographwatercircle",
  0x328c,
  "ideographwoodcircle",
  0x328d,
  "ideva",
  0x0907,
  "idieresis",
  0x00ef,
  "idieresisacute",
  0x1e2f,
  "idieresiscyrillic",
  0x04e5,
  "idotbelow",
  0x1ecb,
  "iebrevecyrillic",
  0x04d7,
  "iecyrillic",
  0x0435,
  "ieungacirclekorean",
  0x3275,
  "ieungaparenkorean",
  0x3215,
  "ieungcirclekorean",
  0x3267,
  "ieungkorean",
  0x3147,
  "ieungparenkorean",
  0x3207,
  "igrave",
  0x00ec,
  "igujarati",
  0x0a87,
  "igurmukhi",
  0x0a07,
  "ihiragana",
  0x3044,
  "ihookabove",
  0x1ec9,
  "iibengali",
  0x0988,
  "iicyrillic",
  0x0438,
  "iideva",
  0x0908,
  "iigujarati",
  0x0a88,
  "iigurmukhi",
  0x0a08,
  "iimatragurmukhi",
  0x0a40,
  "iinvertedbreve",
  0x020b,
  "iishortcyrillic",
  0x0439,
  "iivowelsignbengali",
  0x09c0,
  "iivowelsigndeva",
  0x0940,
  "iivowelsigngujarati",
  0x0ac0,
  "ij",
  0x0133,
  "ikatakana",
  0x30a4,
  "ikatakanahalfwidth",
  0xff72,
  "ikorean",
  0x3163,
  "ilde",
  0x02dc,
  "iluyhebrew",
  0x05ac,
  "imacron",
  0x012b,
  "imacroncyrillic",
  0x04e3,
  "imageorapproximatelyequal",
  0x2253,
  "imatragurmukhi",
  0x0a3f,
  "imonospace",
  0xff49,
  "increment",
  0x2206,
  "infinity",
  0x221e,
  "iniarmenian",
  0x056b,
  "integral",
  0x222b,
  "integralbottom",
  0x2321,
  "integralbt",
  0x2321,
  "integralex",
  0xf8f5,
  "integraltop",
  0x2320,
  "integraltp",
  0x2320,
  "intersection",
  0x2229,
  "intisquare",
  0x3305,
  "invbullet",
  0x25d8,
  "invcircle",
  0x25d9,
  "invsmileface",
  0x263b,
  "iocyrillic",
  0x0451,
  "iogonek",
  0x012f,
  "iota",
  0x03b9,
  "iotadieresis",
  0x03ca,
  "iotadieresistonos",
  0x0390,
  "iotalatin",
  0x0269,
  "iotatonos",
  0x03af,
  "iparen",
  0x24a4,
  "irigurmukhi",
  0x0a72,
  "ismallhiragana",
  0x3043,
  "ismallkatakana",
  0x30a3,
  "ismallkatakanahalfwidth",
  0xff68,
  "issharbengali",
  0x09fa,
  "istroke",
  0x0268,
  "isuperior",
  0xf6ed,
  "iterationhiragana",
  0x309d,
  "iterationkatakana",
  0x30fd,
  "itilde",
  0x0129,
  "itildebelow",
  0x1e2d,
  "iubopomofo",
  0x3129,
  "iucyrillic",
  0x044e,
  "ivowelsignbengali",
  0x09bf,
  "ivowelsigndeva",
  0x093f,
  "ivowelsigngujarati",
  0x0abf,
  "izhitsacyrillic",
  0x0475,
  "izhitsadblgravecyrillic",
  0x0477,
  "j",
  0x006a,
  "jaarmenian",
  0x0571,
  "jabengali",
  0x099c,
  "jadeva",
  0x091c,
  "jagujarati",
  0x0a9c,
  "jagurmukhi",
  0x0a1c,
  "jbopomofo",
  0x3110,
  "jcaron",
  0x01f0,
  "jcircle",
  0x24d9,
  "jcircumflex",
  0x0135,
  "jcrossedtail",
  0x029d,
  "jdotlessstroke",
  0x025f,
  "jecyrillic",
  0x0458,
  "jeemarabic",
  0x062c,
  "jeemfinalarabic",
  0xfe9e,
  "jeeminitialarabic",
  0xfe9f,
  "jeemmedialarabic",
  0xfea0,
  "jeharabic",
  0x0698,
  "jehfinalarabic",
  0xfb8b,
  "jhabengali",
  0x099d,
  "jhadeva",
  0x091d,
  "jhagujarati",
  0x0a9d,
  "jhagurmukhi",
  0x0a1d,
  "jheharmenian",
  0x057b,
  "jis",
  0x3004,
  "jmonospace",
  0xff4a,
  "jparen",
  0x24a5,
  "jsuperior",
  0x02b2,
  "k",
  0x006b,
  "kabashkircyrillic",
  0x04a1,
  "kabengali",
  0x0995,
  "kacute",
  0x1e31,
  "kacyrillic",
  0x043a,
  "kadescendercyrillic",
  0x049b,
  "kadeva",
  0x0915,
  "kaf",
  0x05db,
  "kafarabic",
  0x0643,
  "kafdagesh",
  0xfb3b,
  "kafdageshhebrew",
  0xfb3b,
  "kaffinalarabic",
  0xfeda,
  "kafhebrew",
  0x05db,
  "kafinitialarabic",
  0xfedb,
  "kafmedialarabic",
  0xfedc,
  "kafrafehebrew",
  0xfb4d,
  "kagujarati",
  0x0a95,
  "kagurmukhi",
  0x0a15,
  "kahiragana",
  0x304b,
  "kahookcyrillic",
  0x04c4,
  "kakatakana",
  0x30ab,
  "kakatakanahalfwidth",
  0xff76,
  "kappa",
  0x03ba,
  "kappasymbolgreek",
  0x03f0,
  "kapyeounmieumkorean",
  0x3171,
  "kapyeounphieuphkorean",
  0x3184,
  "kapyeounpieupkorean",
  0x3178,
  "kapyeounssangpieupkorean",
  0x3179,
  "karoriisquare",
  0x330d,
  "kashidaautoarabic",
  0x0640,
  "kashidaautonosidebearingarabic",
  0x0640,
  "kasmallkatakana",
  0x30f5,
  "kasquare",
  0x3384,
  "kasraarabic",
  0x0650,
  "kasratanarabic",
  0x064d,
  "kastrokecyrillic",
  0x049f,
  "katahiraprolongmarkhalfwidth",
  0xff70,
  "kaverticalstrokecyrillic",
  0x049d,
  "kbopomofo",
  0x310e,
  "kcalsquare",
  0x3389,
  "kcaron",
  0x01e9,
  "kcedilla",
  0x0137,
  "kcircle",
  0x24da,
  "kcommaaccent",
  0x0137,
  "kdotbelow",
  0x1e33,
  "keharmenian",
  0x0584,
  "kehiragana",
  0x3051,
  "kekatakana",
  0x30b1,
  "kekatakanahalfwidth",
  0xff79,
  "kenarmenian",
  0x056f,
  "kesmallkatakana",
  0x30f6,
  "kgreenlandic",
  0x0138,
  "khabengali",
  0x0996,
  "khacyrillic",
  0x0445,
  "khadeva",
  0x0916,
  "khagujarati",
  0x0a96,
  "khagurmukhi",
  0x0a16,
  "khaharabic",
  0x062e,
  "khahfinalarabic",
  0xfea6,
  "khahinitialarabic",
  0xfea7,
  "khahmedialarabic",
  0xfea8,
  "kheicoptic",
  0x03e7,
  "khhadeva",
  0x0959,
  "khhagurmukhi",
  0x0a59,
  "khieukhacirclekorean",
  0x3278,
  "khieukhaparenkorean",
  0x3218,
  "khieukhcirclekorean",
  0x326a,
  "khieukhkorean",
  0x314b,
  "khieukhparenkorean",
  0x320a,
  "khokhaithai",
  0x0e02,
  "khokhonthai",
  0x0e05,
  "khokhuatthai",
  0x0e03,
  "khokhwaithai",
  0x0e04,
  "khomutthai",
  0x0e5b,
  "khook",
  0x0199,
  "khorakhangthai",
  0x0e06,
  "khzsquare",
  0x3391,
  "kihiragana",
  0x304d,
  "kikatakana",
  0x30ad,
  "kikatakanahalfwidth",
  0xff77,
  "kiroguramusquare",
  0x3315,
  "kiromeetorusquare",
  0x3316,
  "kirosquare",
  0x3314,
  "kiyeokacirclekorean",
  0x326e,
  "kiyeokaparenkorean",
  0x320e,
  "kiyeokcirclekorean",
  0x3260,
  "kiyeokkorean",
  0x3131,
  "kiyeokparenkorean",
  0x3200,
  "kiyeoksioskorean",
  0x3133,
  "kjecyrillic",
  0x045c,
  "klinebelow",
  0x1e35,
  "klsquare",
  0x3398,
  "kmcubedsquare",
  0x33a6,
  "kmonospace",
  0xff4b,
  "kmsquaredsquare",
  0x33a2,
  "kohiragana",
  0x3053,
  "kohmsquare",
  0x33c0,
  "kokaithai",
  0x0e01,
  "kokatakana",
  0x30b3,
  "kokatakanahalfwidth",
  0xff7a,
  "kooposquare",
  0x331e,
  "koppacyrillic",
  0x0481,
  "koreanstandardsymbol",
  0x327f,
  "koroniscmb",
  0x0343,
  "kparen",
  0x24a6,
  "kpasquare",
  0x33aa,
  "ksicyrillic",
  0x046f,
  "ktsquare",
  0x33cf,
  "kturned",
  0x029e,
  "kuhiragana",
  0x304f,
  "kukatakana",
  0x30af,
  "kukatakanahalfwidth",
  0xff78,
  "kvsquare",
  0x33b8,
  "kwsquare",
  0x33be,
  "l",
  0x006c,
  "labengali",
  0x09b2,
  "lacute",
  0x013a,
  "ladeva",
  0x0932,
  "lagujarati",
  0x0ab2,
  "lagurmukhi",
  0x0a32,
  "lakkhangyaothai",
  0x0e45,
  "lamaleffinalarabic",
  0xfefc,
  "lamalefhamzaabovefinalarabic",
  0xfef8,
  "lamalefhamzaaboveisolatedarabic",
  0xfef7,
  "lamalefhamzabelowfinalarabic",
  0xfefa,
  "lamalefhamzabelowisolatedarabic",
  0xfef9,
  "lamalefisolatedarabic",
  0xfefb,
  "lamalefmaddaabovefinalarabic",
  0xfef6,
  "lamalefmaddaaboveisolatedarabic",
  0xfef5,
  "lamarabic",
  0x0644,
  "lambda",
  0x03bb,
  "lambdastroke",
  0x019b,
  "lamed",
  0x05dc,
  "lameddagesh",
  0xfb3c,
  "lameddageshhebrew",
  0xfb3c,
  "lamedhebrew",
  0x05dc,
  "lamfinalarabic",
  0xfede,
  "lamhahinitialarabic",
  0xfcca,
  "laminitialarabic",
  0xfedf,
  "lamjeeminitialarabic",
  0xfcc9,
  "lamkhahinitialarabic",
  0xfccb,
  "lamlamhehisolatedarabic",
  0xfdf2,
  "lammedialarabic",
  0xfee0,
  "lammeemhahinitialarabic",
  0xfd88,
  "lammeeminitialarabic",
  0xfccc,
  "largecircle",
  0x25ef,
  "lbar",
  0x019a,
  "lbelt",
  0x026c,
  "lbopomofo",
  0x310c,
  "lcaron",
  0x013e,
  "lcedilla",
  0x013c,
  "lcircle",
  0x24db,
  "lcircumflexbelow",
  0x1e3d,
  "lcommaaccent",
  0x013c,
  "ldot",
  0x0140,
  "ldotaccent",
  0x0140,
  "ldotbelow",
  0x1e37,
  "ldotbelowmacron",
  0x1e39,
  "leftangleabovecmb",
  0x031a,
  "lefttackbelowcmb",
  0x0318,
  "less",
  0x003c,
  "lessequal",
  0x2264,
  "lessequalorgreater",
  0x22da,
  "lessmonospace",
  0xff1c,
  "lessorequivalent",
  0x2272,
  "lessorgreater",
  0x2276,
  "lessoverequal",
  0x2266,
  "lesssmall",
  0xfe64,
  "lezh",
  0x026e,
  "lfblock",
  0x258c,
  "lhookretroflex",
  0x026d,
  "lira",
  0x20a4,
  "liwnarmenian",
  0x056c,
  "lj",
  0x01c9,
  "ljecyrillic",
  0x0459,
  "ll",
  0xf6c0,
  "lladeva",
  0x0933,
  "llagujarati",
  0x0ab3,
  "llinebelow",
  0x1e3b,
  "llladeva",
  0x0934,
  "llvocalicbengali",
  0x09e1,
  "llvocalicdeva",
  0x0961,
  "llvocalicvowelsignbengali",
  0x09e3,
  "llvocalicvowelsigndeva",
  0x0963,
  "lmiddletilde",
  0x026b,
  "lmonospace",
  0xff4c,
  "lmsquare",
  0x33d0,
  "lochulathai",
  0x0e2c,
  "logicaland",
  0x2227,
  "logicalnot",
  0x00ac,
  "logicalnotreversed",
  0x2310,
  "logicalor",
  0x2228,
  "lolingthai",
  0x0e25,
  "longs",
  0x017f,
  "lowlinecenterline",
  0xfe4e,
  "lowlinecmb",
  0x0332,
  "lowlinedashed",
  0xfe4d,
  "lozenge",
  0x25ca,
  "lparen",
  0x24a7,
  "lslash",
  0x0142,
  "lsquare",
  0x2113,
  "lsuperior",
  0xf6ee,
  "ltshade",
  0x2591,
  "luthai",
  0x0e26,
  "lvocalicbengali",
  0x098c,
  "lvocalicdeva",
  0x090c,
  "lvocalicvowelsignbengali",
  0x09e2,
  "lvocalicvowelsigndeva",
  0x0962,
  "lxsquare",
  0x33d3,
  "m",
  0x006d,
  "mabengali",
  0x09ae,
  "macron",
  0x00af,
  "macronbelowcmb",
  0x0331,
  "macroncmb",
  0x0304,
  "macronlowmod",
  0x02cd,
  "macronmonospace",
  0xffe3,
  "macute",
  0x1e3f,
  "madeva",
  0x092e,
  "magujarati",
  0x0aae,
  "magurmukhi",
  0x0a2e,
  "mahapakhhebrew",
  0x05a4,
  "mahapakhlefthebrew",
  0x05a4,
  "mahiragana",
  0x307e,
  "maichattawalowleftthai",
  0xf895,
  "maichattawalowrightthai",
  0xf894,
  "maichattawathai",
  0x0e4b,
  "maichattawaupperleftthai",
  0xf893,
  "maieklowleftthai",
  0xf88c,
  "maieklowrightthai",
  0xf88b,
  "maiekthai",
  0x0e48,
  "maiekupperleftthai",
  0xf88a,
  "maihanakatleftthai",
  0xf884,
  "maihanakatthai",
  0x0e31,
  "maitaikhuleftthai",
  0xf889,
  "maitaikhuthai",
  0x0e47,
  "maitholowleftthai",
  0xf88f,
  "maitholowrightthai",
  0xf88e,
  "maithothai",
  0x0e49,
  "maithoupperleftthai",
  0xf88d,
  "maitrilowleftthai",
  0xf892,
  "maitrilowrightthai",
  0xf891,
  "maitrithai",
  0x0e4a,
  "maitriupperleftthai",
  0xf890,
  "maiyamokthai",
  0x0e46,
  "makatakana",
  0x30de,
  "makatakanahalfwidth",
  0xff8f,
  "male",
  0x2642,
  "mansyonsquare",
  0x3347,
  "maqafhebrew",
  0x05be,
  "mars",
  0x2642,
  "masoracirclehebrew",
  0x05af,
  "masquare",
  0x3383,
  "mbopomofo",
  0x3107,
  "mbsquare",
  0x33d4,
  "mcircle",
  0x24dc,
  "mcubedsquare",
  0x33a5,
  "mdotaccent",
  0x1e41,
  "mdotbelow",
  0x1e43,
  "meemarabic",
  0x0645,
  "meemfinalarabic",
  0xfee2,
  "meeminitialarabic",
  0xfee3,
  "meemmedialarabic",
  0xfee4,
  "meemmeeminitialarabic",
  0xfcd1,
  "meemmeemisolatedarabic",
  0xfc48,
  "meetorusquare",
  0x334d,
  "mehiragana",
  0x3081,
  "meizierasquare",
  0x337e,
  "mekatakana",
  0x30e1,
  "mekatakanahalfwidth",
  0xff92,
  "mem",
  0x05de,
  "memdagesh",
  0xfb3e,
  "memdageshhebrew",
  0xfb3e,
  "memhebrew",
  0x05de,
  "menarmenian",
  0x0574,
  "merkhahebrew",
  0x05a5,
  "merkhakefulahebrew",
  0x05a6,
  "merkhakefulalefthebrew",
  0x05a6,
  "merkhalefthebrew",
  0x05a5,
  "mhook",
  0x0271,
  "mhzsquare",
  0x3392,
  "middledotkatakanahalfwidth",
  0xff65,
  "middot",
  0x00b7,
  "mieumacirclekorean",
  0x3272,
  "mieumaparenkorean",
  0x3212,
  "mieumcirclekorean",
  0x3264,
  "mieumkorean",
  0x3141,
  "mieumpansioskorean",
  0x3170,
  "mieumparenkorean",
  0x3204,
  "mieumpieupkorean",
  0x316e,
  "mieumsioskorean",
  0x316f,
  "mihiragana",
  0x307f,
  "mikatakana",
  0x30df,
  "mikatakanahalfwidth",
  0xff90,
  "minus",
  0x2212,
  "minusbelowcmb",
  0x0320,
  "minuscircle",
  0x2296,
  "minusmod",
  0x02d7,
  "minusplus",
  0x2213,
  "minute",
  0x2032,
  "miribaarusquare",
  0x334a,
  "mirisquare",
  0x3349,
  "mlonglegturned",
  0x0270,
  "mlsquare",
  0x3396,
  "mmcubedsquare",
  0x33a3,
  "mmonospace",
  0xff4d,
  "mmsquaredsquare",
  0x339f,
  "mohiragana",
  0x3082,
  "mohmsquare",
  0x33c1,
  "mokatakana",
  0x30e2,
  "mokatakanahalfwidth",
  0xff93,
  "molsquare",
  0x33d6,
  "momathai",
  0x0e21,
  "moverssquare",
  0x33a7,
  "moverssquaredsquare",
  0x33a8,
  "mparen",
  0x24a8,
  "mpasquare",
  0x33ab,
  "mssquare",
  0x33b3,
  "msuperior",
  0xf6ef,
  "mturned",
  0x026f,
  "mu",
  0x00b5,
  "mu1",
  0x00b5,
  "muasquare",
  0x3382,
  "muchgreater",
  0x226b,
  "muchless",
  0x226a,
  "mufsquare",
  0x338c,
  "mugreek",
  0x03bc,
  "mugsquare",
  0x338d,
  "muhiragana",
  0x3080,
  "mukatakana",
  0x30e0,
  "mukatakanahalfwidth",
  0xff91,
  "mulsquare",
  0x3395,
  "multiply",
  0x00d7,
  "mumsquare",
  0x339b,
  "munahhebrew",
  0x05a3,
  "munahlefthebrew",
  0x05a3,
  "musicalnote",
  0x266a,
  "musicalnotedbl",
  0x266b,
  "musicflatsign",
  0x266d,
  "musicsharpsign",
  0x266f,
  "mussquare",
  0x33b2,
  "muvsquare",
  0x33b6,
  "muwsquare",
  0x33bc,
  "mvmegasquare",
  0x33b9,
  "mvsquare",
  0x33b7,
  "mwmegasquare",
  0x33bf,
  "mwsquare",
  0x33bd,
  "n",
  0x006e,
  "nabengali",
  0x09a8,
  "nabla",
  0x2207,
  "nacute",
  0x0144,
  "nadeva",
  0x0928,
  "nagujarati",
  0x0aa8,
  "nagurmukhi",
  0x0a28,
  "nahiragana",
  0x306a,
  "nakatakana",
  0x30ca,
  "nakatakanahalfwidth",
  0xff85,
  "napostrophe",
  0x0149,
  "nasquare",
  0x3381,
  "nbopomofo",
  0x310b,
  "nbspace",
  0x00a0,
  "ncaron",
  0x0148,
  "ncedilla",
  0x0146,
  "ncircle",
  0x24dd,
  "ncircumflexbelow",
  0x1e4b,
  "ncommaaccent",
  0x0146,
  "ndotaccent",
  0x1e45,
  "ndotbelow",
  0x1e47,
  "nehiragana",
  0x306d,
  "nekatakana",
  0x30cd,
  "nekatakanahalfwidth",
  0xff88,
  "newsheqelsign",
  0x20aa,
  "nfsquare",
  0x338b,
  "ngabengali",
  0x0999,
  "ngadeva",
  0x0919,
  "ngagujarati",
  0x0a99,
  "ngagurmukhi",
  0x0a19,
  "ngonguthai",
  0x0e07,
  "nhiragana",
  0x3093,
  "nhookleft",
  0x0272,
  "nhookretroflex",
  0x0273,
  "nieunacirclekorean",
  0x326f,
  "nieunaparenkorean",
  0x320f,
  "nieuncieuckorean",
  0x3135,
  "nieuncirclekorean",
  0x3261,
  "nieunhieuhkorean",
  0x3136,
  "nieunkorean",
  0x3134,
  "nieunpansioskorean",
  0x3168,
  "nieunparenkorean",
  0x3201,
  "nieunsioskorean",
  0x3167,
  "nieuntikeutkorean",
  0x3166,
  "nihiragana",
  0x306b,
  "nikatakana",
  0x30cb,
  "nikatakanahalfwidth",
  0xff86,
  "nikhahitleftthai",
  0xf899,
  "nikhahitthai",
  0x0e4d,
  "nine",
  0x0039,
  "ninearabic",
  0x0669,
  "ninebengali",
  0x09ef,
  "ninecircle",
  0x2468,
  "ninecircleinversesansserif",
  0x2792,
  "ninedeva",
  0x096f,
  "ninegujarati",
  0x0aef,
  "ninegurmukhi",
  0x0a6f,
  "ninehackarabic",
  0x0669,
  "ninehangzhou",
  0x3029,
  "nineideographicparen",
  0x3228,
  "nineinferior",
  0x2089,
  "ninemonospace",
  0xff19,
  "nineoldstyle",
  0xf739,
  "nineparen",
  0x247c,
  "nineperiod",
  0x2490,
  "ninepersian",
  0x06f9,
  "nineroman",
  0x2178,
  "ninesuperior",
  0x2079,
  "nineteencircle",
  0x2472,
  "nineteenparen",
  0x2486,
  "nineteenperiod",
  0x249a,
  "ninethai",
  0x0e59,
  "nj",
  0x01cc,
  "njecyrillic",
  0x045a,
  "nkatakana",
  0x30f3,
  "nkatakanahalfwidth",
  0xff9d,
  "nlegrightlong",
  0x019e,
  "nlinebelow",
  0x1e49,
  "nmonospace",
  0xff4e,
  "nmsquare",
  0x339a,
  "nnabengali",
  0x09a3,
  "nnadeva",
  0x0923,
  "nnagujarati",
  0x0aa3,
  "nnagurmukhi",
  0x0a23,
  "nnnadeva",
  0x0929,
  "nohiragana",
  0x306e,
  "nokatakana",
  0x30ce,
  "nokatakanahalfwidth",
  0xff89,
  "nonbreakingspace",
  0x00a0,
  "nonenthai",
  0x0e13,
  "nonuthai",
  0x0e19,
  "noonarabic",
  0x0646,
  "noonfinalarabic",
  0xfee6,
  "noonghunnaarabic",
  0x06ba,
  "noonghunnafinalarabic",
  0xfb9f,
  "nooninitialarabic",
  0xfee7,
  "noonjeeminitialarabic",
  0xfcd2,
  "noonjeemisolatedarabic",
  0xfc4b,
  "noonmedialarabic",
  0xfee8,
  "noonmeeminitialarabic",
  0xfcd5,
  "noonmeemisolatedarabic",
  0xfc4e,
  "noonnoonfinalarabic",
  0xfc8d,
  "notcontains",
  0x220c,
  "notelement",
  0x2209,
  "notelementof",
  0x2209,
  "notequal",
  0x2260,
  "notgreater",
  0x226f,
  "notgreaternorequal",
  0x2271,
  "notgreaternorless",
  0x2279,
  "notidentical",
  0x2262,
  "notless",
  0x226e,
  "notlessnorequal",
  0x2270,
  "notparallel",
  0x2226,
  "notprecedes",
  0x2280,
  "notsubset",
  0x2284,
  "notsucceeds",
  0x2281,
  "notsuperset",
  0x2285,
  "nowarmenian",
  0x0576,
  "nparen",
  0x24a9,
  "nssquare",
  0x33b1,
  "nsuperior",
  0x207f,
  "ntilde",
  0x00f1,
  "nu",
  0x03bd,
  "nuhiragana",
  0x306c,
  "nukatakana",
  0x30cc,
  "nukatakanahalfwidth",
  0xff87,
  "nuktabengali",
  0x09bc,
  "nuktadeva",
  0x093c,
  "nuktagujarati",
  0x0abc,
  "nuktagurmukhi",
  0x0a3c,
  "numbersign",
  0x0023,
  "numbersignmonospace",
  0xff03,
  "numbersignsmall",
  0xfe5f,
  "numeralsigngreek",
  0x0374,
  "numeralsignlowergreek",
  0x0375,
  "numero",
  0x2116,
  "nun",
  0x05e0,
  "nundagesh",
  0xfb40,
  "nundageshhebrew",
  0xfb40,
  "nunhebrew",
  0x05e0,
  "nvsquare",
  0x33b5,
  "nwsquare",
  0x33bb,
  "nyabengali",
  0x099e,
  "nyadeva",
  0x091e,
  "nyagujarati",
  0x0a9e,
  "nyagurmukhi",
  0x0a1e,
  "o",
  0x006f,
  "oacute",
  0x00f3,
  "oangthai",
  0x0e2d,
  "obarred",
  0x0275,
  "obarredcyrillic",
  0x04e9,
  "obarreddieresiscyrillic",
  0x04eb,
  "obengali",
  0x0993,
  "obopomofo",
  0x311b,
  "obreve",
  0x014f,
  "ocandradeva",
  0x0911,
  "ocandragujarati",
  0x0a91,
  "ocandravowelsigndeva",
  0x0949,
  "ocandravowelsigngujarati",
  0x0ac9,
  "ocaron",
  0x01d2,
  "ocircle",
  0x24de,
  "ocircumflex",
  0x00f4,
  "ocircumflexacute",
  0x1ed1,
  "ocircumflexdotbelow",
  0x1ed9,
  "ocircumflexgrave",
  0x1ed3,
  "ocircumflexhookabove",
  0x1ed5,
  "ocircumflextilde",
  0x1ed7,
  "ocyrillic",
  0x043e,
  "odblacute",
  0x0151,
  "odblgrave",
  0x020d,
  "odeva",
  0x0913,
  "odieresis",
  0x00f6,
  "odieresiscyrillic",
  0x04e7,
  "odotbelow",
  0x1ecd,
  "oe",
  0x0153,
  "oekorean",
  0x315a,
  "ogonek",
  0x02db,
  "ogonekcmb",
  0x0328,
  "ograve",
  0x00f2,
  "ogujarati",
  0x0a93,
  "oharmenian",
  0x0585,
  "ohiragana",
  0x304a,
  "ohookabove",
  0x1ecf,
  "ohorn",
  0x01a1,
  "ohornacute",
  0x1edb,
  "ohorndotbelow",
  0x1ee3,
  "ohorngrave",
  0x1edd,
  "ohornhookabove",
  0x1edf,
  "ohorntilde",
  0x1ee1,
  "ohungarumlaut",
  0x0151,
  "oi",
  0x01a3,
  "oinvertedbreve",
  0x020f,
  "okatakana",
  0x30aa,
  "okatakanahalfwidth",
  0xff75,
  "okorean",
  0x3157,
  "olehebrew",
  0x05ab,
  "omacron",
  0x014d,
  "omacronacute",
  0x1e53,
  "omacrongrave",
  0x1e51,
  "omdeva",
  0x0950,
  "omega",
  0x03c9,
  "omega1",
  0x03d6,
  "omegacyrillic",
  0x0461,
  "omegalatinclosed",
  0x0277,
  "omegaroundcyrillic",
  0x047b,
  "omegatitlocyrillic",
  0x047d,
  "omegatonos",
  0x03ce,
  "omgujarati",
  0x0ad0,
  "omicron",
  0x03bf,
  "omicrontonos",
  0x03cc,
  "omonospace",
  0xff4f,
  "one",
  0x0031,
  "onearabic",
  0x0661,
  "onebengali",
  0x09e7,
  "onecircle",
  0x2460,
  "onecircleinversesansserif",
  0x278a,
  "onedeva",
  0x0967,
  "onedotenleader",
  0x2024,
  "oneeighth",
  0x215b,
  "onefitted",
  0xf6dc,
  "onegujarati",
  0x0ae7,
  "onegurmukhi",
  0x0a67,
  "onehackarabic",
  0x0661,
  "onehalf",
  0x00bd,
  "onehangzhou",
  0x3021,
  "oneideographicparen",
  0x3220,
  "oneinferior",
  0x2081,
  "onemonospace",
  0xff11,
  "onenumeratorbengali",
  0x09f4,
  "oneoldstyle",
  0xf731,
  "oneparen",
  0x2474,
  "oneperiod",
  0x2488,
  "onepersian",
  0x06f1,
  "onequarter",
  0x00bc,
  "oneroman",
  0x2170,
  "onesuperior",
  0x00b9,
  "onethai",
  0x0e51,
  "onethird",
  0x2153,
  "oogonek",
  0x01eb,
  "oogonekmacron",
  0x01ed,
  "oogurmukhi",
  0x0a13,
  "oomatragurmukhi",
  0x0a4b,
  "oopen",
  0x0254,
  "oparen",
  0x24aa,
  "openbullet",
  0x25e6,
  "option",
  0x2325,
  "ordfeminine",
  0x00aa,
  "ordmasculine",
  0x00ba,
  "orthogonal",
  0x221f,
  "oshortdeva",
  0x0912,
  "oshortvowelsigndeva",
  0x094a,
  "oslash",
  0x00f8,
  "oslashacute",
  0x01ff,
  "osmallhiragana",
  0x3049,
  "osmallkatakana",
  0x30a9,
  "osmallkatakanahalfwidth",
  0xff6b,
  "ostrokeacute",
  0x01ff,
  "osuperior",
  0xf6f0,
  "otcyrillic",
  0x047f,
  "otilde",
  0x00f5,
  "otildeacute",
  0x1e4d,
  "otildedieresis",
  0x1e4f,
  "oubopomofo",
  0x3121,
  "overline",
  0x203e,
  "overlinecenterline",
  0xfe4a,
  "overlinecmb",
  0x0305,
  "overlinedashed",
  0xfe49,
  "overlinedblwavy",
  0xfe4c,
  "overlinewavy",
  0xfe4b,
  "overscore",
  0x00af,
  "ovowelsignbengali",
  0x09cb,
  "ovowelsigndeva",
  0x094b,
  "ovowelsigngujarati",
  0x0acb,
  "p",
  0x0070,
  "paampssquare",
  0x3380,
  "paasentosquare",
  0x332b,
  "pabengali",
  0x09aa,
  "pacute",
  0x1e55,
  "padeva",
  0x092a,
  "pagedown",
  0x21df,
  "pageup",
  0x21de,
  "pagujarati",
  0x0aaa,
  "pagurmukhi",
  0x0a2a,
  "pahiragana",
  0x3071,
  "paiyannoithai",
  0x0e2f,
  "pakatakana",
  0x30d1,
  "palatalizationcyrilliccmb",
  0x0484,
  "palochkacyrillic",
  0x04c0,
  "pansioskorean",
  0x317f,
  "paragraph",
  0x00b6,
  "parallel",
  0x2225,
  "parenleft",
  0x0028,
  "parenleftaltonearabic",
  0xfd3e,
  "parenleftbt",
  0xf8ed,
  "parenleftex",
  0xf8ec,
  "parenleftinferior",
  0x208d,
  "parenleftmonospace",
  0xff08,
  "parenleftsmall",
  0xfe59,
  "parenleftsuperior",
  0x207d,
  "parenlefttp",
  0xf8eb,
  "parenleftvertical",
  0xfe35,
  "parenright",
  0x0029,
  "parenrightaltonearabic",
  0xfd3f,
  "parenrightbt",
  0xf8f8,
  "parenrightex",
  0xf8f7,
  "parenrightinferior",
  0x208e,
  "parenrightmonospace",
  0xff09,
  "parenrightsmall",
  0xfe5a,
  "parenrightsuperior",
  0x207e,
  "parenrighttp",
  0xf8f6,
  "parenrightvertical",
  0xfe36,
  "partialdiff",
  0x2202,
  "paseqhebrew",
  0x05c0,
  "pashtahebrew",
  0x0599,
  "pasquare",
  0x33a9,
  "patah",
  0x05b7,
  "patah11",
  0x05b7,
  "patah1d",
  0x05b7,
  "patah2a",
  0x05b7,
  "patahhebrew",
  0x05b7,
  "patahnarrowhebrew",
  0x05b7,
  "patahquarterhebrew",
  0x05b7,
  "patahwidehebrew",
  0x05b7,
  "pazerhebrew",
  0x05a1,
  "pbopomofo",
  0x3106,
  "pcircle",
  0x24df,
  "pdotaccent",
  0x1e57,
  "pe",
  0x05e4,
  "pecyrillic",
  0x043f,
  "pedagesh",
  0xfb44,
  "pedageshhebrew",
  0xfb44,
  "peezisquare",
  0x333b,
  "pefinaldageshhebrew",
  0xfb43,
  "peharabic",
  0x067e,
  "peharmenian",
  0x057a,
  "pehebrew",
  0x05e4,
  "pehfinalarabic",
  0xfb57,
  "pehinitialarabic",
  0xfb58,
  "pehiragana",
  0x307a,
  "pehmedialarabic",
  0xfb59,
  "pekatakana",
  0x30da,
  "pemiddlehookcyrillic",
  0x04a7,
  "perafehebrew",
  0xfb4e,
  "percent",
  0x0025,
  "percentarabic",
  0x066a,
  "percentmonospace",
  0xff05,
  "percentsmall",
  0xfe6a,
  "period",
  0x002e,
  "periodarmenian",
  0x0589,
  "periodcentered",
  0x00b7,
  "periodhalfwidth",
  0xff61,
  "periodinferior",
  0xf6e7,
  "periodmonospace",
  0xff0e,
  "periodsmall",
  0xfe52,
  "periodsuperior",
  0xf6e8,
  "perispomenigreekcmb",
  0x0342,
  "perpendicular",
  0x22a5,
  "perthousand",
  0x2030,
  "peseta",
  0x20a7,
  "pfsquare",
  0x338a,
  "phabengali",
  0x09ab,
  "phadeva",
  0x092b,
  "phagujarati",
  0x0aab,
  "phagurmukhi",
  0x0a2b,
  "phi",
  0x03c6,
  "phi1",
  0x03d5,
  "phieuphacirclekorean",
  0x327a,
  "phieuphaparenkorean",
  0x321a,
  "phieuphcirclekorean",
  0x326c,
  "phieuphkorean",
  0x314d,
  "phieuphparenkorean",
  0x320c,
  "philatin",
  0x0278,
  "phinthuthai",
  0x0e3a,
  "phisymbolgreek",
  0x03d5,
  "phook",
  0x01a5,
  "phophanthai",
  0x0e1e,
  "phophungthai",
  0x0e1c,
  "phosamphaothai",
  0x0e20,
  "pi",
  0x03c0,
  "pieupacirclekorean",
  0x3273,
  "pieupaparenkorean",
  0x3213,
  "pieupcieuckorean",
  0x3176,
  "pieupcirclekorean",
  0x3265,
  "pieupkiyeokkorean",
  0x3172,
  "pieupkorean",
  0x3142,
  "pieupparenkorean",
  0x3205,
  "pieupsioskiyeokkorean",
  0x3174,
  "pieupsioskorean",
  0x3144,
  "pieupsiostikeutkorean",
  0x3175,
  "pieupthieuthkorean",
  0x3177,
  "pieuptikeutkorean",
  0x3173,
  "pihiragana",
  0x3074,
  "pikatakana",
  0x30d4,
  "pisymbolgreek",
  0x03d6,
  "piwrarmenian",
  0x0583,
  "plus",
  0x002b,
  "plusbelowcmb",
  0x031f,
  "pluscircle",
  0x2295,
  "plusminus",
  0x00b1,
  "plusmod",
  0x02d6,
  "plusmonospace",
  0xff0b,
  "plussmall",
  0xfe62,
  "plussuperior",
  0x207a,
  "pmonospace",
  0xff50,
  "pmsquare",
  0x33d8,
  "pohiragana",
  0x307d,
  "pointingindexdownwhite",
  0x261f,
  "pointingindexleftwhite",
  0x261c,
  "pointingindexrightwhite",
  0x261e,
  "pointingindexupwhite",
  0x261d,
  "pokatakana",
  0x30dd,
  "poplathai",
  0x0e1b,
  "postalmark",
  0x3012,
  "postalmarkface",
  0x3020,
  "pparen",
  0x24ab,
  "precedes",
  0x227a,
  "prescription",
  0x211e,
  "primemod",
  0x02b9,
  "primereversed",
  0x2035,
  "product",
  0x220f,
  "projective",
  0x2305,
  "prolongedkana",
  0x30fc,
  "propellor",
  0x2318,
  "propersubset",
  0x2282,
  "propersuperset",
  0x2283,
  "proportion",
  0x2237,
  "proportional",
  0x221d,
  "psi",
  0x03c8,
  "psicyrillic",
  0x0471,
  "psilipneumatacyrilliccmb",
  0x0486,
  "pssquare",
  0x33b0,
  "puhiragana",
  0x3077,
  "pukatakana",
  0x30d7,
  "pvsquare",
  0x33b4,
  "pwsquare",
  0x33ba,
  "q",
  0x0071,
  "qadeva",
  0x0958,
  "qadmahebrew",
  0x05a8,
  "qafarabic",
  0x0642,
  "qaffinalarabic",
  0xfed6,
  "qafinitialarabic",
  0xfed7,
  "qafmedialarabic",
  0xfed8,
  "qamats",
  0x05b8,
  "qamats10",
  0x05b8,
  "qamats1a",
  0x05b8,
  "qamats1c",
  0x05b8,
  "qamats27",
  0x05b8,
  "qamats29",
  0x05b8,
  "qamats33",
  0x05b8,
  "qamatsde",
  0x05b8,
  "qamatshebrew",
  0x05b8,
  "qamatsnarrowhebrew",
  0x05b8,
  "qamatsqatanhebrew",
  0x05b8,
  "qamatsqatannarrowhebrew",
  0x05b8,
  "qamatsqatanquarterhebrew",
  0x05b8,
  "qamatsqatanwidehebrew",
  0x05b8,
  "qamatsquarterhebrew",
  0x05b8,
  "qamatswidehebrew",
  0x05b8,
  "qarneyparahebrew",
  0x059f,
  "qbopomofo",
  0x3111,
  "qcircle",
  0x24e0,
  "qhook",
  0x02a0,
  "qmonospace",
  0xff51,
  "qof",
  0x05e7,
  "qofdagesh",
  0xfb47,
  "qofdageshhebrew",
  0xfb47,
  "qofhebrew",
  0x05e7,
  "qparen",
  0x24ac,
  "quarternote",
  0x2669,
  "qubuts",
  0x05bb,
  "qubuts18",
  0x05bb,
  "qubuts25",
  0x05bb,
  "qubuts31",
  0x05bb,
  "qubutshebrew",
  0x05bb,
  "qubutsnarrowhebrew",
  0x05bb,
  "qubutsquarterhebrew",
  0x05bb,
  "qubutswidehebrew",
  0x05bb,
  "question",
  0x003f,
  "questionarabic",
  0x061f,
  "questionarmenian",
  0x055e,
  "questiondown",
  0x00bf,
  "questiondownsmall",
  0xf7bf,
  "questiongreek",
  0x037e,
  "questionmonospace",
  0xff1f,
  "questionsmall",
  0xf73f,
  "quotedbl",
  0x0022,
  "quotedblbase",
  0x201e,
  "quotedblleft",
  0x201c,
  "quotedblmonospace",
  0xff02,
  "quotedblprime",
  0x301e,
  "quotedblprimereversed",
  0x301d,
  "quotedblright",
  0x201d,
  "quoteleft",
  0x2018,
  "quoteleftreversed",
  0x201b,
  "quotereversed",
  0x201b,
  "quoteright",
  0x2019,
  "quoterightn",
  0x0149,
  "quotesinglbase",
  0x201a,
  "quotesingle",
  0x0027,
  "quotesinglemonospace",
  0xff07,
  "r",
  0x0072,
  "raarmenian",
  0x057c,
  "rabengali",
  0x09b0,
  "racute",
  0x0155,
  "radeva",
  0x0930,
  "radical",
  0x221a,
  "radicalex",
  0xf8e5,
  "radoverssquare",
  0x33ae,
  "radoverssquaredsquare",
  0x33af,
  "radsquare",
  0x33ad,
  "rafe",
  0x05bf,
  "rafehebrew",
  0x05bf,
  "ragujarati",
  0x0ab0,
  "ragurmukhi",
  0x0a30,
  "rahiragana",
  0x3089,
  "rakatakana",
  0x30e9,
  "rakatakanahalfwidth",
  0xff97,
  "ralowerdiagonalbengali",
  0x09f1,
  "ramiddlediagonalbengali",
  0x09f0,
  "ramshorn",
  0x0264,
  "ratio",
  0x2236,
  "rbopomofo",
  0x3116,
  "rcaron",
  0x0159,
  "rcedilla",
  0x0157,
  "rcircle",
  0x24e1,
  "rcommaaccent",
  0x0157,
  "rdblgrave",
  0x0211,
  "rdotaccent",
  0x1e59,
  "rdotbelow",
  0x1e5b,
  "rdotbelowmacron",
  0x1e5d,
  "referencemark",
  0x203b,
  "reflexsubset",
  0x2286,
  "reflexsuperset",
  0x2287,
  "registered",
  0x00ae,
  "registersans",
  0xf8e8,
  "registerserif",
  0xf6da,
  "reharabic",
  0x0631,
  "reharmenian",
  0x0580,
  "rehfinalarabic",
  0xfeae,
  "rehiragana",
  0x308c,
  "rekatakana",
  0x30ec,
  "rekatakanahalfwidth",
  0xff9a,
  "resh",
  0x05e8,
  "reshdageshhebrew",
  0xfb48,
  "reshhebrew",
  0x05e8,
  "reversedtilde",
  0x223d,
  "reviahebrew",
  0x0597,
  "reviamugrashhebrew",
  0x0597,
  "revlogicalnot",
  0x2310,
  "rfishhook",
  0x027e,
  "rfishhookreversed",
  0x027f,
  "rhabengali",
  0x09dd,
  "rhadeva",
  0x095d,
  "rho",
  0x03c1,
  "rhook",
  0x027d,
  "rhookturned",
  0x027b,
  "rhookturnedsuperior",
  0x02b5,
  "rhosymbolgreek",
  0x03f1,
  "rhotichookmod",
  0x02de,
  "rieulacirclekorean",
  0x3271,
  "rieulaparenkorean",
  0x3211,
  "rieulcirclekorean",
  0x3263,
  "rieulhieuhkorean",
  0x3140,
  "rieulkiyeokkorean",
  0x313a,
  "rieulkiyeoksioskorean",
  0x3169,
  "rieulkorean",
  0x3139,
  "rieulmieumkorean",
  0x313b,
  "rieulpansioskorean",
  0x316c,
  "rieulparenkorean",
  0x3203,
  "rieulphieuphkorean",
  0x313f,
  "rieulpieupkorean",
  0x313c,
  "rieulpieupsioskorean",
  0x316b,
  "rieulsioskorean",
  0x313d,
  "rieulthieuthkorean",
  0x313e,
  "rieultikeutkorean",
  0x316a,
  "rieulyeorinhieuhkorean",
  0x316d,
  "rightangle",
  0x221f,
  "righttackbelowcmb",
  0x0319,
  "righttriangle",
  0x22bf,
  "rihiragana",
  0x308a,
  "rikatakana",
  0x30ea,
  "rikatakanahalfwidth",
  0xff98,
  "ring",
  0x02da,
  "ringbelowcmb",
  0x0325,
  "ringcmb",
  0x030a,
  "ringhalfleft",
  0x02bf,
  "ringhalfleftarmenian",
  0x0559,
  "ringhalfleftbelowcmb",
  0x031c,
  "ringhalfleftcentered",
  0x02d3,
  "ringhalfright",
  0x02be,
  "ringhalfrightbelowcmb",
  0x0339,
  "ringhalfrightcentered",
  0x02d2,
  "rinvertedbreve",
  0x0213,
  "rittorusquare",
  0x3351,
  "rlinebelow",
  0x1e5f,
  "rlongleg",
  0x027c,
  "rlonglegturned",
  0x027a,
  "rmonospace",
  0xff52,
  "rohiragana",
  0x308d,
  "rokatakana",
  0x30ed,
  "rokatakanahalfwidth",
  0xff9b,
  "roruathai",
  0x0e23,
  "rparen",
  0x24ad,
  "rrabengali",
  0x09dc,
  "rradeva",
  0x0931,
  "rragurmukhi",
  0x0a5c,
  "rreharabic",
  0x0691,
  "rrehfinalarabic",
  0xfb8d,
  "rrvocalicbengali",
  0x09e0,
  "rrvocalicdeva",
  0x0960,
  "rrvocalicgujarati",
  0x0ae0,
  "rrvocalicvowelsignbengali",
  0x09c4,
  "rrvocalicvowelsigndeva",
  0x0944,
  "rrvocalicvowelsigngujarati",
  0x0ac4,
  "rsuperior",
  0xf6f1,
  "rtblock",
  0x2590,
  "rturned",
  0x0279,
  "rturnedsuperior",
  0x02b4,
  "ruhiragana",
  0x308b,
  "rukatakana",
  0x30eb,
  "rukatakanahalfwidth",
  0xff99,
  "rupeemarkbengali",
  0x09f2,
  "rupeesignbengali",
  0x09f3,
  "rupiah",
  0xf6dd,
  "ruthai",
  0x0e24,
  "rvocalicbengali",
  0x098b,
  "rvocalicdeva",
  0x090b,
  "rvocalicgujarati",
  0x0a8b,
  "rvocalicvowelsignbengali",
  0x09c3,
  "rvocalicvowelsigndeva",
  0x0943,
  "rvocalicvowelsigngujarati",
  0x0ac3,
  "s",
  0x0073,
  "sabengali",
  0x09b8,
  "sacute",
  0x015b,
  "sacutedotaccent",
  0x1e65,
  "sadarabic",
  0x0635,
  "sadeva",
  0x0938,
  "sadfinalarabic",
  0xfeba,
  "sadinitialarabic",
  0xfebb,
  "sadmedialarabic",
  0xfebc,
  "sagujarati",
  0x0ab8,
  "sagurmukhi",
  0x0a38,
  "sahiragana",
  0x3055,
  "sakatakana",
  0x30b5,
  "sakatakanahalfwidth",
  0xff7b,
  "sallallahoualayhewasallamarabic",
  0xfdfa,
  "samekh",
  0x05e1,
  "samekhdagesh",
  0xfb41,
  "samekhdageshhebrew",
  0xfb41,
  "samekhhebrew",
  0x05e1,
  "saraaathai",
  0x0e32,
  "saraaethai",
  0x0e41,
  "saraaimaimalaithai",
  0x0e44,
  "saraaimaimuanthai",
  0x0e43,
  "saraamthai",
  0x0e33,
  "saraathai",
  0x0e30,
  "saraethai",
  0x0e40,
  "saraiileftthai",
  0xf886,
  "saraiithai",
  0x0e35,
  "saraileftthai",
  0xf885,
  "saraithai",
  0x0e34,
  "saraothai",
  0x0e42,
  "saraueeleftthai",
  0xf888,
  "saraueethai",
  0x0e37,
  "saraueleftthai",
  0xf887,
  "sarauethai",
  0x0e36,
  "sarauthai",
  0x0e38,
  "sarauuthai",
  0x0e39,
  "sbopomofo",
  0x3119,
  "scaron",
  0x0161,
  "scarondotaccent",
  0x1e67,
  "scedilla",
  0x015f,
  "schwa",
  0x0259,
  "schwacyrillic",
  0x04d9,
  "schwadieresiscyrillic",
  0x04db,
  "schwahook",
  0x025a,
  "scircle",
  0x24e2,
  "scircumflex",
  0x015d,
  "scommaaccent",
  0x0219,
  "sdotaccent",
  0x1e61,
  "sdotbelow",
  0x1e63,
  "sdotbelowdotaccent",
  0x1e69,
  "seagullbelowcmb",
  0x033c,
  "second",
  0x2033,
  "secondtonechinese",
  0x02ca,
  "section",
  0x00a7,
  "seenarabic",
  0x0633,
  "seenfinalarabic",
  0xfeb2,
  "seeninitialarabic",
  0xfeb3,
  "seenmedialarabic",
  0xfeb4,
  "segol",
  0x05b6,
  "segol13",
  0x05b6,
  "segol1f",
  0x05b6,
  "segol2c",
  0x05b6,
  "segolhebrew",
  0x05b6,
  "segolnarrowhebrew",
  0x05b6,
  "segolquarterhebrew",
  0x05b6,
  "segoltahebrew",
  0x0592,
  "segolwidehebrew",
  0x05b6,
  "seharmenian",
  0x057d,
  "sehiragana",
  0x305b,
  "sekatakana",
  0x30bb,
  "sekatakanahalfwidth",
  0xff7e,
  "semicolon",
  0x003b,
  "semicolonarabic",
  0x061b,
  "semicolonmonospace",
  0xff1b,
  "semicolonsmall",
  0xfe54,
  "semivoicedmarkkana",
  0x309c,
  "semivoicedmarkkanahalfwidth",
  0xff9f,
  "sentisquare",
  0x3322,
  "sentosquare",
  0x3323,
  "seven",
  0x0037,
  "sevenarabic",
  0x0667,
  "sevenbengali",
  0x09ed,
  "sevencircle",
  0x2466,
  "sevencircleinversesansserif",
  0x2790,
  "sevendeva",
  0x096d,
  "seveneighths",
  0x215e,
  "sevengujarati",
  0x0aed,
  "sevengurmukhi",
  0x0a6d,
  "sevenhackarabic",
  0x0667,
  "sevenhangzhou",
  0x3027,
  "sevenideographicparen",
  0x3226,
  "seveninferior",
  0x2087,
  "sevenmonospace",
  0xff17,
  "sevenoldstyle",
  0xf737,
  "sevenparen",
  0x247a,
  "sevenperiod",
  0x248e,
  "sevenpersian",
  0x06f7,
  "sevenroman",
  0x2176,
  "sevensuperior",
  0x2077,
  "seventeencircle",
  0x2470,
  "seventeenparen",
  0x2484,
  "seventeenperiod",
  0x2498,
  "seventhai",
  0x0e57,
  "sfthyphen",
  0x00ad,
  "shaarmenian",
  0x0577,
  "shabengali",
  0x09b6,
  "shacyrillic",
  0x0448,
  "shaddaarabic",
  0x0651,
  "shaddadammaarabic",
  0xfc61,
  "shaddadammatanarabic",
  0xfc5e,
  "shaddafathaarabic",
  0xfc60,
  "shaddakasraarabic",
  0xfc62,
  "shaddakasratanarabic",
  0xfc5f,
  "shade",
  0x2592,
  "shadedark",
  0x2593,
  "shadelight",
  0x2591,
  "shademedium",
  0x2592,
  "shadeva",
  0x0936,
  "shagujarati",
  0x0ab6,
  "shagurmukhi",
  0x0a36,
  "shalshelethebrew",
  0x0593,
  "shbopomofo",
  0x3115,
  "shchacyrillic",
  0x0449,
  "sheenarabic",
  0x0634,
  "sheenfinalarabic",
  0xfeb6,
  "sheeninitialarabic",
  0xfeb7,
  "sheenmedialarabic",
  0xfeb8,
  "sheicoptic",
  0x03e3,
  "sheqel",
  0x20aa,
  "sheqelhebrew",
  0x20aa,
  "sheva",
  0x05b0,
  "sheva115",
  0x05b0,
  "sheva15",
  0x05b0,
  "sheva22",
  0x05b0,
  "sheva2e",
  0x05b0,
  "shevahebrew",
  0x05b0,
  "shevanarrowhebrew",
  0x05b0,
  "shevaquarterhebrew",
  0x05b0,
  "shevawidehebrew",
  0x05b0,
  "shhacyrillic",
  0x04bb,
  "shimacoptic",
  0x03ed,
  "shin",
  0x05e9,
  "shindagesh",
  0xfb49,
  "shindageshhebrew",
  0xfb49,
  "shindageshshindot",
  0xfb2c,
  "shindageshshindothebrew",
  0xfb2c,
  "shindageshsindot",
  0xfb2d,
  "shindageshsindothebrew",
  0xfb2d,
  "shindothebrew",
  0x05c1,
  "shinhebrew",
  0x05e9,
  "shinshindot",
  0xfb2a,
  "shinshindothebrew",
  0xfb2a,
  "shinsindot",
  0xfb2b,
  "shinsindothebrew",
  0xfb2b,
  "shook",
  0x0282,
  "sigma",
  0x03c3,
  "sigma1",
  0x03c2,
  "sigmafinal",
  0x03c2,
  "sigmalunatesymbolgreek",
  0x03f2,
  "sihiragana",
  0x3057,
  "sikatakana",
  0x30b7,
  "sikatakanahalfwidth",
  0xff7c,
  "siluqhebrew",
  0x05bd,
  "siluqlefthebrew",
  0x05bd,
  "similar",
  0x223c,
  "sindothebrew",
  0x05c2,
  "siosacirclekorean",
  0x3274,
  "siosaparenkorean",
  0x3214,
  "sioscieuckorean",
  0x317e,
  "sioscirclekorean",
  0x3266,
  "sioskiyeokkorean",
  0x317a,
  "sioskorean",
  0x3145,
  "siosnieunkorean",
  0x317b,
  "siosparenkorean",
  0x3206,
  "siospieupkorean",
  0x317d,
  "siostikeutkorean",
  0x317c,
  "six",
  0x0036,
  "sixarabic",
  0x0666,
  "sixbengali",
  0x09ec,
  "sixcircle",
  0x2465,
  "sixcircleinversesansserif",
  0x278f,
  "sixdeva",
  0x096c,
  "sixgujarati",
  0x0aec,
  "sixgurmukhi",
  0x0a6c,
  "sixhackarabic",
  0x0666,
  "sixhangzhou",
  0x3026,
  "sixideographicparen",
  0x3225,
  "sixinferior",
  0x2086,
  "sixmonospace",
  0xff16,
  "sixoldstyle",
  0xf736,
  "sixparen",
  0x2479,
  "sixperiod",
  0x248d,
  "sixpersian",
  0x06f6,
  "sixroman",
  0x2175,
  "sixsuperior",
  0x2076,
  "sixteencircle",
  0x246f,
  "sixteencurrencydenominatorbengali",
  0x09f9,
  "sixteenparen",
  0x2483,
  "sixteenperiod",
  0x2497,
  "sixthai",
  0x0e56,
  "slash",
  0x002f,
  "slashmonospace",
  0xff0f,
  "slong",
  0x017f,
  "slongdotaccent",
  0x1e9b,
  "smileface",
  0x263a,
  "smonospace",
  0xff53,
  "sofpasuqhebrew",
  0x05c3,
  "softhyphen",
  0x00ad,
  "softsigncyrillic",
  0x044c,
  "sohiragana",
  0x305d,
  "sokatakana",
  0x30bd,
  "sokatakanahalfwidth",
  0xff7f,
  "soliduslongoverlaycmb",
  0x0338,
  "solidusshortoverlaycmb",
  0x0337,
  "sorusithai",
  0x0e29,
  "sosalathai",
  0x0e28,
  "sosothai",
  0x0e0b,
  "sosuathai",
  0x0e2a,
  "space",
  0x0020,
  "spacehackarabic",
  0x0020,
  "spade",
  0x2660,
  "spadesuitblack",
  0x2660,
  "spadesuitwhite",
  0x2664,
  "sparen",
  0x24ae,
  "squarebelowcmb",
  0x033b,
  "squarecc",
  0x33c4,
  "squarecm",
  0x339d,
  "squarediagonalcrosshatchfill",
  0x25a9,
  "squarehorizontalfill",
  0x25a4,
  "squarekg",
  0x338f,
  "squarekm",
  0x339e,
  "squarekmcapital",
  0x33ce,
  "squareln",
  0x33d1,
  "squarelog",
  0x33d2,
  "squaremg",
  0x338e,
  "squaremil",
  0x33d5,
  "squaremm",
  0x339c,
  "squaremsquared",
  0x33a1,
  "squareorthogonalcrosshatchfill",
  0x25a6,
  "squareupperlefttolowerrightfill",
  0x25a7,
  "squareupperrighttolowerleftfill",
  0x25a8,
  "squareverticalfill",
  0x25a5,
  "squarewhitewithsmallblack",
  0x25a3,
  "srsquare",
  0x33db,
  "ssabengali",
  0x09b7,
  "ssadeva",
  0x0937,
  "ssagujarati",
  0x0ab7,
  "ssangcieuckorean",
  0x3149,
  "ssanghieuhkorean",
  0x3185,
  "ssangieungkorean",
  0x3180,
  "ssangkiyeokkorean",
  0x3132,
  "ssangnieunkorean",
  0x3165,
  "ssangpieupkorean",
  0x3143,
  "ssangsioskorean",
  0x3146,
  "ssangtikeutkorean",
  0x3138,
  "ssuperior",
  0xf6f2,
  "sterling",
  0x00a3,
  "sterlingmonospace",
  0xffe1,
  "strokelongoverlaycmb",
  0x0336,
  "strokeshortoverlaycmb",
  0x0335,
  "subset",
  0x2282,
  "subsetnotequal",
  0x228a,
  "subsetorequal",
  0x2286,
  "succeeds",
  0x227b,
  "suchthat",
  0x220b,
  "suhiragana",
  0x3059,
  "sukatakana",
  0x30b9,
  "sukatakanahalfwidth",
  0xff7d,
  "sukunarabic",
  0x0652,
  "summation",
  0x2211,
  "sun",
  0x263c,
  "superset",
  0x2283,
  "supersetnotequal",
  0x228b,
  "supersetorequal",
  0x2287,
  "svsquare",
  0x33dc,
  "syouwaerasquare",
  0x337c,
  "t",
  0x0074,
  "tabengali",
  0x09a4,
  "tackdown",
  0x22a4,
  "tackleft",
  0x22a3,
  "tadeva",
  0x0924,
  "tagujarati",
  0x0aa4,
  "tagurmukhi",
  0x0a24,
  "taharabic",
  0x0637,
  "tahfinalarabic",
  0xfec2,
  "tahinitialarabic",
  0xfec3,
  "tahiragana",
  0x305f,
  "tahmedialarabic",
  0xfec4,
  "taisyouerasquare",
  0x337d,
  "takatakana",
  0x30bf,
  "takatakanahalfwidth",
  0xff80,
  "tatweelarabic",
  0x0640,
  "tau",
  0x03c4,
  "tav",
  0x05ea,
  "tavdages",
  0xfb4a,
  "tavdagesh",
  0xfb4a,
  "tavdageshhebrew",
  0xfb4a,
  "tavhebrew",
  0x05ea,
  "tbar",
  0x0167,
  "tbopomofo",
  0x310a,
  "tcaron",
  0x0165,
  "tccurl",
  0x02a8,
  "tcedilla",
  0x0163,
  "tcheharabic",
  0x0686,
  "tchehfinalarabic",
  0xfb7b,
  "tchehinitialarabic",
  0xfb7c,
  "tchehmedialarabic",
  0xfb7d,
  "tcircle",
  0x24e3,
  "tcircumflexbelow",
  0x1e71,
  "tcommaaccent",
  0x0163,
  "tdieresis",
  0x1e97,
  "tdotaccent",
  0x1e6b,
  "tdotbelow",
  0x1e6d,
  "tecyrillic",
  0x0442,
  "tedescendercyrillic",
  0x04ad,
  "teharabic",
  0x062a,
  "tehfinalarabic",
  0xfe96,
  "tehhahinitialarabic",
  0xfca2,
  "tehhahisolatedarabic",
  0xfc0c,
  "tehinitialarabic",
  0xfe97,
  "tehiragana",
  0x3066,
  "tehjeeminitialarabic",
  0xfca1,
  "tehjeemisolatedarabic",
  0xfc0b,
  "tehmarbutaarabic",
  0x0629,
  "tehmarbutafinalarabic",
  0xfe94,
  "tehmedialarabic",
  0xfe98,
  "tehmeeminitialarabic",
  0xfca4,
  "tehmeemisolatedarabic",
  0xfc0e,
  "tehnoonfinalarabic",
  0xfc73,
  "tekatakana",
  0x30c6,
  "tekatakanahalfwidth",
  0xff83,
  "telephone",
  0x2121,
  "telephoneblack",
  0x260e,
  "telishagedolahebrew",
  0x05a0,
  "telishaqetanahebrew",
  0x05a9,
  "tencircle",
  0x2469,
  "tenideographicparen",
  0x3229,
  "tenparen",
  0x247d,
  "tenperiod",
  0x2491,
  "tenroman",
  0x2179,
  "tesh",
  0x02a7,
  "tet",
  0x05d8,
  "tetdagesh",
  0xfb38,
  "tetdageshhebrew",
  0xfb38,
  "tethebrew",
  0x05d8,
  "tetsecyrillic",
  0x04b5,
  "tevirhebrew",
  0x059b,
  "tevirlefthebrew",
  0x059b,
  "thabengali",
  0x09a5,
  "thadeva",
  0x0925,
  "thagujarati",
  0x0aa5,
  "thagurmukhi",
  0x0a25,
  "thalarabic",
  0x0630,
  "thalfinalarabic",
  0xfeac,
  "thanthakhatlowleftthai",
  0xf898,
  "thanthakhatlowrightthai",
  0xf897,
  "thanthakhatthai",
  0x0e4c,
  "thanthakhatupperleftthai",
  0xf896,
  "theharabic",
  0x062b,
  "thehfinalarabic",
  0xfe9a,
  "thehinitialarabic",
  0xfe9b,
  "thehmedialarabic",
  0xfe9c,
  "thereexists",
  0x2203,
  "therefore",
  0x2234,
  "theta",
  0x03b8,
  "theta1",
  0x03d1,
  "thetasymbolgreek",
  0x03d1,
  "thieuthacirclekorean",
  0x3279,
  "thieuthaparenkorean",
  0x3219,
  "thieuthcirclekorean",
  0x326b,
  "thieuthkorean",
  0x314c,
  "thieuthparenkorean",
  0x320b,
  "thirteencircle",
  0x246c,
  "thirteenparen",
  0x2480,
  "thirteenperiod",
  0x2494,
  "thonangmonthothai",
  0x0e11,
  "thook",
  0x01ad,
  "thophuthaothai",
  0x0e12,
  "thorn",
  0x00fe,
  "thothahanthai",
  0x0e17,
  "thothanthai",
  0x0e10,
  "thothongthai",
  0x0e18,
  "thothungthai",
  0x0e16,
  "thousandcyrillic",
  0x0482,
  "thousandsseparatorarabic",
  0x066c,
  "thousandsseparatorpersian",
  0x066c,
  "three",
  0x0033,
  "threearabic",
  0x0663,
  "threebengali",
  0x09e9,
  "threecircle",
  0x2462,
  "threecircleinversesansserif",
  0x278c,
  "threedeva",
  0x0969,
  "threeeighths",
  0x215c,
  "threegujarati",
  0x0ae9,
  "threegurmukhi",
  0x0a69,
  "threehackarabic",
  0x0663,
  "threehangzhou",
  0x3023,
  "threeideographicparen",
  0x3222,
  "threeinferior",
  0x2083,
  "threemonospace",
  0xff13,
  "threenumeratorbengali",
  0x09f6,
  "threeoldstyle",
  0xf733,
  "threeparen",
  0x2476,
  "threeperiod",
  0x248a,
  "threepersian",
  0x06f3,
  "threequarters",
  0x00be,
  "threequartersemdash",
  0xf6de,
  "threeroman",
  0x2172,
  "threesuperior",
  0x00b3,
  "threethai",
  0x0e53,
  "thzsquare",
  0x3394,
  "tihiragana",
  0x3061,
  "tikatakana",
  0x30c1,
  "tikatakanahalfwidth",
  0xff81,
  "tikeutacirclekorean",
  0x3270,
  "tikeutaparenkorean",
  0x3210,
  "tikeutcirclekorean",
  0x3262,
  "tikeutkorean",
  0x3137,
  "tikeutparenkorean",
  0x3202,
  "tilde",
  0x02dc,
  "tildebelowcmb",
  0x0330,
  "tildecmb",
  0x0303,
  "tildecomb",
  0x0303,
  "tildedoublecmb",
  0x0360,
  "tildeoperator",
  0x223c,
  "tildeoverlaycmb",
  0x0334,
  "tildeverticalcmb",
  0x033e,
  "timescircle",
  0x2297,
  "tipehahebrew",
  0x0596,
  "tipehalefthebrew",
  0x0596,
  "tippigurmukhi",
  0x0a70,
  "titlocyrilliccmb",
  0x0483,
  "tiwnarmenian",
  0x057f,
  "tlinebelow",
  0x1e6f,
  "tmonospace",
  0xff54,
  "toarmenian",
  0x0569,
  "tohiragana",
  0x3068,
  "tokatakana",
  0x30c8,
  "tokatakanahalfwidth",
  0xff84,
  "tonebarextrahighmod",
  0x02e5,
  "tonebarextralowmod",
  0x02e9,
  "tonebarhighmod",
  0x02e6,
  "tonebarlowmod",
  0x02e8,
  "tonebarmidmod",
  0x02e7,
  "tonefive",
  0x01bd,
  "tonesix",
  0x0185,
  "tonetwo",
  0x01a8,
  "tonos",
  0x0384,
  "tonsquare",
  0x3327,
  "topatakthai",
  0x0e0f,
  "tortoiseshellbracketleft",
  0x3014,
  "tortoiseshellbracketleftsmall",
  0xfe5d,
  "tortoiseshellbracketleftvertical",
  0xfe39,
  "tortoiseshellbracketright",
  0x3015,
  "tortoiseshellbracketrightsmall",
  0xfe5e,
  "tortoiseshellbracketrightvertical",
  0xfe3a,
  "totaothai",
  0x0e15,
  "tpalatalhook",
  0x01ab,
  "tparen",
  0x24af,
  "trademark",
  0x2122,
  "trademarksans",
  0xf8ea,
  "trademarkserif",
  0xf6db,
  "tretroflexhook",
  0x0288,
  "triagdn",
  0x25bc,
  "triaglf",
  0x25c4,
  "triagrt",
  0x25ba,
  "triagup",
  0x25b2,
  "ts",
  0x02a6,
  "tsadi",
  0x05e6,
  "tsadidagesh",
  0xfb46,
  "tsadidageshhebrew",
  0xfb46,
  "tsadihebrew",
  0x05e6,
  "tsecyrillic",
  0x0446,
  "tsere",
  0x05b5,
  "tsere12",
  0x05b5,
  "tsere1e",
  0x05b5,
  "tsere2b",
  0x05b5,
  "tserehebrew",
  0x05b5,
  "tserenarrowhebrew",
  0x05b5,
  "tserequarterhebrew",
  0x05b5,
  "tserewidehebrew",
  0x05b5,
  "tshecyrillic",
  0x045b,
  "tsuperior",
  0xf6f3,
  "ttabengali",
  0x099f,
  "ttadeva",
  0x091f,
  "ttagujarati",
  0x0a9f,
  "ttagurmukhi",
  0x0a1f,
  "tteharabic",
  0x0679,
  "ttehfinalarabic",
  0xfb67,
  "ttehinitialarabic",
  0xfb68,
  "ttehmedialarabic",
  0xfb69,
  "tthabengali",
  0x09a0,
  "tthadeva",
  0x0920,
  "tthagujarati",
  0x0aa0,
  "tthagurmukhi",
  0x0a20,
  "tturned",
  0x0287,
  "tuhiragana",
  0x3064,
  "tukatakana",
  0x30c4,
  "tukatakanahalfwidth",
  0xff82,
  "tusmallhiragana",
  0x3063,
  "tusmallkatakana",
  0x30c3,
  "tusmallkatakanahalfwidth",
  0xff6f,
  "twelvecircle",
  0x246b,
  "twelveparen",
  0x247f,
  "twelveperiod",
  0x2493,
  "twelveroman",
  0x217b,
  "twentycircle",
  0x2473,
  "twentyhangzhou",
  0x5344,
  "twentyparen",
  0x2487,
  "twentyperiod",
  0x249b,
  "two",
  0x0032,
  "twoarabic",
  0x0662,
  "twobengali",
  0x09e8,
  "twocircle",
  0x2461,
  "twocircleinversesansserif",
  0x278b,
  "twodeva",
  0x0968,
  "twodotenleader",
  0x2025,
  "twodotleader",
  0x2025,
  "twodotleadervertical",
  0xfe30,
  "twogujarati",
  0x0ae8,
  "twogurmukhi",
  0x0a68,
  "twohackarabic",
  0x0662,
  "twohangzhou",
  0x3022,
  "twoideographicparen",
  0x3221,
  "twoinferior",
  0x2082,
  "twomonospace",
  0xff12,
  "twonumeratorbengali",
  0x09f5,
  "twooldstyle",
  0xf732,
  "twoparen",
  0x2475,
  "twoperiod",
  0x2489,
  "twopersian",
  0x06f2,
  "tworoman",
  0x2171,
  "twostroke",
  0x01bb,
  "twosuperior",
  0x00b2,
  "twothai",
  0x0e52,
  "twothirds",
  0x2154,
  "u",
  0x0075,
  "uacute",
  0x00fa,
  "ubar",
  0x0289,
  "ubengali",
  0x0989,
  "ubopomofo",
  0x3128,
  "ubreve",
  0x016d,
  "ucaron",
  0x01d4,
  "ucircle",
  0x24e4,
  "ucircumflex",
  0x00fb,
  "ucircumflexbelow",
  0x1e77,
  "ucyrillic",
  0x0443,
  "udattadeva",
  0x0951,
  "udblacute",
  0x0171,
  "udblgrave",
  0x0215,
  "udeva",
  0x0909,
  "udieresis",
  0x00fc,
  "udieresisacute",
  0x01d8,
  "udieresisbelow",
  0x1e73,
  "udieresiscaron",
  0x01da,
  "udieresiscyrillic",
  0x04f1,
  "udieresisgrave",
  0x01dc,
  "udieresismacron",
  0x01d6,
  "udotbelow",
  0x1ee5,
  "ugrave",
  0x00f9,
  "ugujarati",
  0x0a89,
  "ugurmukhi",
  0x0a09,
  "uhiragana",
  0x3046,
  "uhookabove",
  0x1ee7,
  "uhorn",
  0x01b0,
  "uhornacute",
  0x1ee9,
  "uhorndotbelow",
  0x1ef1,
  "uhorngrave",
  0x1eeb,
  "uhornhookabove",
  0x1eed,
  "uhorntilde",
  0x1eef,
  "uhungarumlaut",
  0x0171,
  "uhungarumlautcyrillic",
  0x04f3,
  "uinvertedbreve",
  0x0217,
  "ukatakana",
  0x30a6,
  "ukatakanahalfwidth",
  0xff73,
  "ukcyrillic",
  0x0479,
  "ukorean",
  0x315c,
  "umacron",
  0x016b,
  "umacroncyrillic",
  0x04ef,
  "umacrondieresis",
  0x1e7b,
  "umatragurmukhi",
  0x0a41,
  "umonospace",
  0xff55,
  "underscore",
  0x005f,
  "underscoredbl",
  0x2017,
  "underscoremonospace",
  0xff3f,
  "underscorevertical",
  0xfe33,
  "underscorewavy",
  0xfe4f,
  "union",
  0x222a,
  "universal",
  0x2200,
  "uogonek",
  0x0173,
  "uparen",
  0x24b0,
  "upblock",
  0x2580,
  "upperdothebrew",
  0x05c4,
  "upsilon",
  0x03c5,
  "upsilondieresis",
  0x03cb,
  "upsilondieresistonos",
  0x03b0,
  "upsilonlatin",
  0x028a,
  "upsilontonos",
  0x03cd,
  "uptackbelowcmb",
  0x031d,
  "uptackmod",
  0x02d4,
  "uragurmukhi",
  0x0a73,
  "uring",
  0x016f,
  "ushortcyrillic",
  0x045e,
  "usmallhiragana",
  0x3045,
  "usmallkatakana",
  0x30a5,
  "usmallkatakanahalfwidth",
  0xff69,
  "ustraightcyrillic",
  0x04af,
  "ustraightstrokecyrillic",
  0x04b1,
  "utilde",
  0x0169,
  "utildeacute",
  0x1e79,
  "utildebelow",
  0x1e75,
  "uubengali",
  0x098a,
  "uudeva",
  0x090a,
  "uugujarati",
  0x0a8a,
  "uugurmukhi",
  0x0a0a,
  "uumatragurmukhi",
  0x0a42,
  "uuvowelsignbengali",
  0x09c2,
  "uuvowelsigndeva",
  0x0942,
  "uuvowelsigngujarati",
  0x0ac2,
  "uvowelsignbengali",
  0x09c1,
  "uvowelsigndeva",
  0x0941,
  "uvowelsigngujarati",
  0x0ac1,
  "v",
  0x0076,
  "vadeva",
  0x0935,
  "vagujarati",
  0x0ab5,
  "vagurmukhi",
  0x0a35,
  "vakatakana",
  0x30f7,
  "vav",
  0x05d5,
  "vavdagesh",
  0xfb35,
  "vavdagesh65",
  0xfb35,
  "vavdageshhebrew",
  0xfb35,
  "vavhebrew",
  0x05d5,
  "vavholam",
  0xfb4b,
  "vavholamhebrew",
  0xfb4b,
  "vavvavhebrew",
  0x05f0,
  "vavyodhebrew",
  0x05f1,
  "vcircle",
  0x24e5,
  "vdotbelow",
  0x1e7f,
  "vecyrillic",
  0x0432,
  "veharabic",
  0x06a4,
  "vehfinalarabic",
  0xfb6b,
  "vehinitialarabic",
  0xfb6c,
  "vehmedialarabic",
  0xfb6d,
  "vekatakana",
  0x30f9,
  "venus",
  0x2640,
  "verticalbar",
  0x007c,
  "verticallineabovecmb",
  0x030d,
  "verticallinebelowcmb",
  0x0329,
  "verticallinelowmod",
  0x02cc,
  "verticallinemod",
  0x02c8,
  "vewarmenian",
  0x057e,
  "vhook",
  0x028b,
  "vikatakana",
  0x30f8,
  "viramabengali",
  0x09cd,
  "viramadeva",
  0x094d,
  "viramagujarati",
  0x0acd,
  "visargabengali",
  0x0983,
  "visargadeva",
  0x0903,
  "visargagujarati",
  0x0a83,
  "vmonospace",
  0xff56,
  "voarmenian",
  0x0578,
  "voicediterationhiragana",
  0x309e,
  "voicediterationkatakana",
  0x30fe,
  "voicedmarkkana",
  0x309b,
  "voicedmarkkanahalfwidth",
  0xff9e,
  "vokatakana",
  0x30fa,
  "vparen",
  0x24b1,
  "vtilde",
  0x1e7d,
  "vturned",
  0x028c,
  "vuhiragana",
  0x3094,
  "vukatakana",
  0x30f4,
  "w",
  0x0077,
  "wacute",
  0x1e83,
  "waekorean",
  0x3159,
  "wahiragana",
  0x308f,
  "wakatakana",
  0x30ef,
  "wakatakanahalfwidth",
  0xff9c,
  "wakorean",
  0x3158,
  "wasmallhiragana",
  0x308e,
  "wasmallkatakana",
  0x30ee,
  "wattosquare",
  0x3357,
  "wavedash",
  0x301c,
  "wavyunderscorevertical",
  0xfe34,
  "wawarabic",
  0x0648,
  "wawfinalarabic",
  0xfeee,
  "wawhamzaabovearabic",
  0x0624,
  "wawhamzaabovefinalarabic",
  0xfe86,
  "wbsquare",
  0x33dd,
  "wcircle",
  0x24e6,
  "wcircumflex",
  0x0175,
  "wdieresis",
  0x1e85,
  "wdotaccent",
  0x1e87,
  "wdotbelow",
  0x1e89,
  "wehiragana",
  0x3091,
  "weierstrass",
  0x2118,
  "wekatakana",
  0x30f1,
  "wekorean",
  0x315e,
  "weokorean",
  0x315d,
  "wgrave",
  0x1e81,
  "whitebullet",
  0x25e6,
  "whitecircle",
  0x25cb,
  "whitecircleinverse",
  0x25d9,
  "whitecornerbracketleft",
  0x300e,
  "whitecornerbracketleftvertical",
  0xfe43,
  "whitecornerbracketright",
  0x300f,
  "whitecornerbracketrightvertical",
  0xfe44,
  "whitediamond",
  0x25c7,
  "whitediamondcontainingblacksmalldiamond",
  0x25c8,
  "whitedownpointingsmalltriangle",
  0x25bf,
  "whitedownpointingtriangle",
  0x25bd,
  "whiteleftpointingsmalltriangle",
  0x25c3,
  "whiteleftpointingtriangle",
  0x25c1,
  "whitelenticularbracketleft",
  0x3016,
  "whitelenticularbracketright",
  0x3017,
  "whiterightpointingsmalltriangle",
  0x25b9,
  "whiterightpointingtriangle",
  0x25b7,
  "whitesmallsquare",
  0x25ab,
  "whitesmilingface",
  0x263a,
  "whitesquare",
  0x25a1,
  "whitestar",
  0x2606,
  "whitetelephone",
  0x260f,
  "whitetortoiseshellbracketleft",
  0x3018,
  "whitetortoiseshellbracketright",
  0x3019,
  "whiteuppointingsmalltriangle",
  0x25b5,
  "whiteuppointingtriangle",
  0x25b3,
  "wihiragana",
  0x3090,
  "wikatakana",
  0x30f0,
  "wikorean",
  0x315f,
  "wmonospace",
  0xff57,
  "wohiragana",
  0x3092,
  "wokatakana",
  0x30f2,
  "wokatakanahalfwidth",
  0xff66,
  "won",
  0x20a9,
  "wonmonospace",
  0xffe6,
  "wowaenthai",
  0x0e27,
  "wparen",
  0x24b2,
  "wring",
  0x1e98,
  "wsuperior",
  0x02b7,
  "wturned",
  0x028d,
  "wynn",
  0x01bf,
  "x",
  0x0078,
  "xabovecmb",
  0x033d,
  "xbopomofo",
  0x3112,
  "xcircle",
  0x24e7,
  "xdieresis",
  0x1e8d,
  "xdotaccent",
  0x1e8b,
  "xeharmenian",
  0x056d,
  "xi",
  0x03be,
  "xmonospace",
  0xff58,
  "xparen",
  0x24b3,
  "xsuperior",
  0x02e3,
  "y",
  0x0079,
  "yaadosquare",
  0x334e,
  "yabengali",
  0x09af,
  "yacute",
  0x00fd,
  "yadeva",
  0x092f,
  "yaekorean",
  0x3152,
  "yagujarati",
  0x0aaf,
  "yagurmukhi",
  0x0a2f,
  "yahiragana",
  0x3084,
  "yakatakana",
  0x30e4,
  "yakatakanahalfwidth",
  0xff94,
  "yakorean",
  0x3151,
  "yamakkanthai",
  0x0e4e,
  "yasmallhiragana",
  0x3083,
  "yasmallkatakana",
  0x30e3,
  "yasmallkatakanahalfwidth",
  0xff6c,
  "yatcyrillic",
  0x0463,
  "ycircle",
  0x24e8,
  "ycircumflex",
  0x0177,
  "ydieresis",
  0x00ff,
  "ydotaccent",
  0x1e8f,
  "ydotbelow",
  0x1ef5,
  "yeharabic",
  0x064a,
  "yehbarreearabic",
  0x06d2,
  "yehbarreefinalarabic",
  0xfbaf,
  "yehfinalarabic",
  0xfef2,
  "yehhamzaabovearabic",
  0x0626,
  "yehhamzaabovefinalarabic",
  0xfe8a,
  "yehhamzaaboveinitialarabic",
  0xfe8b,
  "yehhamzaabovemedialarabic",
  0xfe8c,
  "yehinitialarabic",
  0xfef3,
  "yehmedialarabic",
  0xfef4,
  "yehmeeminitialarabic",
  0xfcdd,
  "yehmeemisolatedarabic",
  0xfc58,
  "yehnoonfinalarabic",
  0xfc94,
  "yehthreedotsbelowarabic",
  0x06d1,
  "yekorean",
  0x3156,
  "yen",
  0x00a5,
  "yenmonospace",
  0xffe5,
  "yeokorean",
  0x3155,
  "yeorinhieuhkorean",
  0x3186,
  "yerahbenyomohebrew",
  0x05aa,
  "yerahbenyomolefthebrew",
  0x05aa,
  "yericyrillic",
  0x044b,
  "yerudieresiscyrillic",
  0x04f9,
  "yesieungkorean",
  0x3181,
  "yesieungpansioskorean",
  0x3183,
  "yesieungsioskorean",
  0x3182,
  "yetivhebrew",
  0x059a,
  "ygrave",
  0x1ef3,
  "yhook",
  0x01b4,
  "yhookabove",
  0x1ef7,
  "yiarmenian",
  0x0575,
  "yicyrillic",
  0x0457,
  "yikorean",
  0x3162,
  "yinyang",
  0x262f,
  "yiwnarmenian",
  0x0582,
  "ymonospace",
  0xff59,
  "yod",
  0x05d9,
  "yoddagesh",
  0xfb39,
  "yoddageshhebrew",
  0xfb39,
  "yodhebrew",
  0x05d9,
  "yodyodhebrew",
  0x05f2,
  "yodyodpatahhebrew",
  0xfb1f,
  "yohiragana",
  0x3088,
  "yoikorean",
  0x3189,
  "yokatakana",
  0x30e8,
  "yokatakanahalfwidth",
  0xff96,
  "yokorean",
  0x315b,
  "yosmallhiragana",
  0x3087,
  "yosmallkatakana",
  0x30e7,
  "yosmallkatakanahalfwidth",
  0xff6e,
  "yotgreek",
  0x03f3,
  "yoyaekorean",
  0x3188,
  "yoyakorean",
  0x3187,
  "yoyakthai",
  0x0e22,
  "yoyingthai",
  0x0e0d,
  "yparen",
  0x24b4,
  "ypogegrammeni",
  0x037a,
  "ypogegrammenigreekcmb",
  0x0345,
  "yr",
  0x01a6,
  "yring",
  0x1e99,
  "ysuperior",
  0x02b8,
  "ytilde",
  0x1ef9,
  "yturned",
  0x028e,
  "yuhiragana",
  0x3086,
  "yuikorean",
  0x318c,
  "yukatakana",
  0x30e6,
  "yukatakanahalfwidth",
  0xff95,
  "yukorean",
  0x3160,
  "yusbigcyrillic",
  0x046b,
  "yusbigiotifiedcyrillic",
  0x046d,
  "yuslittlecyrillic",
  0x0467,
  "yuslittleiotifiedcyrillic",
  0x0469,
  "yusmallhiragana",
  0x3085,
  "yusmallkatakana",
  0x30e5,
  "yusmallkatakanahalfwidth",
  0xff6d,
  "yuyekorean",
  0x318b,
  "yuyeokorean",
  0x318a,
  "yyabengali",
  0x09df,
  "yyadeva",
  0x095f,
  "z",
  0x007a,
  "zaarmenian",
  0x0566,
  "zacute",
  0x017a,
  "zadeva",
  0x095b,
  "zagurmukhi",
  0x0a5b,
  "zaharabic",
  0x0638,
  "zahfinalarabic",
  0xfec6,
  "zahinitialarabic",
  0xfec7,
  "zahiragana",
  0x3056,
  "zahmedialarabic",
  0xfec8,
  "zainarabic",
  0x0632,
  "zainfinalarabic",
  0xfeb0,
  "zakatakana",
  0x30b6,
  "zaqefgadolhebrew",
  0x0595,
  "zaqefqatanhebrew",
  0x0594,
  "zarqahebrew",
  0x0598,
  "zayin",
  0x05d6,
  "zayindagesh",
  0xfb36,
  "zayindageshhebrew",
  0xfb36,
  "zayinhebrew",
  0x05d6,
  "zbopomofo",
  0x3117,
  "zcaron",
  0x017e,
  "zcircle",
  0x24e9,
  "zcircumflex",
  0x1e91,
  "zcurl",
  0x0291,
  "zdot",
  0x017c,
  "zdotaccent",
  0x017c,
  "zdotbelow",
  0x1e93,
  "zecyrillic",
  0x0437,
  "zedescendercyrillic",
  0x0499,
  "zedieresiscyrillic",
  0x04df,
  "zehiragana",
  0x305c,
  "zekatakana",
  0x30bc,
  "zero",
  0x0030,
  "zeroarabic",
  0x0660,
  "zerobengali",
  0x09e6,
  "zerodeva",
  0x0966,
  "zerogujarati",
  0x0ae6,
  "zerogurmukhi",
  0x0a66,
  "zerohackarabic",
  0x0660,
  "zeroinferior",
  0x2080,
  "zeromonospace",
  0xff10,
  "zerooldstyle",
  0xf730,
  "zeropersian",
  0x06f0,
  "zerosuperior",
  0x2070,
  "zerothai",
  0x0e50,
  "zerowidthjoiner",
  0xfeff,
  "zerowidthnonjoiner",
  0x200c,
  "zerowidthspace",
  0x200b,
  "zeta",
  0x03b6,
  "zhbopomofo",
  0x3113,
  "zhearmenian",
  0x056a,
  "zhebrevecyrillic",
  0x04c2,
  "zhecyrillic",
  0x0436,
  "zhedescendercyrillic",
  0x0497,
  "zhedieresiscyrillic",
  0x04dd,
  "zihiragana",
  0x3058,
  "zikatakana",
  0x30b8,
  "zinorhebrew",
  0x05ae,
  "zlinebelow",
  0x1e95,
  "zmonospace",
  0xff5a,
  "zohiragana",
  0x305e,
  "zokatakana",
  0x30be,
  "zparen",
  0x24b5,
  "zretroflexhook",
  0x0290,
  "zstroke",
  0x01b6,
  "zuhiragana",
  0x305a,
  "zukatakana",
  0x30ba,
  ".notdef",
  0x0000,
  "angbracketleftbig",
  0x2329,
  "angbracketleftBig",
  0x2329,
  "angbracketleftbigg",
  0x2329,
  "angbracketleftBigg",
  0x2329,
  "angbracketrightBig",
  0x232a,
  "angbracketrightbig",
  0x232a,
  "angbracketrightBigg",
  0x232a,
  "angbracketrightbigg",
  0x232a,
  "arrowhookleft",
  0x21aa,
  "arrowhookright",
  0x21a9,
  "arrowlefttophalf",
  0x21bc,
  "arrowleftbothalf",
  0x21bd,
  "arrownortheast",
  0x2197,
  "arrownorthwest",
  0x2196,
  "arrowrighttophalf",
  0x21c0,
  "arrowrightbothalf",
  0x21c1,
  "arrowsoutheast",
  0x2198,
  "arrowsouthwest",
  0x2199,
  "backslashbig",
  0x2216,
  "backslashBig",
  0x2216,
  "backslashBigg",
  0x2216,
  "backslashbigg",
  0x2216,
  "bardbl",
  0x2016,
  "bracehtipdownleft",
  0xfe37,
  "bracehtipdownright",
  0xfe37,
  "bracehtipupleft",
  0xfe38,
  "bracehtipupright",
  0xfe38,
  "braceleftBig",
  0x007b,
  "braceleftbig",
  0x007b,
  "braceleftbigg",
  0x007b,
  "braceleftBigg",
  0x007b,
  "bracerightBig",
  0x007d,
  "bracerightbig",
  0x007d,
  "bracerightbigg",
  0x007d,
  "bracerightBigg",
  0x007d,
  "bracketleftbig",
  0x005b,
  "bracketleftBig",
  0x005b,
  "bracketleftbigg",
  0x005b,
  "bracketleftBigg",
  0x005b,
  "bracketrightBig",
  0x005d,
  "bracketrightbig",
  0x005d,
  "bracketrightbigg",
  0x005d,
  "bracketrightBigg",
  0x005d,
  "ceilingleftbig",
  0x2308,
  "ceilingleftBig",
  0x2308,
  "ceilingleftBigg",
  0x2308,
  "ceilingleftbigg",
  0x2308,
  "ceilingrightbig",
  0x2309,
  "ceilingrightBig",
  0x2309,
  "ceilingrightbigg",
  0x2309,
  "ceilingrightBigg",
  0x2309,
  "circledotdisplay",
  0x2299,
  "circledottext",
  0x2299,
  "circlemultiplydisplay",
  0x2297,
  "circlemultiplytext",
  0x2297,
  "circleplusdisplay",
  0x2295,
  "circleplustext",
  0x2295,
  "contintegraldisplay",
  0x222e,
  "contintegraltext",
  0x222e,
  "coproductdisplay",
  0x2210,
  "coproducttext",
  0x2210,
  "floorleftBig",
  0x230a,
  "floorleftbig",
  0x230a,
  "floorleftbigg",
  0x230a,
  "floorleftBigg",
  0x230a,
  "floorrightbig",
  0x230b,
  "floorrightBig",
  0x230b,
  "floorrightBigg",
  0x230b,
  "floorrightbigg",
  0x230b,
  "hatwide",
  0x0302,
  "hatwider",
  0x0302,
  "hatwidest",
  0x0302,
  "intercal",
  0x1d40,
  "integraldisplay",
  0x222b,
  "integraltext",
  0x222b,
  "intersectiondisplay",
  0x22c2,
  "intersectiontext",
  0x22c2,
  "logicalanddisplay",
  0x2227,
  "logicalandtext",
  0x2227,
  "logicalordisplay",
  0x2228,
  "logicalortext",
  0x2228,
  "parenleftBig",
  0x0028,
  "parenleftbig",
  0x0028,
  "parenleftBigg",
  0x0028,
  "parenleftbigg",
  0x0028,
  "parenrightBig",
  0x0029,
  "parenrightbig",
  0x0029,
  "parenrightBigg",
  0x0029,
  "parenrightbigg",
  0x0029,
  "prime",
  0x2032,
  "productdisplay",
  0x220f,
  "producttext",
  0x220f,
  "radicalbig",
  0x221a,
  "radicalBig",
  0x221a,
  "radicalBigg",
  0x221a,
  "radicalbigg",
  0x221a,
  "radicalbt",
  0x221a,
  "radicaltp",
  0x221a,
  "radicalvertex",
  0x221a,
  "slashbig",
  0x002f,
  "slashBig",
  0x002f,
  "slashBigg",
  0x002f,
  "slashbigg",
  0x002f,
  "summationdisplay",
  0x2211,
  "summationtext",
  0x2211,
  "tildewide",
  0x02dc,
  "tildewider",
  0x02dc,
  "tildewidest",
  0x02dc,
  "uniondisplay",
  0x22c3,
  "unionmultidisplay",
  0x228e,
  "unionmultitext",
  0x228e,
  "unionsqdisplay",
  0x2294,
  "unionsqtext",
  0x2294,
  "uniontext",
  0x22c3,
  "vextenddouble",
  0x2225,
  "vextendsingle",
  0x2223
 ];
});
var getDingbatsGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "space",
  0x0020,
  "a1",
  0x2701,
  "a2",
  0x2702,
  "a202",
  0x2703,
  "a3",
  0x2704,
  "a4",
  0x260e,
  "a5",
  0x2706,
  "a119",
  0x2707,
  "a118",
  0x2708,
  "a117",
  0x2709,
  "a11",
  0x261b,
  "a12",
  0x261e,
  "a13",
  0x270c,
  "a14",
  0x270d,
  "a15",
  0x270e,
  "a16",
  0x270f,
  "a105",
  0x2710,
  "a17",
  0x2711,
  "a18",
  0x2712,
  "a19",
  0x2713,
  "a20",
  0x2714,
  "a21",
  0x2715,
  "a22",
  0x2716,
  "a23",
  0x2717,
  "a24",
  0x2718,
  "a25",
  0x2719,
  "a26",
  0x271a,
  "a27",
  0x271b,
  "a28",
  0x271c,
  "a6",
  0x271d,
  "a7",
  0x271e,
  "a8",
  0x271f,
  "a9",
  0x2720,
  "a10",
  0x2721,
  "a29",
  0x2722,
  "a30",
  0x2723,
  "a31",
  0x2724,
  "a32",
  0x2725,
  "a33",
  0x2726,
  "a34",
  0x2727,
  "a35",
  0x2605,
  "a36",
  0x2729,
  "a37",
  0x272a,
  "a38",
  0x272b,
  "a39",
  0x272c,
  "a40",
  0x272d,
  "a41",
  0x272e,
  "a42",
  0x272f,
  "a43",
  0x2730,
  "a44",
  0x2731,
  "a45",
  0x2732,
  "a46",
  0x2733,
  "a47",
  0x2734,
  "a48",
  0x2735,
  "a49",
  0x2736,
  "a50",
  0x2737,
  "a51",
  0x2738,
  "a52",
  0x2739,
  "a53",
  0x273a,
  "a54",
  0x273b,
  "a55",
  0x273c,
  "a56",
  0x273d,
  "a57",
  0x273e,
  "a58",
  0x273f,
  "a59",
  0x2740,
  "a60",
  0x2741,
  "a61",
  0x2742,
  "a62",
  0x2743,
  "a63",
  0x2744,
  "a64",
  0x2745,
  "a65",
  0x2746,
  "a66",
  0x2747,
  "a67",
  0x2748,
  "a68",
  0x2749,
  "a69",
  0x274a,
  "a70",
  0x274b,
  "a71",
  0x25cf,
  "a72",
  0x274d,
  "a73",
  0x25a0,
  "a74",
  0x274f,
  "a203",
  0x2750,
  "a75",
  0x2751,
  "a204",
  0x2752,
  "a76",
  0x25b2,
  "a77",
  0x25bc,
  "a78",
  0x25c6,
  "a79",
  0x2756,
  "a81",
  0x25d7,
  "a82",
  0x2758,
  "a83",
  0x2759,
  "a84",
  0x275a,
  "a97",
  0x275b,
  "a98",
  0x275c,
  "a99",
  0x275d,
  "a100",
  0x275e,
  "a101",
  0x2761,
  "a102",
  0x2762,
  "a103",
  0x2763,
  "a104",
  0x2764,
  "a106",
  0x2765,
  "a107",
  0x2766,
  "a108",
  0x2767,
  "a112",
  0x2663,
  "a111",
  0x2666,
  "a110",
  0x2665,
  "a109",
  0x2660,
  "a120",
  0x2460,
  "a121",
  0x2461,
  "a122",
  0x2462,
  "a123",
  0x2463,
  "a124",
  0x2464,
  "a125",
  0x2465,
  "a126",
  0x2466,
  "a127",
  0x2467,
  "a128",
  0x2468,
  "a129",
  0x2469,
  "a130",
  0x2776,
  "a131",
  0x2777,
  "a132",
  0x2778,
  "a133",
  0x2779,
  "a134",
  0x277a,
  "a135",
  0x277b,
  "a136",
  0x277c,
  "a137",
  0x277d,
  "a138",
  0x277e,
  "a139",
  0x277f,
  "a140",
  0x2780,
  "a141",
  0x2781,
  "a142",
  0x2782,
  "a143",
  0x2783,
  "a144",
  0x2784,
  "a145",
  0x2785,
  "a146",
  0x2786,
  "a147",
  0x2787,
  "a148",
  0x2788,
  "a149",
  0x2789,
  "a150",
  0x278a,
  "a151",
  0x278b,
  "a152",
  0x278c,
  "a153",
  0x278d,
  "a154",
  0x278e,
  "a155",
  0x278f,
  "a156",
  0x2790,
  "a157",
  0x2791,
  "a158",
  0x2792,
  "a159",
  0x2793,
  "a160",
  0x2794,
  "a161",
  0x2192,
  "a163",
  0x2194,
  "a164",
  0x2195,
  "a196",
  0x2798,
  "a165",
  0x2799,
  "a192",
  0x279a,
  "a166",
  0x279b,
  "a167",
  0x279c,
  "a168",
  0x279d,
  "a169",
  0x279e,
  "a170",
  0x279f,
  "a171",
  0x27a0,
  "a172",
  0x27a1,
  "a173",
  0x27a2,
  "a162",
  0x27a3,
  "a174",
  0x27a4,
  "a175",
  0x27a5,
  "a176",
  0x27a6,
  "a177",
  0x27a7,
  "a178",
  0x27a8,
  "a179",
  0x27a9,
  "a193",
  0x27aa,
  "a180",
  0x27ab,
  "a199",
  0x27ac,
  "a181",
  0x27ad,
  "a200",
  0x27ae,
  "a182",
  0x27af,
  "a201",
  0x27b1,
  "a183",
  0x27b2,
  "a184",
  0x27b3,
  "a197",
  0x27b4,
  "a185",
  0x27b5,
  "a194",
  0x27b6,
  "a198",
  0x27b7,
  "a186",
  0x27b8,
  "a195",
  0x27b9,
  "a187",
  0x27ba,
  "a188",
  0x27bb,
  "a189",
  0x27bc,
  "a190",
  0x27bd,
  "a191",
  0x27be,
  "a89",
  0x2768,
  "a90",
  0x2769,
  "a93",
  0x276a,
  "a94",
  0x276b,
  "a91",
  0x276c,
  "a92",
  0x276d,
  "a205",
  0x276e,
  "a85",
  0x276f,
  "a206",
  0x2770,
  "a86",
  0x2771,
  "a87",
  0x2772,
  "a88",
  0x2773,
  "a95",
  0x2774,
  "a96",
  0x2775,
  ".notdef",
  0x0000
 ];
});


/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSymbolsFonts = exports.getSupplementalGlyphMapForCalibri = exports.getSupplementalGlyphMapForArialBlack = exports.getStdFontMap = exports.getSerifFonts = exports.getNonStdFontMap = exports.getGlyphMapForStandardFonts = void 0;

var _core_utils = __w_pdfjs_require__(138);

var getStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.ArialNarrow = "Helvetica";
  t["ArialNarrow-Bold"] = "Helvetica-Bold";
  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
  t.ArialBlack = "Helvetica";
  t["ArialBlack-Bold"] = "Helvetica-Bold";
  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialBlack-Italic"] = "Helvetica-Oblique";
  t["Arial-Black"] = "Helvetica";
  t["Arial-Black-Bold"] = "Helvetica-Bold";
  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Black-Italic"] = "Helvetica-Oblique";
  t.Arial = "Helvetica";
  t["Arial-Bold"] = "Helvetica-Bold";
  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Italic"] = "Helvetica-Oblique";
  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT"] = "Helvetica-Bold";
  t["Arial-ItalicMT"] = "Helvetica-Oblique";
  t.ArialMT = "Helvetica";
  t["Courier-Bold"] = "Courier-Bold";
  t["Courier-BoldItalic"] = "Courier-BoldOblique";
  t["Courier-Italic"] = "Courier-Oblique";
  t.CourierNew = "Courier";
  t["CourierNew-Bold"] = "Courier-Bold";
  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  t["CourierNew-Italic"] = "Courier-Oblique";
  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  t["CourierNewPS-BoldMT"] = "Courier-Bold";
  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  t.CourierNewPSMT = "Courier";
  t.Helvetica = "Helvetica";
  t["Helvetica-Bold"] = "Helvetica-Bold";
  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  t["Helvetica-Italic"] = "Helvetica-Oblique";
  t["Helvetica-Oblique"] = "Helvetica-Oblique";
  t["Symbol-Bold"] = "Symbol";
  t["Symbol-BoldItalic"] = "Symbol";
  t["Symbol-Italic"] = "Symbol";
  t.TimesNewRoman = "Times-Roman";
  t["TimesNewRoman-Bold"] = "Times-Bold";
  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRoman-Italic"] = "Times-Italic";
  t.TimesNewRomanPS = "Times-Roman";
  t["TimesNewRomanPS-Bold"] = "Times-Bold";
  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  t["TimesNewRomanPS-Italic"] = "Times-Italic";
  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  t.TimesNewRomanPSMT = "Times-Roman";
  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
exports.getStdFontMap = getStdFontMap;
var getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Calibri = "Helvetica";
  t["Calibri-Bold"] = "Helvetica-Bold";
  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  t["Calibri-Italic"] = "Helvetica-Oblique";
  t.CenturyGothic = "Helvetica";
  t["CenturyGothic-Bold"] = "Helvetica-Bold";
  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
  t.ComicSansMS = "Comic Sans MS";
  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  t.LucidaConsole = "Courier";
  t["LucidaConsole-Bold"] = "Courier-Bold";
  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  t["LucidaConsole-Italic"] = "Courier-Oblique";
  t["LucidaSans-Demi"] = "Helvetica-Bold";
  t["MS-Gothic"] = "MS Gothic";
  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
  t["MS-Mincho"] = "MS Mincho";
  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
  t["MS-PGothic"] = "MS PGothic";
  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
  t["MS-PMincho"] = "MS PMincho";
  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
  t.NuptialScript = "Times-Italic";
  t.SegoeUISymbol = "Helvetica";
  t.Wingdings = "ZapfDingbats";
  t["Wingdings-Regular"] = "ZapfDingbats";
});
exports.getNonStdFontMap = getNonStdFontMap;
var getSerifFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Adobe Jenson"] = true;
  t["Adobe Text"] = true;
  t.Albertus = true;
  t.Aldus = true;
  t.Alexandria = true;
  t.Algerian = true;
  t["American Typewriter"] = true;
  t.Antiqua = true;
  t.Apex = true;
  t.Arno = true;
  t.Aster = true;
  t.Aurora = true;
  t.Baskerville = true;
  t.Bell = true;
  t.Bembo = true;
  t["Bembo Schoolbook"] = true;
  t.Benguiat = true;
  t["Berkeley Old Style"] = true;
  t["Bernhard Modern"] = true;
  t["Berthold City"] = true;
  t.Bodoni = true;
  t["Bauer Bodoni"] = true;
  t["Book Antiqua"] = true;
  t.Bookman = true;
  t["Bordeaux Roman"] = true;
  t["Californian FB"] = true;
  t.Calisto = true;
  t.Calvert = true;
  t.Capitals = true;
  t.Cambria = true;
  t.Cartier = true;
  t.Caslon = true;
  t.Catull = true;
  t.Centaur = true;
  t["Century Old Style"] = true;
  t["Century Schoolbook"] = true;
  t.Chaparral = true;
  t["Charis SIL"] = true;
  t.Cheltenham = true;
  t["Cholla Slab"] = true;
  t.Clarendon = true;
  t.Clearface = true;
  t.Cochin = true;
  t.Colonna = true;
  t["Computer Modern"] = true;
  t["Concrete Roman"] = true;
  t.Constantia = true;
  t["Cooper Black"] = true;
  t.Corona = true;
  t.Ecotype = true;
  t.Egyptienne = true;
  t.Elephant = true;
  t.Excelsior = true;
  t.Fairfield = true;
  t["FF Scala"] = true;
  t.Folkard = true;
  t.Footlight = true;
  t.FreeSerif = true;
  t["Friz Quadrata"] = true;
  t.Garamond = true;
  t.Gentium = true;
  t.Georgia = true;
  t.Gloucester = true;
  t["Goudy Old Style"] = true;
  t["Goudy Schoolbook"] = true;
  t["Goudy Pro Font"] = true;
  t.Granjon = true;
  t["Guardian Egyptian"] = true;
  t.Heather = true;
  t.Hercules = true;
  t["High Tower Text"] = true;
  t.Hiroshige = true;
  t["Hoefler Text"] = true;
  t["Humana Serif"] = true;
  t.Imprint = true;
  t["Ionic No. 5"] = true;
  t.Janson = true;
  t.Joanna = true;
  t.Korinna = true;
  t.Lexicon = true;
  t["Liberation Serif"] = true;
  t["Linux Libertine"] = true;
  t.Literaturnaya = true;
  t.Lucida = true;
  t["Lucida Bright"] = true;
  t.Melior = true;
  t.Memphis = true;
  t.Miller = true;
  t.Minion = true;
  t.Modern = true;
  t["Mona Lisa"] = true;
  t["Mrs Eaves"] = true;
  t["MS Serif"] = true;
  t["Museo Slab"] = true;
  t["New York"] = true;
  t["Nimbus Roman"] = true;
  t["NPS Rawlinson Roadway"] = true;
  t.NuptialScript = true;
  t.Palatino = true;
  t.Perpetua = true;
  t.Plantin = true;
  t["Plantin Schoolbook"] = true;
  t.Playbill = true;
  t["Poor Richard"] = true;
  t["Rawlinson Roadway"] = true;
  t.Renault = true;
  t.Requiem = true;
  t.Rockwell = true;
  t.Roman = true;
  t["Rotis Serif"] = true;
  t.Sabon = true;
  t.Scala = true;
  t.Seagull = true;
  t.Sistina = true;
  t.Souvenir = true;
  t.STIX = true;
  t["Stone Informal"] = true;
  t["Stone Serif"] = true;
  t.Sylfaen = true;
  t.Times = true;
  t.Trajan = true;
  t["Trinit"] = true;
  t["Trump Mediaeval"] = true;
  t.Utopia = true;
  t["Vale Type"] = true;
  t["Bitstream Vera"] = true;
  t["Vera Serif"] = true;
  t.Versailles = true;
  t.Wanted = true;
  t.Weiss = true;
  t["Wide Latin"] = true;
  t.Windsor = true;
  t.XITS = true;
});
exports.getSerifFonts = getSerifFonts;
var getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Dingbats = true;
  t.Symbol = true;
  t.ZapfDingbats = true;
});
exports.getSymbolsFonts = getSymbolsFonts;
var getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[227] = 353;
  t[229] = 382;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
var getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
var getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[1] = 32;
  t[4] = 65;
  t[17] = 66;
  t[18] = 67;
  t[24] = 68;
  t[28] = 69;
  t[38] = 70;
  t[39] = 71;
  t[44] = 72;
  t[47] = 73;
  t[58] = 74;
  t[60] = 75;
  t[62] = 76;
  t[68] = 77;
  t[69] = 78;
  t[75] = 79;
  t[87] = 80;
  t[89] = 81;
  t[90] = 82;
  t[94] = 83;
  t[100] = 84;
  t[104] = 85;
  t[115] = 86;
  t[116] = 87;
  t[121] = 88;
  t[122] = 89;
  t[127] = 90;
  t[258] = 97;
  t[268] = 261;
  t[271] = 98;
  t[272] = 99;
  t[273] = 263;
  t[282] = 100;
  t[286] = 101;
  t[295] = 281;
  t[296] = 102;
  t[336] = 103;
  t[346] = 104;
  t[349] = 105;
  t[361] = 106;
  t[364] = 107;
  t[367] = 108;
  t[371] = 322;
  t[373] = 109;
  t[374] = 110;
  t[381] = 111;
  t[383] = 243;
  t[393] = 112;
  t[395] = 113;
  t[396] = 114;
  t[400] = 115;
  t[401] = 347;
  t[410] = 116;
  t[437] = 117;
  t[448] = 118;
  t[449] = 119;
  t[454] = 120;
  t[455] = 121;
  t[460] = 122;
  t[463] = 380;
  t[853] = 44;
  t[855] = 58;
  t[856] = 46;
  t[876] = 47;
  t[878] = 45;
  t[882] = 45;
  t[894] = 40;
  t[895] = 41;
  t[896] = 91;
  t[897] = 93;
  t[923] = 64;
  t[1004] = 48;
  t[1005] = 49;
  t[1006] = 50;
  t[1007] = 51;
  t[1008] = 52;
  t[1009] = 53;
  t[1010] = 54;
  t[1011] = 55;
  t[1012] = 56;
  t[1013] = 57;
  t[1081] = 37;
  t[1085] = 43;
  t[1086] = 45;
});
exports.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) => {

"use strict";
__w_pdfjs_require__.r(__webpack_exports__);
/* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, {
/* harmony export */   "getNormalizedUnicodes": () => (/* binding */ getNormalizedUnicodes),
/* harmony export */   "getUnicodeForGlyph": () => (/* binding */ getUnicodeForGlyph),
/* harmony export */   "getUnicodeRangeFor": () => (/* binding */ getUnicodeRangeFor),
/* harmony export */   "mapSpecialUnicodeValues": () => (/* binding */ mapSpecialUnicodeValues),
/* harmony export */   "reverseIfRtl": () => (/* binding */ reverseIfRtl)
/* harmony export */ });
/* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(138);

var getSpecialPUASymbols = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getLookupTableFactory)(function (t) {
 t[63721] = 0x00a9;
 t[63193] = 0x00a9;
 t[63720] = 0x00ae;
 t[63194] = 0x00ae;
 t[63722] = 0x2122;
 t[63195] = 0x2122;
 t[63729] = 0x23a7;
 t[63730] = 0x23a8;
 t[63731] = 0x23a9;
 t[63740] = 0x23ab;
 t[63741] = 0x23ac;
 t[63742] = 0x23ad;
 t[63726] = 0x23a1;
 t[63727] = 0x23a2;
 t[63728] = 0x23a3;
 t[63737] = 0x23a4;
 t[63738] = 0x23a5;
 t[63739] = 0x23a6;
 t[63723] = 0x239b;
 t[63724] = 0x239c;
 t[63725] = 0x239d;
 t[63734] = 0x239e;
 t[63735] = 0x239f;
 t[63736] = 0x23a0;
});
function mapSpecialUnicodeValues(code) {
 if (code >= 0xfff0 && code <= 0xffff) {
  return 0;
 } else if (code >= 0xf600 && code <= 0xf8ff) {
  return getSpecialPUASymbols()[code] || code;
 } else if (code === 0x00ad) {
  return 0x002d;
 }
 return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
 var unicode = glyphsUnicodeMap[name];
 if (unicode !== undefined) {
  return unicode;
 }
 if (!name) {
  return -1;
 }
 if (name[0] === "u") {
  var nameLen = name.length, hexStr;
  if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
   hexStr = name.substring(3);
  } else if (nameLen >= 5 && nameLen <= 7) {
   hexStr = name.substring(1);
  } else {
   return -1;
  }
  if (hexStr === hexStr.toUpperCase()) {
   unicode = parseInt(hexStr, 16);
   if (unicode >= 0) {
    return unicode;
   }
  }
 }
 return -1;
}
var UnicodeRanges = [
 {
  begin: 0x0000,
  end: 0x007f
 },
 {
  begin: 0x0080,
  end: 0x00ff
 },
 {
  begin: 0x0100,
  end: 0x017f
 },
 {
  begin: 0x0180,
  end: 0x024f
 },
 {
  begin: 0x0250,
  end: 0x02af
 },
 {
  begin: 0x02b0,
  end: 0x02ff
 },
 {
  begin: 0x0300,
  end: 0x036f
 },
 {
  begin: 0x0370,
  end: 0x03ff
 },
 {
  begin: 0x2c80,
  end: 0x2cff
 },
 {
  begin: 0x0400,
  end: 0x04ff
 },
 {
  begin: 0x0530,
  end: 0x058f
 },
 {
  begin: 0x0590,
  end: 0x05ff
 },
 {
  begin: 0xa500,
  end: 0xa63f
 },
 {
  begin: 0x0600,
  end: 0x06ff
 },
 {
  begin: 0x07c0,
  end: 0x07ff
 },
 {
  begin: 0x0900,
  end: 0x097f
 },
 {
  begin: 0x0980,
  end: 0x09ff
 },
 {
  begin: 0x0a00,
  end: 0x0a7f
 },
 {
  begin: 0x0a80,
  end: 0x0aff
 },
 {
  begin: 0x0b00,
  end: 0x0b7f
 },
 {
  begin: 0x0b80,
  end: 0x0bff
 },
 {
  begin: 0x0c00,
  end: 0x0c7f
 },
 {
  begin: 0x0c80,
  end: 0x0cff
 },
 {
  begin: 0x0d00,
  end: 0x0d7f
 },
 {
  begin: 0x0e00,
  end: 0x0e7f
 },
 {
  begin: 0x0e80,
  end: 0x0eff
 },
 {
  begin: 0x10a0,
  end: 0x10ff
 },
 {
  begin: 0x1b00,
  end: 0x1b7f
 },
 {
  begin: 0x1100,
  end: 0x11ff
 },
 {
  begin: 0x1e00,
  end: 0x1eff
 },
 {
  begin: 0x1f00,
  end: 0x1fff
 },
 {
  begin: 0x2000,
  end: 0x206f
 },
 {
  begin: 0x2070,
  end: 0x209f
 },
 {
  begin: 0x20a0,
  end: 0x20cf
 },
 {
  begin: 0x20d0,
  end: 0x20ff
 },
 {
  begin: 0x2100,
  end: 0x214f
 },
 {
  begin: 0x2150,
  end: 0x218f
 },
 {
  begin: 0x2190,
  end: 0x21ff
 },
 {
  begin: 0x2200,
  end: 0x22ff
 },
 {
  begin: 0x2300,
  end: 0x23ff
 },
 {
  begin: 0x2400,
  end: 0x243f
 },
 {
  begin: 0x2440,
  end: 0x245f
 },
 {
  begin: 0x2460,
  end: 0x24ff
 },
 {
  begin: 0x2500,
  end: 0x257f
 },
 {
  begin: 0x2580,
  end: 0x259f
 },
 {
  begin: 0x25a0,
  end: 0x25ff
 },
 {
  begin: 0x2600,
  end: 0x26ff
 },
 {
  begin: 0x2700,
  end: 0x27bf
 },
 {
  begin: 0x3000,
  end: 0x303f
 },
 {
  begin: 0x3040,
  end: 0x309f
 },
 {
  begin: 0x30a0,
  end: 0x30ff
 },
 {
  begin: 0x3100,
  end: 0x312f
 },
 {
  begin: 0x3130,
  end: 0x318f
 },
 {
  begin: 0xa840,
  end: 0xa87f
 },
 {
  begin: 0x3200,
  end: 0x32ff
 },
 {
  begin: 0x3300,
  end: 0x33ff
 },
 {
  begin: 0xac00,
  end: 0xd7af
 },
 {
  begin: 0xd800,
  end: 0xdfff
 },
 {
  begin: 0x10900,
  end: 0x1091f
 },
 {
  begin: 0x4e00,
  end: 0x9fff
 },
 {
  begin: 0xe000,
  end: 0xf8ff
 },
 {
  begin: 0x31c0,
  end: 0x31ef
 },
 {
  begin: 0xfb00,
  end: 0xfb4f
 },
 {
  begin: 0xfb50,
  end: 0xfdff
 },
 {
  begin: 0xfe20,
  end: 0xfe2f
 },
 {
  begin: 0xfe10,
  end: 0xfe1f
 },
 {
  begin: 0xfe50,
  end: 0xfe6f
 },
 {
  begin: 0xfe70,
  end: 0xfeff
 },
 {
  begin: 0xff00,
  end: 0xffef
 },
 {
  begin: 0xfff0,
  end: 0xffff
 },
 {
  begin: 0x0f00,
  end: 0x0fff
 },
 {
  begin: 0x0700,
  end: 0x074f
 },
 {
  begin: 0x0780,
  end: 0x07bf
 },
 {
  begin: 0x0d80,
  end: 0x0dff
 },
 {
  begin: 0x1000,
  end: 0x109f
 },
 {
  begin: 0x1200,
  end: 0x137f
 },
 {
  begin: 0x13a0,
  end: 0x13ff
 },
 {
  begin: 0x1400,
  end: 0x167f
 },
 {
  begin: 0x1680,
  end: 0x169f
 },
 {
  begin: 0x16a0,
  end: 0x16ff
 },
 {
  begin: 0x1780,
  end: 0x17ff
 },
 {
  begin: 0x1800,
  end: 0x18af
 },
 {
  begin: 0x2800,
  end: 0x28ff
 },
 {
  begin: 0xa000,
  end: 0xa48f
 },
 {
  begin: 0x1700,
  end: 0x171f
 },
 {
  begin: 0x10300,
  end: 0x1032f
 },
 {
  begin: 0x10330,
  end: 0x1034f
 },
 {
  begin: 0x10400,
  end: 0x1044f
 },
 {
  begin: 0x1d000,
  end: 0x1d0ff
 },
 {
  begin: 0x1d400,
  end: 0x1d7ff
 },
 {
  begin: 0xff000,
  end: 0xffffd
 },
 {
  begin: 0xfe00,
  end: 0xfe0f
 },
 {
  begin: 0xe0000,
  end: 0xe007f
 },
 {
  begin: 0x1900,
  end: 0x194f
 },
 {
  begin: 0x1950,
  end: 0x197f
 },
 {
  begin: 0x1980,
  end: 0x19df
 },
 {
  begin: 0x1a00,
  end: 0x1a1f
 },
 {
  begin: 0x2c00,
  end: 0x2c5f
 },
 {
  begin: 0x2d30,
  end: 0x2d7f
 },
 {
  begin: 0x4dc0,
  end: 0x4dff
 },
 {
  begin: 0xa800,
  end: 0xa82f
 },
 {
  begin: 0x10000,
  end: 0x1007f
 },
 {
  begin: 0x10140,
  end: 0x1018f
 },
 {
  begin: 0x10380,
  end: 0x1039f
 },
 {
  begin: 0x103a0,
  end: 0x103df
 },
 {
  begin: 0x10450,
  end: 0x1047f
 },
 {
  begin: 0x10480,
  end: 0x104af
 },
 {
  begin: 0x10800,
  end: 0x1083f
 },
 {
  begin: 0x10a00,
  end: 0x10a5f
 },
 {
  begin: 0x1d300,
  end: 0x1d35f
 },
 {
  begin: 0x12000,
  end: 0x123ff
 },
 {
  begin: 0x1d360,
  end: 0x1d37f
 },
 {
  begin: 0x1b80,
  end: 0x1bbf
 },
 {
  begin: 0x1c00,
  end: 0x1c4f
 },
 {
  begin: 0x1c50,
  end: 0x1c7f
 },
 {
  begin: 0xa880,
  end: 0xa8df
 },
 {
  begin: 0xa900,
  end: 0xa92f
 },
 {
  begin: 0xa930,
  end: 0xa95f
 },
 {
  begin: 0xaa00,
  end: 0xaa5f
 },
 {
  begin: 0x10190,
  end: 0x101cf
 },
 {
  begin: 0x101d0,
  end: 0x101ff
 },
 {
  begin: 0x102a0,
  end: 0x102df
 },
 {
  begin: 0x1f030,
  end: 0x1f09f
 }
];
function getUnicodeRangeFor(value) {
 for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
  var range = UnicodeRanges[i];
  if (value >= range.begin && value < range.end) {
   return i;
  }
 }
 return -1;
}
function isRTLRangeFor(value) {
 var range = UnicodeRanges[13];
 if (value >= range.begin && value < range.end) {
  return true;
 }
 range = UnicodeRanges[11];
 if (value >= range.begin && value < range.end) {
  return true;
 }
 return false;
}
var getNormalizedUnicodes = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "\u00A8",
  "\u0020\u0308",
  "\u00AF",
  "\u0020\u0304",
  "\u00B4",
  "\u0020\u0301",
  "\u00B5",
  "\u03BC",
  "\u00B8",
  "\u0020\u0327",
  "\u0132",
  "\u0049\u004A",
  "\u0133",
  "\u0069\u006A",
  "\u013F",
  "\u004C\u00B7",
  "\u0140",
  "\u006C\u00B7",
  "\u0149",
  "\u02BC\u006E",
  "\u017F",
  "\u0073",
  "\u01C4",
  "\u0044\u017D",
  "\u01C5",
  "\u0044\u017E",
  "\u01C6",
  "\u0064\u017E",
  "\u01C7",
  "\u004C\u004A",
  "\u01C8",
  "\u004C\u006A",
  "\u01C9",
  "\u006C\u006A",
  "\u01CA",
  "\u004E\u004A",
  "\u01CB",
  "\u004E\u006A",
  "\u01CC",
  "\u006E\u006A",
  "\u01F1",
  "\u0044\u005A",
  "\u01F2",
  "\u0044\u007A",
  "\u01F3",
  "\u0064\u007A",
  "\u02D8",
  "\u0020\u0306",
  "\u02D9",
  "\u0020\u0307",
  "\u02DA",
  "\u0020\u030A",
  "\u02DB",
  "\u0020\u0328",
  "\u02DC",
  "\u0020\u0303",
  "\u02DD",
  "\u0020\u030B",
  "\u037A",
  "\u0020\u0345",
  "\u0384",
  "\u0020\u0301",
  "\u03D0",
  "\u03B2",
  "\u03D1",
  "\u03B8",
  "\u03D2",
  "\u03A5",
  "\u03D5",
  "\u03C6",
  "\u03D6",
  "\u03C0",
  "\u03F0",
  "\u03BA",
  "\u03F1",
  "\u03C1",
  "\u03F2",
  "\u03C2",
  "\u03F4",
  "\u0398",
  "\u03F5",
  "\u03B5",
  "\u03F9",
  "\u03A3",
  "\u0587",
  "\u0565\u0582",
  "\u0675",
  "\u0627\u0674",
  "\u0676",
  "\u0648\u0674",
  "\u0677",
  "\u06C7\u0674",
  "\u0678",
  "\u064A\u0674",
  "\u0E33",
  "\u0E4D\u0E32",
  "\u0EB3",
  "\u0ECD\u0EB2",
  "\u0EDC",
  "\u0EAB\u0E99",
  "\u0EDD",
  "\u0EAB\u0EA1",
  "\u0F77",
  "\u0FB2\u0F81",
  "\u0F79",
  "\u0FB3\u0F81",
  "\u1E9A",
  "\u0061\u02BE",
  "\u1FBD",
  "\u0020\u0313",
  "\u1FBF",
  "\u0020\u0313",
  "\u1FC0",
  "\u0020\u0342",
  "\u1FFE",
  "\u0020\u0314",
  "\u2002",
  "\u0020",
  "\u2003",
  "\u0020",
  "\u2004",
  "\u0020",
  "\u2005",
  "\u0020",
  "\u2006",
  "\u0020",
  "\u2008",
  "\u0020",
  "\u2009",
  "\u0020",
  "\u200A",
  "\u0020",
  "\u2017",
  "\u0020\u0333",
  "\u2024",
  "\u002E",
  "\u2025",
  "\u002E\u002E",
  "\u2026",
  "\u002E\u002E\u002E",
  "\u2033",
  "\u2032\u2032",
  "\u2034",
  "\u2032\u2032\u2032",
  "\u2036",
  "\u2035\u2035",
  "\u2037",
  "\u2035\u2035\u2035",
  "\u203C",
  "\u0021\u0021",
  "\u203E",
  "\u0020\u0305",
  "\u2047",
  "\u003F\u003F",
  "\u2048",
  "\u003F\u0021",
  "\u2049",
  "\u0021\u003F",
  "\u2057",
  "\u2032\u2032\u2032\u2032",
  "\u205F",
  "\u0020",
  "\u20A8",
  "\u0052\u0073",
  "\u2100",
  "\u0061\u002F\u0063",
  "\u2101",
  "\u0061\u002F\u0073",
  "\u2103",
  "\u00B0\u0043",
  "\u2105",
  "\u0063\u002F\u006F",
  "\u2106",
  "\u0063\u002F\u0075",
  "\u2107",
  "\u0190",
  "\u2109",
  "\u00B0\u0046",
  "\u2116",
  "\u004E\u006F",
  "\u2121",
  "\u0054\u0045\u004C",
  "\u2135",
  "\u05D0",
  "\u2136",
  "\u05D1",
  "\u2137",
  "\u05D2",
  "\u2138",
  "\u05D3",
  "\u213B",
  "\u0046\u0041\u0058",
  "\u2160",
  "\u0049",
  "\u2161",
  "\u0049\u0049",
  "\u2162",
  "\u0049\u0049\u0049",
  "\u2163",
  "\u0049\u0056",
  "\u2164",
  "\u0056",
  "\u2165",
  "\u0056\u0049",
  "\u2166",
  "\u0056\u0049\u0049",
  "\u2167",
  "\u0056\u0049\u0049\u0049",
  "\u2168",
  "\u0049\u0058",
  "\u2169",
  "\u0058",
  "\u216A",
  "\u0058\u0049",
  "\u216B",
  "\u0058\u0049\u0049",
  "\u216C",
  "\u004C",
  "\u216D",
  "\u0043",
  "\u216E",
  "\u0044",
  "\u216F",
  "\u004D",
  "\u2170",
  "\u0069",
  "\u2171",
  "\u0069\u0069",
  "\u2172",
  "\u0069\u0069\u0069",
  "\u2173",
  "\u0069\u0076",
  "\u2174",
  "\u0076",
  "\u2175",
  "\u0076\u0069",
  "\u2176",
  "\u0076\u0069\u0069",
  "\u2177",
  "\u0076\u0069\u0069\u0069",
  "\u2178",
  "\u0069\u0078",
  "\u2179",
  "\u0078",
  "\u217A",
  "\u0078\u0069",
  "\u217B",
  "\u0078\u0069\u0069",
  "\u217C",
  "\u006C",
  "\u217D",
  "\u0063",
  "\u217E",
  "\u0064",
  "\u217F",
  "\u006D",
  "\u222C",
  "\u222B\u222B",
  "\u222D",
  "\u222B\u222B\u222B",
  "\u222F",
  "\u222E\u222E",
  "\u2230",
  "\u222E\u222E\u222E",
  "\u2474",
  "\u0028\u0031\u0029",
  "\u2475",
  "\u0028\u0032\u0029",
  "\u2476",
  "\u0028\u0033\u0029",
  "\u2477",
  "\u0028\u0034\u0029",
  "\u2478",
  "\u0028\u0035\u0029",
  "\u2479",
  "\u0028\u0036\u0029",
  "\u247A",
  "\u0028\u0037\u0029",
  "\u247B",
  "\u0028\u0038\u0029",
  "\u247C",
  "\u0028\u0039\u0029",
  "\u247D",
  "\u0028\u0031\u0030\u0029",
  "\u247E",
  "\u0028\u0031\u0031\u0029",
  "\u247F",
  "\u0028\u0031\u0032\u0029",
  "\u2480",
  "\u0028\u0031\u0033\u0029",
  "\u2481",
  "\u0028\u0031\u0034\u0029",
  "\u2482",
  "\u0028\u0031\u0035\u0029",
  "\u2483",
  "\u0028\u0031\u0036\u0029",
  "\u2484",
  "\u0028\u0031\u0037\u0029",
  "\u2485",
  "\u0028\u0031\u0038\u0029",
  "\u2486",
  "\u0028\u0031\u0039\u0029",
  "\u2487",
  "\u0028\u0032\u0030\u0029",
  "\u2488",
  "\u0031\u002E",
  "\u2489",
  "\u0032\u002E",
  "\u248A",
  "\u0033\u002E",
  "\u248B",
  "\u0034\u002E",
  "\u248C",
  "\u0035\u002E",
  "\u248D",
  "\u0036\u002E",
  "\u248E",
  "\u0037\u002E",
  "\u248F",
  "\u0038\u002E",
  "\u2490",
  "\u0039\u002E",
  "\u2491",
  "\u0031\u0030\u002E",
  "\u2492",
  "\u0031\u0031\u002E",
  "\u2493",
  "\u0031\u0032\u002E",
  "\u2494",
  "\u0031\u0033\u002E",
  "\u2495",
  "\u0031\u0034\u002E",
  "\u2496",
  "\u0031\u0035\u002E",
  "\u2497",
  "\u0031\u0036\u002E",
  "\u2498",
  "\u0031\u0037\u002E",
  "\u2499",
  "\u0031\u0038\u002E",
  "\u249A",
  "\u0031\u0039\u002E",
  "\u249B",
  "\u0032\u0030\u002E",
  "\u249C",
  "\u0028\u0061\u0029",
  "\u249D",
  "\u0028\u0062\u0029",
  "\u249E",
  "\u0028\u0063\u0029",
  "\u249F",
  "\u0028\u0064\u0029",
  "\u24A0",
  "\u0028\u0065\u0029",
  "\u24A1",
  "\u0028\u0066\u0029",
  "\u24A2",
  "\u0028\u0067\u0029",
  "\u24A3",
  "\u0028\u0068\u0029",
  "\u24A4",
  "\u0028\u0069\u0029",
  "\u24A5",
  "\u0028\u006A\u0029",
  "\u24A6",
  "\u0028\u006B\u0029",
  "\u24A7",
  "\u0028\u006C\u0029",
  "\u24A8",
  "\u0028\u006D\u0029",
  "\u24A9",
  "\u0028\u006E\u0029",
  "\u24AA",
  "\u0028\u006F\u0029",
  "\u24AB",
  "\u0028\u0070\u0029",
  "\u24AC",
  "\u0028\u0071\u0029",
  "\u24AD",
  "\u0028\u0072\u0029",
  "\u24AE",
  "\u0028\u0073\u0029",
  "\u24AF",
  "\u0028\u0074\u0029",
  "\u24B0",
  "\u0028\u0075\u0029",
  "\u24B1",
  "\u0028\u0076\u0029",
  "\u24B2",
  "\u0028\u0077\u0029",
  "\u24B3",
  "\u0028\u0078\u0029",
  "\u24B4",
  "\u0028\u0079\u0029",
  "\u24B5",
  "\u0028\u007A\u0029",
  "\u2A0C",
  "\u222B\u222B\u222B\u222B",
  "\u2A74",
  "\u003A\u003A\u003D",
  "\u2A75",
  "\u003D\u003D",
  "\u2A76",
  "\u003D\u003D\u003D",
  "\u2E9F",
  "\u6BCD",
  "\u2EF3",
  "\u9F9F",
  "\u2F00",
  "\u4E00",
  "\u2F01",
  "\u4E28",
  "\u2F02",
  "\u4E36",
  "\u2F03",
  "\u4E3F",
  "\u2F04",
  "\u4E59",
  "\u2F05",
  "\u4E85",
  "\u2F06",
  "\u4E8C",
  "\u2F07",
  "\u4EA0",
  "\u2F08",
  "\u4EBA",
  "\u2F09",
  "\u513F",
  "\u2F0A",
  "\u5165",
  "\u2F0B",
  "\u516B",
  "\u2F0C",
  "\u5182",
  "\u2F0D",
  "\u5196",
  "\u2F0E",
  "\u51AB",
  "\u2F0F",
  "\u51E0",
  "\u2F10",
  "\u51F5",
  "\u2F11",
  "\u5200",
  "\u2F12",
  "\u529B",
  "\u2F13",
  "\u52F9",
  "\u2F14",
  "\u5315",
  "\u2F15",
  "\u531A",
  "\u2F16",
  "\u5338",
  "\u2F17",
  "\u5341",
  "\u2F18",
  "\u535C",
  "\u2F19",
  "\u5369",
  "\u2F1A",
  "\u5382",
  "\u2F1B",
  "\u53B6",
  "\u2F1C",
  "\u53C8",
  "\u2F1D",
  "\u53E3",
  "\u2F1E",
  "\u56D7",
  "\u2F1F",
  "\u571F",
  "\u2F20",
  "\u58EB",
  "\u2F21",
  "\u5902",
  "\u2F22",
  "\u590A",
  "\u2F23",
  "\u5915",
  "\u2F24",
  "\u5927",
  "\u2F25",
  "\u5973",
  "\u2F26",
  "\u5B50",
  "\u2F27",
  "\u5B80",
  "\u2F28",
  "\u5BF8",
  "\u2F29",
  "\u5C0F",
  "\u2F2A",
  "\u5C22",
  "\u2F2B",
  "\u5C38",
  "\u2F2C",
  "\u5C6E",
  "\u2F2D",
  "\u5C71",
  "\u2F2E",
  "\u5DDB",
  "\u2F2F",
  "\u5DE5",
  "\u2F30",
  "\u5DF1",
  "\u2F31",
  "\u5DFE",
  "\u2F32",
  "\u5E72",
  "\u2F33",
  "\u5E7A",
  "\u2F34",
  "\u5E7F",
  "\u2F35",
  "\u5EF4",
  "\u2F36",
  "\u5EFE",
  "\u2F37",
  "\u5F0B",
  "\u2F38",
  "\u5F13",
  "\u2F39",
  "\u5F50",
  "\u2F3A",
  "\u5F61",
  "\u2F3B",
  "\u5F73",
  "\u2F3C",
  "\u5FC3",
  "\u2F3D",
  "\u6208",
  "\u2F3E",
  "\u6236",
  "\u2F3F",
  "\u624B",
  "\u2F40",
  "\u652F",
  "\u2F41",
  "\u6534",
  "\u2F42",
  "\u6587",
  "\u2F43",
  "\u6597",
  "\u2F44",
  "\u65A4",
  "\u2F45",
  "\u65B9",
  "\u2F46",
  "\u65E0",
  "\u2F47",
  "\u65E5",
  "\u2F48",
  "\u66F0",
  "\u2F49",
  "\u6708",
  "\u2F4A",
  "\u6728",
  "\u2F4B",
  "\u6B20",
  "\u2F4C",
  "\u6B62",
  "\u2F4D",
  "\u6B79",
  "\u2F4E",
  "\u6BB3",
  "\u2F4F",
  "\u6BCB",
  "\u2F50",
  "\u6BD4",
  "\u2F51",
  "\u6BDB",
  "\u2F52",
  "\u6C0F",
  "\u2F53",
  "\u6C14",
  "\u2F54",
  "\u6C34",
  "\u2F55",
  "\u706B",
  "\u2F56",
  "\u722A",
  "\u2F57",
  "\u7236",
  "\u2F58",
  "\u723B",
  "\u2F59",
  "\u723F",
  "\u2F5A",
  "\u7247",
  "\u2F5B",
  "\u7259",
  "\u2F5C",
  "\u725B",
  "\u2F5D",
  "\u72AC",
  "\u2F5E",
  "\u7384",
  "\u2F5F",
  "\u7389",
  "\u2F60",
  "\u74DC",
  "\u2F61",
  "\u74E6",
  "\u2F62",
  "\u7518",
  "\u2F63",
  "\u751F",
  "\u2F64",
  "\u7528",
  "\u2F65",
  "\u7530",
  "\u2F66",
  "\u758B",
  "\u2F67",
  "\u7592",
  "\u2F68",
  "\u7676",
  "\u2F69",
  "\u767D",
  "\u2F6A",
  "\u76AE",
  "\u2F6B",
  "\u76BF",
  "\u2F6C",
  "\u76EE",
  "\u2F6D",
  "\u77DB",
  "\u2F6E",
  "\u77E2",
  "\u2F6F",
  "\u77F3",
  "\u2F70",
  "\u793A",
  "\u2F71",
  "\u79B8",
  "\u2F72",
  "\u79BE",
  "\u2F73",
  "\u7A74",
  "\u2F74",
  "\u7ACB",
  "\u2F75",
  "\u7AF9",
  "\u2F76",
  "\u7C73",
  "\u2F77",
  "\u7CF8",
  "\u2F78",
  "\u7F36",
  "\u2F79",
  "\u7F51",
  "\u2F7A",
  "\u7F8A",
  "\u2F7B",
  "\u7FBD",
  "\u2F7C",
  "\u8001",
  "\u2F7D",
  "\u800C",
  "\u2F7E",
  "\u8012",
  "\u2F7F",
  "\u8033",
  "\u2F80",
  "\u807F",
  "\u2F81",
  "\u8089",
  "\u2F82",
  "\u81E3",
  "\u2F83",
  "\u81EA",
  "\u2F84",
  "\u81F3",
  "\u2F85",
  "\u81FC",
  "\u2F86",
  "\u820C",
  "\u2F87",
  "\u821B",
  "\u2F88",
  "\u821F",
  "\u2F89",
  "\u826E",
  "\u2F8A",
  "\u8272",
  "\u2F8B",
  "\u8278",
  "\u2F8C",
  "\u864D",
  "\u2F8D",
  "\u866B",
  "\u2F8E",
  "\u8840",
  "\u2F8F",
  "\u884C",
  "\u2F90",
  "\u8863",
  "\u2F91",
  "\u897E",
  "\u2F92",
  "\u898B",
  "\u2F93",
  "\u89D2",
  "\u2F94",
  "\u8A00",
  "\u2F95",
  "\u8C37",
  "\u2F96",
  "\u8C46",
  "\u2F97",
  "\u8C55",
  "\u2F98",
  "\u8C78",
  "\u2F99",
  "\u8C9D",
  "\u2F9A",
  "\u8D64",
  "\u2F9B",
  "\u8D70",
  "\u2F9C",
  "\u8DB3",
  "\u2F9D",
  "\u8EAB",
  "\u2F9E",
  "\u8ECA",
  "\u2F9F",
  "\u8F9B",
  "\u2FA0",
  "\u8FB0",
  "\u2FA1",
  "\u8FB5",
  "\u2FA2",
  "\u9091",
  "\u2FA3",
  "\u9149",
  "\u2FA4",
  "\u91C6",
  "\u2FA5",
  "\u91CC",
  "\u2FA6",
  "\u91D1",
  "\u2FA7",
  "\u9577",
  "\u2FA8",
  "\u9580",
  "\u2FA9",
  "\u961C",
  "\u2FAA",
  "\u96B6",
  "\u2FAB",
  "\u96B9",
  "\u2FAC",
  "\u96E8",
  "\u2FAD",
  "\u9751",
  "\u2FAE",
  "\u975E",
  "\u2FAF",
  "\u9762",
  "\u2FB0",
  "\u9769",
  "\u2FB1",
  "\u97CB",
  "\u2FB2",
  "\u97ED",
  "\u2FB3",
  "\u97F3",
  "\u2FB4",
  "\u9801",
  "\u2FB5",
  "\u98A8",
  "\u2FB6",
  "\u98DB",
  "\u2FB7",
  "\u98DF",
  "\u2FB8",
  "\u9996",
  "\u2FB9",
  "\u9999",
  "\u2FBA",
  "\u99AC",
  "\u2FBB",
  "\u9AA8",
  "\u2FBC",
  "\u9AD8",
  "\u2FBD",
  "\u9ADF",
  "\u2FBE",
  "\u9B25",
  "\u2FBF",
  "\u9B2F",
  "\u2FC0",
  "\u9B32",
  "\u2FC1",
  "\u9B3C",
  "\u2FC2",
  "\u9B5A",
  "\u2FC3",
  "\u9CE5",
  "\u2FC4",
  "\u9E75",
  "\u2FC5",
  "\u9E7F",
  "\u2FC6",
  "\u9EA5",
  "\u2FC7",
  "\u9EBB",
  "\u2FC8",
  "\u9EC3",
  "\u2FC9",
  "\u9ECD",
  "\u2FCA",
  "\u9ED1",
  "\u2FCB",
  "\u9EF9",
  "\u2FCC",
  "\u9EFD",
  "\u2FCD",
  "\u9F0E",
  "\u2FCE",
  "\u9F13",
  "\u2FCF",
  "\u9F20",
  "\u2FD0",
  "\u9F3B",
  "\u2FD1",
  "\u9F4A",
  "\u2FD2",
  "\u9F52",
  "\u2FD3",
  "\u9F8D",
  "\u2FD4",
  "\u9F9C",
  "\u2FD5",
  "\u9FA0",
  "\u3036",
  "\u3012",
  "\u3038",
  "\u5341",
  "\u3039",
  "\u5344",
  "\u303A",
  "\u5345",
  "\u309B",
  "\u0020\u3099",
  "\u309C",
  "\u0020\u309A",
  "\u3131",
  "\u1100",
  "\u3132",
  "\u1101",
  "\u3133",
  "\u11AA",
  "\u3134",
  "\u1102",
  "\u3135",
  "\u11AC",
  "\u3136",
  "\u11AD",
  "\u3137",
  "\u1103",
  "\u3138",
  "\u1104",
  "\u3139",
  "\u1105",
  "\u313A",
  "\u11B0",
  "\u313B",
  "\u11B1",
  "\u313C",
  "\u11B2",
  "\u313D",
  "\u11B3",
  "\u313E",
  "\u11B4",
  "\u313F",
  "\u11B5",
  "\u3140",
  "\u111A",
  "\u3141",
  "\u1106",
  "\u3142",
  "\u1107",
  "\u3143",
  "\u1108",
  "\u3144",
  "\u1121",
  "\u3145",
  "\u1109",
  "\u3146",
  "\u110A",
  "\u3147",
  "\u110B",
  "\u3148",
  "\u110C",
  "\u3149",
  "\u110D",
  "\u314A",
  "\u110E",
  "\u314B",
  "\u110F",
  "\u314C",
  "\u1110",
  "\u314D",
  "\u1111",
  "\u314E",
  "\u1112",
  "\u314F",
  "\u1161",
  "\u3150",
  "\u1162",
  "\u3151",
  "\u1163",
  "\u3152",
  "\u1164",
  "\u3153",
  "\u1165",
  "\u3154",
  "\u1166",
  "\u3155",
  "\u1167",
  "\u3156",
  "\u1168",
  "\u3157",
  "\u1169",
  "\u3158",
  "\u116A",
  "\u3159",
  "\u116B",
  "\u315A",
  "\u116C",
  "\u315B",
  "\u116D",
  "\u315C",
  "\u116E",
  "\u315D",
  "\u116F",
  "\u315E",
  "\u1170",
  "\u315F",
  "\u1171",
  "\u3160",
  "\u1172",
  "\u3161",
  "\u1173",
  "\u3162",
  "\u1174",
  "\u3163",
  "\u1175",
  "\u3164",
  "\u1160",
  "\u3165",
  "\u1114",
  "\u3166",
  "\u1115",
  "\u3167",
  "\u11C7",
  "\u3168",
  "\u11C8",
  "\u3169",
  "\u11CC",
  "\u316A",
  "\u11CE",
  "\u316B",
  "\u11D3",
  "\u316C",
  "\u11D7",
  "\u316D",
  "\u11D9",
  "\u316E",
  "\u111C",
  "\u316F",
  "\u11DD",
  "\u3170",
  "\u11DF",
  "\u3171",
  "\u111D",
  "\u3172",
  "\u111E",
  "\u3173",
  "\u1120",
  "\u3174",
  "\u1122",
  "\u3175",
  "\u1123",
  "\u3176",
  "\u1127",
  "\u3177",
  "\u1129",
  "\u3178",
  "\u112B",
  "\u3179",
  "\u112C",
  "\u317A",
  "\u112D",
  "\u317B",
  "\u112E",
  "\u317C",
  "\u112F",
  "\u317D",
  "\u1132",
  "\u317E",
  "\u1136",
  "\u317F",
  "\u1140",
  "\u3180",
  "\u1147",
  "\u3181",
  "\u114C",
  "\u3182",
  "\u11F1",
  "\u3183",
  "\u11F2",
  "\u3184",
  "\u1157",
  "\u3185",
  "\u1158",
  "\u3186",
  "\u1159",
  "\u3187",
  "\u1184",
  "\u3188",
  "\u1185",
  "\u3189",
  "\u1188",
  "\u318A",
  "\u1191",
  "\u318B",
  "\u1192",
  "\u318C",
  "\u1194",
  "\u318D",
  "\u119E",
  "\u318E",
  "\u11A1",
  "\u3200",
  "\u0028\u1100\u0029",
  "\u3201",
  "\u0028\u1102\u0029",
  "\u3202",
  "\u0028\u1103\u0029",
  "\u3203",
  "\u0028\u1105\u0029",
  "\u3204",
  "\u0028\u1106\u0029",
  "\u3205",
  "\u0028\u1107\u0029",
  "\u3206",
  "\u0028\u1109\u0029",
  "\u3207",
  "\u0028\u110B\u0029",
  "\u3208",
  "\u0028\u110C\u0029",
  "\u3209",
  "\u0028\u110E\u0029",
  "\u320A",
  "\u0028\u110F\u0029",
  "\u320B",
  "\u0028\u1110\u0029",
  "\u320C",
  "\u0028\u1111\u0029",
  "\u320D",
  "\u0028\u1112\u0029",
  "\u320E",
  "\u0028\u1100\u1161\u0029",
  "\u320F",
  "\u0028\u1102\u1161\u0029",
  "\u3210",
  "\u0028\u1103\u1161\u0029",
  "\u3211",
  "\u0028\u1105\u1161\u0029",
  "\u3212",
  "\u0028\u1106\u1161\u0029",
  "\u3213",
  "\u0028\u1107\u1161\u0029",
  "\u3214",
  "\u0028\u1109\u1161\u0029",
  "\u3215",
  "\u0028\u110B\u1161\u0029",
  "\u3216",
  "\u0028\u110C\u1161\u0029",
  "\u3217",
  "\u0028\u110E\u1161\u0029",
  "\u3218",
  "\u0028\u110F\u1161\u0029",
  "\u3219",
  "\u0028\u1110\u1161\u0029",
  "\u321A",
  "\u0028\u1111\u1161\u0029",
  "\u321B",
  "\u0028\u1112\u1161\u0029",
  "\u321C",
  "\u0028\u110C\u116E\u0029",
  "\u321D",
  "\u0028\u110B\u1169\u110C\u1165\u11AB\u0029",
  "\u321E",
  "\u0028\u110B\u1169\u1112\u116E\u0029",
  "\u3220",
  "\u0028\u4E00\u0029",
  "\u3221",
  "\u0028\u4E8C\u0029",
  "\u3222",
  "\u0028\u4E09\u0029",
  "\u3223",
  "\u0028\u56DB\u0029",
  "\u3224",
  "\u0028\u4E94\u0029",
  "\u3225",
  "\u0028\u516D\u0029",
  "\u3226",
  "\u0028\u4E03\u0029",
  "\u3227",
  "\u0028\u516B\u0029",
  "\u3228",
  "\u0028\u4E5D\u0029",
  "\u3229",
  "\u0028\u5341\u0029",
  "\u322A",
  "\u0028\u6708\u0029",
  "\u322B",
  "\u0028\u706B\u0029",
  "\u322C",
  "\u0028\u6C34\u0029",
  "\u322D",
  "\u0028\u6728\u0029",
  "\u322E",
  "\u0028\u91D1\u0029",
  "\u322F",
  "\u0028\u571F\u0029",
  "\u3230",
  "\u0028\u65E5\u0029",
  "\u3231",
  "\u0028\u682A\u0029",
  "\u3232",
  "\u0028\u6709\u0029",
  "\u3233",
  "\u0028\u793E\u0029",
  "\u3234",
  "\u0028\u540D\u0029",
  "\u3235",
  "\u0028\u7279\u0029",
  "\u3236",
  "\u0028\u8CA1\u0029",
  "\u3237",
  "\u0028\u795D\u0029",
  "\u3238",
  "\u0028\u52B4\u0029",
  "\u3239",
  "\u0028\u4EE3\u0029",
  "\u323A",
  "\u0028\u547C\u0029",
  "\u323B",
  "\u0028\u5B66\u0029",
  "\u323C",
  "\u0028\u76E3\u0029",
  "\u323D",
  "\u0028\u4F01\u0029",
  "\u323E",
  "\u0028\u8CC7\u0029",
  "\u323F",
  "\u0028\u5354\u0029",
  "\u3240",
  "\u0028\u796D\u0029",
  "\u3241",
  "\u0028\u4F11\u0029",
  "\u3242",
  "\u0028\u81EA\u0029",
  "\u3243",
  "\u0028\u81F3\u0029",
  "\u32C0",
  "\u0031\u6708",
  "\u32C1",
  "\u0032\u6708",
  "\u32C2",
  "\u0033\u6708",
  "\u32C3",
  "\u0034\u6708",
  "\u32C4",
  "\u0035\u6708",
  "\u32C5",
  "\u0036\u6708",
  "\u32C6",
  "\u0037\u6708",
  "\u32C7",
  "\u0038\u6708",
  "\u32C8",
  "\u0039\u6708",
  "\u32C9",
  "\u0031\u0030\u6708",
  "\u32CA",
  "\u0031\u0031\u6708",
  "\u32CB",
  "\u0031\u0032\u6708",
  "\u3358",
  "\u0030\u70B9",
  "\u3359",
  "\u0031\u70B9",
  "\u335A",
  "\u0032\u70B9",
  "\u335B",
  "\u0033\u70B9",
  "\u335C",
  "\u0034\u70B9",
  "\u335D",
  "\u0035\u70B9",
  "\u335E",
  "\u0036\u70B9",
  "\u335F",
  "\u0037\u70B9",
  "\u3360",
  "\u0038\u70B9",
  "\u3361",
  "\u0039\u70B9",
  "\u3362",
  "\u0031\u0030\u70B9",
  "\u3363",
  "\u0031\u0031\u70B9",
  "\u3364",
  "\u0031\u0032\u70B9",
  "\u3365",
  "\u0031\u0033\u70B9",
  "\u3366",
  "\u0031\u0034\u70B9",
  "\u3367",
  "\u0031\u0035\u70B9",
  "\u3368",
  "\u0031\u0036\u70B9",
  "\u3369",
  "\u0031\u0037\u70B9",
  "\u336A",
  "\u0031\u0038\u70B9",
  "\u336B",
  "\u0031\u0039\u70B9",
  "\u336C",
  "\u0032\u0030\u70B9",
  "\u336D",
  "\u0032\u0031\u70B9",
  "\u336E",
  "\u0032\u0032\u70B9",
  "\u336F",
  "\u0032\u0033\u70B9",
  "\u3370",
  "\u0032\u0034\u70B9",
  "\u33E0",
  "\u0031\u65E5",
  "\u33E1",
  "\u0032\u65E5",
  "\u33E2",
  "\u0033\u65E5",
  "\u33E3",
  "\u0034\u65E5",
  "\u33E4",
  "\u0035\u65E5",
  "\u33E5",
  "\u0036\u65E5",
  "\u33E6",
  "\u0037\u65E5",
  "\u33E7",
  "\u0038\u65E5",
  "\u33E8",
  "\u0039\u65E5",
  "\u33E9",
  "\u0031\u0030\u65E5",
  "\u33EA",
  "\u0031\u0031\u65E5",
  "\u33EB",
  "\u0031\u0032\u65E5",
  "\u33EC",
  "\u0031\u0033\u65E5",
  "\u33ED",
  "\u0031\u0034\u65E5",
  "\u33EE",
  "\u0031\u0035\u65E5",
  "\u33EF",
  "\u0031\u0036\u65E5",
  "\u33F0",
  "\u0031\u0037\u65E5",
  "\u33F1",
  "\u0031\u0038\u65E5",
  "\u33F2",
  "\u0031\u0039\u65E5",
  "\u33F3",
  "\u0032\u0030\u65E5",
  "\u33F4",
  "\u0032\u0031\u65E5",
  "\u33F5",
  "\u0032\u0032\u65E5",
  "\u33F6",
  "\u0032\u0033\u65E5",
  "\u33F7",
  "\u0032\u0034\u65E5",
  "\u33F8",
  "\u0032\u0035\u65E5",
  "\u33F9",
  "\u0032\u0036\u65E5",
  "\u33FA",
  "\u0032\u0037\u65E5",
  "\u33FB",
  "\u0032\u0038\u65E5",
  "\u33FC",
  "\u0032\u0039\u65E5",
  "\u33FD",
  "\u0033\u0030\u65E5",
  "\u33FE",
  "\u0033\u0031\u65E5",
  "\uFB00",
  "\u0066\u0066",
  "\uFB01",
  "\u0066\u0069",
  "\uFB02",
  "\u0066\u006C",
  "\uFB03",
  "\u0066\u0066\u0069",
  "\uFB04",
  "\u0066\u0066\u006C",
  "\uFB05",
  "\u017F\u0074",
  "\uFB06",
  "\u0073\u0074",
  "\uFB13",
  "\u0574\u0576",
  "\uFB14",
  "\u0574\u0565",
  "\uFB15",
  "\u0574\u056B",
  "\uFB16",
  "\u057E\u0576",
  "\uFB17",
  "\u0574\u056D",
  "\uFB4F",
  "\u05D0\u05DC",
  "\uFB50",
  "\u0671",
  "\uFB51",
  "\u0671",
  "\uFB52",
  "\u067B",
  "\uFB53",
  "\u067B",
  "\uFB54",
  "\u067B",
  "\uFB55",
  "\u067B",
  "\uFB56",
  "\u067E",
  "\uFB57",
  "\u067E",
  "\uFB58",
  "\u067E",
  "\uFB59",
  "\u067E",
  "\uFB5A",
  "\u0680",
  "\uFB5B",
  "\u0680",
  "\uFB5C",
  "\u0680",
  "\uFB5D",
  "\u0680",
  "\uFB5E",
  "\u067A",
  "\uFB5F",
  "\u067A",
  "\uFB60",
  "\u067A",
  "\uFB61",
  "\u067A",
  "\uFB62",
  "\u067F",
  "\uFB63",
  "\u067F",
  "\uFB64",
  "\u067F",
  "\uFB65",
  "\u067F",
  "\uFB66",
  "\u0679",
  "\uFB67",
  "\u0679",
  "\uFB68",
  "\u0679",
  "\uFB69",
  "\u0679",
  "\uFB6A",
  "\u06A4",
  "\uFB6B",
  "\u06A4",
  "\uFB6C",
  "\u06A4",
  "\uFB6D",
  "\u06A4",
  "\uFB6E",
  "\u06A6",
  "\uFB6F",
  "\u06A6",
  "\uFB70",
  "\u06A6",
  "\uFB71",
  "\u06A6",
  "\uFB72",
  "\u0684",
  "\uFB73",
  "\u0684",
  "\uFB74",
  "\u0684",
  "\uFB75",
  "\u0684",
  "\uFB76",
  "\u0683",
  "\uFB77",
  "\u0683",
  "\uFB78",
  "\u0683",
  "\uFB79",
  "\u0683",
  "\uFB7A",
  "\u0686",
  "\uFB7B",
  "\u0686",
  "\uFB7C",
  "\u0686",
  "\uFB7D",
  "\u0686",
  "\uFB7E",
  "\u0687",
  "\uFB7F",
  "\u0687",
  "\uFB80",
  "\u0687",
  "\uFB81",
  "\u0687",
  "\uFB82",
  "\u068D",
  "\uFB83",
  "\u068D",
  "\uFB84",
  "\u068C",
  "\uFB85",
  "\u068C",
  "\uFB86",
  "\u068E",
  "\uFB87",
  "\u068E",
  "\uFB88",
  "\u0688",
  "\uFB89",
  "\u0688",
  "\uFB8A",
  "\u0698",
  "\uFB8B",
  "\u0698",
  "\uFB8C",
  "\u0691",
  "\uFB8D",
  "\u0691",
  "\uFB8E",
  "\u06A9",
  "\uFB8F",
  "\u06A9",
  "\uFB90",
  "\u06A9",
  "\uFB91",
  "\u06A9",
  "\uFB92",
  "\u06AF",
  "\uFB93",
  "\u06AF",
  "\uFB94",
  "\u06AF",
  "\uFB95",
  "\u06AF",
  "\uFB96",
  "\u06B3",
  "\uFB97",
  "\u06B3",
  "\uFB98",
  "\u06B3",
  "\uFB99",
  "\u06B3",
  "\uFB9A",
  "\u06B1",
  "\uFB9B",
  "\u06B1",
  "\uFB9C",
  "\u06B1",
  "\uFB9D",
  "\u06B1",
  "\uFB9E",
  "\u06BA",
  "\uFB9F",
  "\u06BA",
  "\uFBA0",
  "\u06BB",
  "\uFBA1",
  "\u06BB",
  "\uFBA2",
  "\u06BB",
  "\uFBA3",
  "\u06BB",
  "\uFBA4",
  "\u06C0",
  "\uFBA5",
  "\u06C0",
  "\uFBA6",
  "\u06C1",
  "\uFBA7",
  "\u06C1",
  "\uFBA8",
  "\u06C1",
  "\uFBA9",
  "\u06C1",
  "\uFBAA",
  "\u06BE",
  "\uFBAB",
  "\u06BE",
  "\uFBAC",
  "\u06BE",
  "\uFBAD",
  "\u06BE",
  "\uFBAE",
  "\u06D2",
  "\uFBAF",
  "\u06D2",
  "\uFBB0",
  "\u06D3",
  "\uFBB1",
  "\u06D3",
  "\uFBD3",
  "\u06AD",
  "\uFBD4",
  "\u06AD",
  "\uFBD5",
  "\u06AD",
  "\uFBD6",
  "\u06AD",
  "\uFBD7",
  "\u06C7",
  "\uFBD8",
  "\u06C7",
  "\uFBD9",
  "\u06C6",
  "\uFBDA",
  "\u06C6",
  "\uFBDB",
  "\u06C8",
  "\uFBDC",
  "\u06C8",
  "\uFBDD",
  "\u0677",
  "\uFBDE",
  "\u06CB",
  "\uFBDF",
  "\u06CB",
  "\uFBE0",
  "\u06C5",
  "\uFBE1",
  "\u06C5",
  "\uFBE2",
  "\u06C9",
  "\uFBE3",
  "\u06C9",
  "\uFBE4",
  "\u06D0",
  "\uFBE5",
  "\u06D0",
  "\uFBE6",
  "\u06D0",
  "\uFBE7",
  "\u06D0",
  "\uFBE8",
  "\u0649",
  "\uFBE9",
  "\u0649",
  "\uFBEA",
  "\u0626\u0627",
  "\uFBEB",
  "\u0626\u0627",
  "\uFBEC",
  "\u0626\u06D5",
  "\uFBED",
  "\u0626\u06D5",
  "\uFBEE",
  "\u0626\u0648",
  "\uFBEF",
  "\u0626\u0648",
  "\uFBF0",
  "\u0626\u06C7",
  "\uFBF1",
  "\u0626\u06C7",
  "\uFBF2",
  "\u0626\u06C6",
  "\uFBF3",
  "\u0626\u06C6",
  "\uFBF4",
  "\u0626\u06C8",
  "\uFBF5",
  "\u0626\u06C8",
  "\uFBF6",
  "\u0626\u06D0",
  "\uFBF7",
  "\u0626\u06D0",
  "\uFBF8",
  "\u0626\u06D0",
  "\uFBF9",
  "\u0626\u0649",
  "\uFBFA",
  "\u0626\u0649",
  "\uFBFB",
  "\u0626\u0649",
  "\uFBFC",
  "\u06CC",
  "\uFBFD",
  "\u06CC",
  "\uFBFE",
  "\u06CC",
  "\uFBFF",
  "\u06CC",
  "\uFC00",
  "\u0626\u062C",
  "\uFC01",
  "\u0626\u062D",
  "\uFC02",
  "\u0626\u0645",
  "\uFC03",
  "\u0626\u0649",
  "\uFC04",
  "\u0626\u064A",
  "\uFC05",
  "\u0628\u062C",
  "\uFC06",
  "\u0628\u062D",
  "\uFC07",
  "\u0628\u062E",
  "\uFC08",
  "\u0628\u0645",
  "\uFC09",
  "\u0628\u0649",
  "\uFC0A",
  "\u0628\u064A",
  "\uFC0B",
  "\u062A\u062C",
  "\uFC0C",
  "\u062A\u062D",
  "\uFC0D",
  "\u062A\u062E",
  "\uFC0E",
  "\u062A\u0645",
  "\uFC0F",
  "\u062A\u0649",
  "\uFC10",
  "\u062A\u064A",
  "\uFC11",
  "\u062B\u062C",
  "\uFC12",
  "\u062B\u0645",
  "\uFC13",
  "\u062B\u0649",
  "\uFC14",
  "\u062B\u064A",
  "\uFC15",
  "\u062C\u062D",
  "\uFC16",
  "\u062C\u0645",
  "\uFC17",
  "\u062D\u062C",
  "\uFC18",
  "\u062D\u0645",
  "\uFC19",
  "\u062E\u062C",
  "\uFC1A",
  "\u062E\u062D",
  "\uFC1B",
  "\u062E\u0645",
  "\uFC1C",
  "\u0633\u062C",
  "\uFC1D",
  "\u0633\u062D",
  "\uFC1E",
  "\u0633\u062E",
  "\uFC1F",
  "\u0633\u0645",
  "\uFC20",
  "\u0635\u062D",
  "\uFC21",
  "\u0635\u0645",
  "\uFC22",
  "\u0636\u062C",
  "\uFC23",
  "\u0636\u062D",
  "\uFC24",
  "\u0636\u062E",
  "\uFC25",
  "\u0636\u0645",
  "\uFC26",
  "\u0637\u062D",
  "\uFC27",
  "\u0637\u0645",
  "\uFC28",
  "\u0638\u0645",
  "\uFC29",
  "\u0639\u062C",
  "\uFC2A",
  "\u0639\u0645",
  "\uFC2B",
  "\u063A\u062C",
  "\uFC2C",
  "\u063A\u0645",
  "\uFC2D",
  "\u0641\u062C",
  "\uFC2E",
  "\u0641\u062D",
  "\uFC2F",
  "\u0641\u062E",
  "\uFC30",
  "\u0641\u0645",
  "\uFC31",
  "\u0641\u0649",
  "\uFC32",
  "\u0641\u064A",
  "\uFC33",
  "\u0642\u062D",
  "\uFC34",
  "\u0642\u0645",
  "\uFC35",
  "\u0642\u0649",
  "\uFC36",
  "\u0642\u064A",
  "\uFC37",
  "\u0643\u0627",
  "\uFC38",
  "\u0643\u062C",
  "\uFC39",
  "\u0643\u062D",
  "\uFC3A",
  "\u0643\u062E",
  "\uFC3B",
  "\u0643\u0644",
  "\uFC3C",
  "\u0643\u0645",
  "\uFC3D",
  "\u0643\u0649",
  "\uFC3E",
  "\u0643\u064A",
  "\uFC3F",
  "\u0644\u062C",
  "\uFC40",
  "\u0644\u062D",
  "\uFC41",
  "\u0644\u062E",
  "\uFC42",
  "\u0644\u0645",
  "\uFC43",
  "\u0644\u0649",
  "\uFC44",
  "\u0644\u064A",
  "\uFC45",
  "\u0645\u062C",
  "\uFC46",
  "\u0645\u062D",
  "\uFC47",
  "\u0645\u062E",
  "\uFC48",
  "\u0645\u0645",
  "\uFC49",
  "\u0645\u0649",
  "\uFC4A",
  "\u0645\u064A",
  "\uFC4B",
  "\u0646\u062C",
  "\uFC4C",
  "\u0646\u062D",
  "\uFC4D",
  "\u0646\u062E",
  "\uFC4E",
  "\u0646\u0645",
  "\uFC4F",
  "\u0646\u0649",
  "\uFC50",
  "\u0646\u064A",
  "\uFC51",
  "\u0647\u062C",
  "\uFC52",
  "\u0647\u0645",
  "\uFC53",
  "\u0647\u0649",
  "\uFC54",
  "\u0647\u064A",
  "\uFC55",
  "\u064A\u062C",
  "\uFC56",
  "\u064A\u062D",
  "\uFC57",
  "\u064A\u062E",
  "\uFC58",
  "\u064A\u0645",
  "\uFC59",
  "\u064A\u0649",
  "\uFC5A",
  "\u064A\u064A",
  "\uFC5B",
  "\u0630\u0670",
  "\uFC5C",
  "\u0631\u0670",
  "\uFC5D",
  "\u0649\u0670",
  "\uFC5E",
  "\u0020\u064C\u0651",
  "\uFC5F",
  "\u0020\u064D\u0651",
  "\uFC60",
  "\u0020\u064E\u0651",
  "\uFC61",
  "\u0020\u064F\u0651",
  "\uFC62",
  "\u0020\u0650\u0651",
  "\uFC63",
  "\u0020\u0651\u0670",
  "\uFC64",
  "\u0626\u0631",
  "\uFC65",
  "\u0626\u0632",
  "\uFC66",
  "\u0626\u0645",
  "\uFC67",
  "\u0626\u0646",
  "\uFC68",
  "\u0626\u0649",
  "\uFC69",
  "\u0626\u064A",
  "\uFC6A",
  "\u0628\u0631",
  "\uFC6B",
  "\u0628\u0632",
  "\uFC6C",
  "\u0628\u0645",
  "\uFC6D",
  "\u0628\u0646",
  "\uFC6E",
  "\u0628\u0649",
  "\uFC6F",
  "\u0628\u064A",
  "\uFC70",
  "\u062A\u0631",
  "\uFC71",
  "\u062A\u0632",
  "\uFC72",
  "\u062A\u0645",
  "\uFC73",
  "\u062A\u0646",
  "\uFC74",
  "\u062A\u0649",
  "\uFC75",
  "\u062A\u064A",
  "\uFC76",
  "\u062B\u0631",
  "\uFC77",
  "\u062B\u0632",
  "\uFC78",
  "\u062B\u0645",
  "\uFC79",
  "\u062B\u0646",
  "\uFC7A",
  "\u062B\u0649",
  "\uFC7B",
  "\u062B\u064A",
  "\uFC7C",
  "\u0641\u0649",
  "\uFC7D",
  "\u0641\u064A",
  "\uFC7E",
  "\u0642\u0649",
  "\uFC7F",
  "\u0642\u064A",
  "\uFC80",
  "\u0643\u0627",
  "\uFC81",
  "\u0643\u0644",
  "\uFC82",
  "\u0643\u0645",
  "\uFC83",
  "\u0643\u0649",
  "\uFC84",
  "\u0643\u064A",
  "\uFC85",
  "\u0644\u0645",
  "\uFC86",
  "\u0644\u0649",
  "\uFC87",
  "\u0644\u064A",
  "\uFC88",
  "\u0645\u0627",
  "\uFC89",
  "\u0645\u0645",
  "\uFC8A",
  "\u0646\u0631",
  "\uFC8B",
  "\u0646\u0632",
  "\uFC8C",
  "\u0646\u0645",
  "\uFC8D",
  "\u0646\u0646",
  "\uFC8E",
  "\u0646\u0649",
  "\uFC8F",
  "\u0646\u064A",
  "\uFC90",
  "\u0649\u0670",
  "\uFC91",
  "\u064A\u0631",
  "\uFC92",
  "\u064A\u0632",
  "\uFC93",
  "\u064A\u0645",
  "\uFC94",
  "\u064A\u0646",
  "\uFC95",
  "\u064A\u0649",
  "\uFC96",
  "\u064A\u064A",
  "\uFC97",
  "\u0626\u062C",
  "\uFC98",
  "\u0626\u062D",
  "\uFC99",
  "\u0626\u062E",
  "\uFC9A",
  "\u0626\u0645",
  "\uFC9B",
  "\u0626\u0647",
  "\uFC9C",
  "\u0628\u062C",
  "\uFC9D",
  "\u0628\u062D",
  "\uFC9E",
  "\u0628\u062E",
  "\uFC9F",
  "\u0628\u0645",
  "\uFCA0",
  "\u0628\u0647",
  "\uFCA1",
  "\u062A\u062C",
  "\uFCA2",
  "\u062A\u062D",
  "\uFCA3",
  "\u062A\u062E",
  "\uFCA4",
  "\u062A\u0645",
  "\uFCA5",
  "\u062A\u0647",
  "\uFCA6",
  "\u062B\u0645",
  "\uFCA7",
  "\u062C\u062D",
  "\uFCA8",
  "\u062C\u0645",
  "\uFCA9",
  "\u062D\u062C",
  "\uFCAA",
  "\u062D\u0645",
  "\uFCAB",
  "\u062E\u062C",
  "\uFCAC",
  "\u062E\u0645",
  "\uFCAD",
  "\u0633\u062C",
  "\uFCAE",
  "\u0633\u062D",
  "\uFCAF",
  "\u0633\u062E",
  "\uFCB0",
  "\u0633\u0645",
  "\uFCB1",
  "\u0635\u062D",
  "\uFCB2",
  "\u0635\u062E",
  "\uFCB3",
  "\u0635\u0645",
  "\uFCB4",
  "\u0636\u062C",
  "\uFCB5",
  "\u0636\u062D",
  "\uFCB6",
  "\u0636\u062E",
  "\uFCB7",
  "\u0636\u0645",
  "\uFCB8",
  "\u0637\u062D",
  "\uFCB9",
  "\u0638\u0645",
  "\uFCBA",
  "\u0639\u062C",
  "\uFCBB",
  "\u0639\u0645",
  "\uFCBC",
  "\u063A\u062C",
  "\uFCBD",
  "\u063A\u0645",
  "\uFCBE",
  "\u0641\u062C",
  "\uFCBF",
  "\u0641\u062D",
  "\uFCC0",
  "\u0641\u062E",
  "\uFCC1",
  "\u0641\u0645",
  "\uFCC2",
  "\u0642\u062D",
  "\uFCC3",
  "\u0642\u0645",
  "\uFCC4",
  "\u0643\u062C",
  "\uFCC5",
  "\u0643\u062D",
  "\uFCC6",
  "\u0643\u062E",
  "\uFCC7",
  "\u0643\u0644",
  "\uFCC8",
  "\u0643\u0645",
  "\uFCC9",
  "\u0644\u062C",
  "\uFCCA",
  "\u0644\u062D",
  "\uFCCB",
  "\u0644\u062E",
  "\uFCCC",
  "\u0644\u0645",
  "\uFCCD",
  "\u0644\u0647",
  "\uFCCE",
  "\u0645\u062C",
  "\uFCCF",
  "\u0645\u062D",
  "\uFCD0",
  "\u0645\u062E",
  "\uFCD1",
  "\u0645\u0645",
  "\uFCD2",
  "\u0646\u062C",
  "\uFCD3",
  "\u0646\u062D",
  "\uFCD4",
  "\u0646\u062E",
  "\uFCD5",
  "\u0646\u0645",
  "\uFCD6",
  "\u0646\u0647",
  "\uFCD7",
  "\u0647\u062C",
  "\uFCD8",
  "\u0647\u0645",
  "\uFCD9",
  "\u0647\u0670",
  "\uFCDA",
  "\u064A\u062C",
  "\uFCDB",
  "\u064A\u062D",
  "\uFCDC",
  "\u064A\u062E",
  "\uFCDD",
  "\u064A\u0645",
  "\uFCDE",
  "\u064A\u0647",
  "\uFCDF",
  "\u0626\u0645",
  "\uFCE0",
  "\u0626\u0647",
  "\uFCE1",
  "\u0628\u0645",
  "\uFCE2",
  "\u0628\u0647",
  "\uFCE3",
  "\u062A\u0645",
  "\uFCE4",
  "\u062A\u0647",
  "\uFCE5",
  "\u062B\u0645",
  "\uFCE6",
  "\u062B\u0647",
  "\uFCE7",
  "\u0633\u0645",
  "\uFCE8",
  "\u0633\u0647",
  "\uFCE9",
  "\u0634\u0645",
  "\uFCEA",
  "\u0634\u0647",
  "\uFCEB",
  "\u0643\u0644",
  "\uFCEC",
  "\u0643\u0645",
  "\uFCED",
  "\u0644\u0645",
  "\uFCEE",
  "\u0646\u0645",
  "\uFCEF",
  "\u0646\u0647",
  "\uFCF0",
  "\u064A\u0645",
  "\uFCF1",
  "\u064A\u0647",
  "\uFCF2",
  "\u0640\u064E\u0651",
  "\uFCF3",
  "\u0640\u064F\u0651",
  "\uFCF4",
  "\u0640\u0650\u0651",
  "\uFCF5",
  "\u0637\u0649",
  "\uFCF6",
  "\u0637\u064A",
  "\uFCF7",
  "\u0639\u0649",
  "\uFCF8",
  "\u0639\u064A",
  "\uFCF9",
  "\u063A\u0649",
  "\uFCFA",
  "\u063A\u064A",
  "\uFCFB",
  "\u0633\u0649",
  "\uFCFC",
  "\u0633\u064A",
  "\uFCFD",
  "\u0634\u0649",
  "\uFCFE",
  "\u0634\u064A",
  "\uFCFF",
  "\u062D\u0649",
  "\uFD00",
  "\u062D\u064A",
  "\uFD01",
  "\u062C\u0649",
  "\uFD02",
  "\u062C\u064A",
  "\uFD03",
  "\u062E\u0649",
  "\uFD04",
  "\u062E\u064A",
  "\uFD05",
  "\u0635\u0649",
  "\uFD06",
  "\u0635\u064A",
  "\uFD07",
  "\u0636\u0649",
  "\uFD08",
  "\u0636\u064A",
  "\uFD09",
  "\u0634\u062C",
  "\uFD0A",
  "\u0634\u062D",
  "\uFD0B",
  "\u0634\u062E",
  "\uFD0C",
  "\u0634\u0645",
  "\uFD0D",
  "\u0634\u0631",
  "\uFD0E",
  "\u0633\u0631",
  "\uFD0F",
  "\u0635\u0631",
  "\uFD10",
  "\u0636\u0631",
  "\uFD11",
  "\u0637\u0649",
  "\uFD12",
  "\u0637\u064A",
  "\uFD13",
  "\u0639\u0649",
  "\uFD14",
  "\u0639\u064A",
  "\uFD15",
  "\u063A\u0649",
  "\uFD16",
  "\u063A\u064A",
  "\uFD17",
  "\u0633\u0649",
  "\uFD18",
  "\u0633\u064A",
  "\uFD19",
  "\u0634\u0649",
  "\uFD1A",
  "\u0634\u064A",
  "\uFD1B",
  "\u062D\u0649",
  "\uFD1C",
  "\u062D\u064A",
  "\uFD1D",
  "\u062C\u0649",
  "\uFD1E",
  "\u062C\u064A",
  "\uFD1F",
  "\u062E\u0649",
  "\uFD20",
  "\u062E\u064A",
  "\uFD21",
  "\u0635\u0649",
  "\uFD22",
  "\u0635\u064A",
  "\uFD23",
  "\u0636\u0649",
  "\uFD24",
  "\u0636\u064A",
  "\uFD25",
  "\u0634\u062C",
  "\uFD26",
  "\u0634\u062D",
  "\uFD27",
  "\u0634\u062E",
  "\uFD28",
  "\u0634\u0645",
  "\uFD29",
  "\u0634\u0631",
  "\uFD2A",
  "\u0633\u0631",
  "\uFD2B",
  "\u0635\u0631",
  "\uFD2C",
  "\u0636\u0631",
  "\uFD2D",
  "\u0634\u062C",
  "\uFD2E",
  "\u0634\u062D",
  "\uFD2F",
  "\u0634\u062E",
  "\uFD30",
  "\u0634\u0645",
  "\uFD31",
  "\u0633\u0647",
  "\uFD32",
  "\u0634\u0647",
  "\uFD33",
  "\u0637\u0645",
  "\uFD34",
  "\u0633\u062C",
  "\uFD35",
  "\u0633\u062D",
  "\uFD36",
  "\u0633\u062E",
  "\uFD37",
  "\u0634\u062C",
  "\uFD38",
  "\u0634\u062D",
  "\uFD39",
  "\u0634\u062E",
  "\uFD3A",
  "\u0637\u0645",
  "\uFD3B",
  "\u0638\u0645",
  "\uFD3C",
  "\u0627\u064B",
  "\uFD3D",
  "\u0627\u064B",
  "\uFD50",
  "\u062A\u062C\u0645",
  "\uFD51",
  "\u062A\u062D\u062C",
  "\uFD52",
  "\u062A\u062D\u062C",
  "\uFD53",
  "\u062A\u062D\u0645",
  "\uFD54",
  "\u062A\u062E\u0645",
  "\uFD55",
  "\u062A\u0645\u062C",
  "\uFD56",
  "\u062A\u0645\u062D",
  "\uFD57",
  "\u062A\u0645\u062E",
  "\uFD58",
  "\u062C\u0645\u062D",
  "\uFD59",
  "\u062C\u0645\u062D",
  "\uFD5A",
  "\u062D\u0645\u064A",
  "\uFD5B",
  "\u062D\u0645\u0649",
  "\uFD5C",
  "\u0633\u062D\u062C",
  "\uFD5D",
  "\u0633\u062C\u062D",
  "\uFD5E",
  "\u0633\u062C\u0649",
  "\uFD5F",
  "\u0633\u0645\u062D",
  "\uFD60",
  "\u0633\u0645\u062D",
  "\uFD61",
  "\u0633\u0645\u062C",
  "\uFD62",
  "\u0633\u0645\u0645",
  "\uFD63",
  "\u0633\u0645\u0645",
  "\uFD64",
  "\u0635\u062D\u062D",
  "\uFD65",
  "\u0635\u062D\u062D",
  "\uFD66",
  "\u0635\u0645\u0645",
  "\uFD67",
  "\u0634\u062D\u0645",
  "\uFD68",
  "\u0634\u062D\u0645",
  "\uFD69",
  "\u0634\u062C\u064A",
  "\uFD6A",
  "\u0634\u0645\u062E",
  "\uFD6B",
  "\u0634\u0645\u062E",
  "\uFD6C",
  "\u0634\u0645\u0645",
  "\uFD6D",
  "\u0634\u0645\u0645",
  "\uFD6E",
  "\u0636\u062D\u0649",
  "\uFD6F",
  "\u0636\u062E\u0645",
  "\uFD70",
  "\u0636\u062E\u0645",
  "\uFD71",
  "\u0637\u0645\u062D",
  "\uFD72",
  "\u0637\u0645\u062D",
  "\uFD73",
  "\u0637\u0645\u0645",
  "\uFD74",
  "\u0637\u0645\u064A",
  "\uFD75",
  "\u0639\u062C\u0645",
  "\uFD76",
  "\u0639\u0645\u0645",
  "\uFD77",
  "\u0639\u0645\u0645",
  "\uFD78",
  "\u0639\u0645\u0649",
  "\uFD79",
  "\u063A\u0645\u0645",
  "\uFD7A",
  "\u063A\u0645\u064A",
  "\uFD7B",
  "\u063A\u0645\u0649",
  "\uFD7C",
  "\u0641\u062E\u0645",
  "\uFD7D",
  "\u0641\u062E\u0645",
  "\uFD7E",
  "\u0642\u0645\u062D",
  "\uFD7F",
  "\u0642\u0645\u0645",
  "\uFD80",
  "\u0644\u062D\u0645",
  "\uFD81",
  "\u0644\u062D\u064A",
  "\uFD82",
  "\u0644\u062D\u0649",
  "\uFD83",
  "\u0644\u062C\u062C",
  "\uFD84",
  "\u0644\u062C\u062C",
  "\uFD85",
  "\u0644\u062E\u0645",
  "\uFD86",
  "\u0644\u062E\u0645",
  "\uFD87",
  "\u0644\u0645\u062D",
  "\uFD88",
  "\u0644\u0645\u062D",
  "\uFD89",
  "\u0645\u062D\u062C",
  "\uFD8A",
  "\u0645\u062D\u0645",
  "\uFD8B",
  "\u0645\u062D\u064A",
  "\uFD8C",
  "\u0645\u062C\u062D",
  "\uFD8D",
  "\u0645\u062C\u0645",
  "\uFD8E",
  "\u0645\u062E\u062C",
  "\uFD8F",
  "\u0645\u062E\u0645",
  "\uFD92",
  "\u0645\u062C\u062E",
  "\uFD93",
  "\u0647\u0645\u062C",
  "\uFD94",
  "\u0647\u0645\u0645",
  "\uFD95",
  "\u0646\u062D\u0645",
  "\uFD96",
  "\u0646\u062D\u0649",
  "\uFD97",
  "\u0646\u062C\u0645",
  "\uFD98",
  "\u0646\u062C\u0645",
  "\uFD99",
  "\u0646\u062C\u0649",
  "\uFD9A",
  "\u0646\u0645\u064A",
  "\uFD9B",
  "\u0646\u0645\u0649",
  "\uFD9C",
  "\u064A\u0645\u0645",
  "\uFD9D",
  "\u064A\u0645\u0645",
  "\uFD9E",
  "\u0628\u062E\u064A",
  "\uFD9F",
  "\u062A\u062C\u064A",
  "\uFDA0",
  "\u062A\u062C\u0649",
  "\uFDA1",
  "\u062A\u062E\u064A",
  "\uFDA2",
  "\u062A\u062E\u0649",
  "\uFDA3",
  "\u062A\u0645\u064A",
  "\uFDA4",
  "\u062A\u0645\u0649",
  "\uFDA5",
  "\u062C\u0645\u064A",
  "\uFDA6",
  "\u062C\u062D\u0649",
  "\uFDA7",
  "\u062C\u0645\u0649",
  "\uFDA8",
  "\u0633\u062E\u0649",
  "\uFDA9",
  "\u0635\u062D\u064A",
  "\uFDAA",
  "\u0634\u062D\u064A",
  "\uFDAB",
  "\u0636\u062D\u064A",
  "\uFDAC",
  "\u0644\u062C\u064A",
  "\uFDAD",
  "\u0644\u0645\u064A",
  "\uFDAE",
  "\u064A\u062D\u064A",
  "\uFDAF",
  "\u064A\u062C\u064A",
  "\uFDB0",
  "\u064A\u0645\u064A",
  "\uFDB1",
  "\u0645\u0645\u064A",
  "\uFDB2",
  "\u0642\u0645\u064A",
  "\uFDB3",
  "\u0646\u062D\u064A",
  "\uFDB4",
  "\u0642\u0645\u062D",
  "\uFDB5",
  "\u0644\u062D\u0645",
  "\uFDB6",
  "\u0639\u0645\u064A",
  "\uFDB7",
  "\u0643\u0645\u064A",
  "\uFDB8",
  "\u0646\u062C\u062D",
  "\uFDB9",
  "\u0645\u062E\u064A",
  "\uFDBA",
  "\u0644\u062C\u0645",
  "\uFDBB",
  "\u0643\u0645\u0645",
  "\uFDBC",
  "\u0644\u062C\u0645",
  "\uFDBD",
  "\u0646\u062C\u062D",
  "\uFDBE",
  "\u062C\u062D\u064A",
  "\uFDBF",
  "\u062D\u062C\u064A",
  "\uFDC0",
  "\u0645\u062C\u064A",
  "\uFDC1",
  "\u0641\u0645\u064A",
  "\uFDC2",
  "\u0628\u062D\u064A",
  "\uFDC3",
  "\u0643\u0645\u0645",
  "\uFDC4",
  "\u0639\u062C\u0645",
  "\uFDC5",
  "\u0635\u0645\u0645",
  "\uFDC6",
  "\u0633\u062E\u064A",
  "\uFDC7",
  "\u0646\u062C\u064A",
  "\uFE49",
  "\u203E",
  "\uFE4A",
  "\u203E",
  "\uFE4B",
  "\u203E",
  "\uFE4C",
  "\u203E",
  "\uFE4D",
  "\u005F",
  "\uFE4E",
  "\u005F",
  "\uFE4F",
  "\u005F",
  "\uFE80",
  "\u0621",
  "\uFE81",
  "\u0622",
  "\uFE82",
  "\u0622",
  "\uFE83",
  "\u0623",
  "\uFE84",
  "\u0623",
  "\uFE85",
  "\u0624",
  "\uFE86",
  "\u0624",
  "\uFE87",
  "\u0625",
  "\uFE88",
  "\u0625",
  "\uFE89",
  "\u0626",
  "\uFE8A",
  "\u0626",
  "\uFE8B",
  "\u0626",
  "\uFE8C",
  "\u0626",
  "\uFE8D",
  "\u0627",
  "\uFE8E",
  "\u0627",
  "\uFE8F",
  "\u0628",
  "\uFE90",
  "\u0628",
  "\uFE91",
  "\u0628",
  "\uFE92",
  "\u0628",
  "\uFE93",
  "\u0629",
  "\uFE94",
  "\u0629",
  "\uFE95",
  "\u062A",
  "\uFE96",
  "\u062A",
  "\uFE97",
  "\u062A",
  "\uFE98",
  "\u062A",
  "\uFE99",
  "\u062B",
  "\uFE9A",
  "\u062B",
  "\uFE9B",
  "\u062B",
  "\uFE9C",
  "\u062B",
  "\uFE9D",
  "\u062C",
  "\uFE9E",
  "\u062C",
  "\uFE9F",
  "\u062C",
  "\uFEA0",
  "\u062C",
  "\uFEA1",
  "\u062D",
  "\uFEA2",
  "\u062D",
  "\uFEA3",
  "\u062D",
  "\uFEA4",
  "\u062D",
  "\uFEA5",
  "\u062E",
  "\uFEA6",
  "\u062E",
  "\uFEA7",
  "\u062E",
  "\uFEA8",
  "\u062E",
  "\uFEA9",
  "\u062F",
  "\uFEAA",
  "\u062F",
  "\uFEAB",
  "\u0630",
  "\uFEAC",
  "\u0630",
  "\uFEAD",
  "\u0631",
  "\uFEAE",
  "\u0631",
  "\uFEAF",
  "\u0632",
  "\uFEB0",
  "\u0632",
  "\uFEB1",
  "\u0633",
  "\uFEB2",
  "\u0633",
  "\uFEB3",
  "\u0633",
  "\uFEB4",
  "\u0633",
  "\uFEB5",
  "\u0634",
  "\uFEB6",
  "\u0634",
  "\uFEB7",
  "\u0634",
  "\uFEB8",
  "\u0634",
  "\uFEB9",
  "\u0635",
  "\uFEBA",
  "\u0635",
  "\uFEBB",
  "\u0635",
  "\uFEBC",
  "\u0635",
  "\uFEBD",
  "\u0636",
  "\uFEBE",
  "\u0636",
  "\uFEBF",
  "\u0636",
  "\uFEC0",
  "\u0636",
  "\uFEC1",
  "\u0637",
  "\uFEC2",
  "\u0637",
  "\uFEC3",
  "\u0637",
  "\uFEC4",
  "\u0637",
  "\uFEC5",
  "\u0638",
  "\uFEC6",
  "\u0638",
  "\uFEC7",
  "\u0638",
  "\uFEC8",
  "\u0638",
  "\uFEC9",
  "\u0639",
  "\uFECA",
  "\u0639",
  "\uFECB",
  "\u0639",
  "\uFECC",
  "\u0639",
  "\uFECD",
  "\u063A",
  "\uFECE",
  "\u063A",
  "\uFECF",
  "\u063A",
  "\uFED0",
  "\u063A",
  "\uFED1",
  "\u0641",
  "\uFED2",
  "\u0641",
  "\uFED3",
  "\u0641",
  "\uFED4",
  "\u0641",
  "\uFED5",
  "\u0642",
  "\uFED6",
  "\u0642",
  "\uFED7",
  "\u0642",
  "\uFED8",
  "\u0642",
  "\uFED9",
  "\u0643",
  "\uFEDA",
  "\u0643",
  "\uFEDB",
  "\u0643",
  "\uFEDC",
  "\u0643",
  "\uFEDD",
  "\u0644",
  "\uFEDE",
  "\u0644",
  "\uFEDF",
  "\u0644",
  "\uFEE0",
  "\u0644",
  "\uFEE1",
  "\u0645",
  "\uFEE2",
  "\u0645",
  "\uFEE3",
  "\u0645",
  "\uFEE4",
  "\u0645",
  "\uFEE5",
  "\u0646",
  "\uFEE6",
  "\u0646",
  "\uFEE7",
  "\u0646",
  "\uFEE8",
  "\u0646",
  "\uFEE9",
  "\u0647",
  "\uFEEA",
  "\u0647",
  "\uFEEB",
  "\u0647",
  "\uFEEC",
  "\u0647",
  "\uFEED",
  "\u0648",
  "\uFEEE",
  "\u0648",
  "\uFEEF",
  "\u0649",
  "\uFEF0",
  "\u0649",
  "\uFEF1",
  "\u064A",
  "\uFEF2",
  "\u064A",
  "\uFEF3",
  "\u064A",
  "\uFEF4",
  "\u064A",
  "\uFEF5",
  "\u0644\u0622",
  "\uFEF6",
  "\u0644\u0622",
  "\uFEF7",
  "\u0644\u0623",
  "\uFEF8",
  "\u0644\u0623",
  "\uFEF9",
  "\u0644\u0625",
  "\uFEFA",
  "\u0644\u0625",
  "\uFEFB",
  "\u0644\u0627",
  "\uFEFC",
  "\u0644\u0627"
 ];
});
function reverseIfRtl(chars) {
 var charsLength = chars.length;
 if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
  return chars;
 }
 var s = "";
 for (var ii = charsLength - 1; ii >= 0; ii--) {
  s += chars[ii];
 }
 return s;
}


/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontRendererFactory = void 0;

var _util = __w_pdfjs_require__(4);

var _cff_parser = __w_pdfjs_require__(160);

var _glyphlist = __w_pdfjs_require__(163);

var _encodings = __w_pdfjs_require__(162);

var _stream = __w_pdfjs_require__(142);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FontRendererFactory = function FontRendererFactoryClosure() {
  function getLong(data, offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
  }

  function getUshort(data, offset) {
    return data[offset] << 8 | data[offset + 1];
  }

  function getSubroutineBias(subrs) {
    var numSubrs = subrs.length;
    var bias = 32768;

    if (numSubrs < 1240) {
      bias = 107;
    } else if (numSubrs < 33900) {
      bias = 1131;
    }

    return bias;
  }

  function parseCmap(data, start, end) {
    var offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
    var format = getUshort(data, start + offset);
    var ranges, p, i;

    if (format === 4) {
      getUshort(data, start + offset + 2);
      var segCount = getUshort(data, start + offset + 6) >> 1;
      p = start + offset + 14;
      ranges = [];

      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i] = {
          end: getUshort(data, p)
        };
      }

      p += 2;

      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i].start = getUshort(data, p);
      }

      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i].idDelta = getUshort(data, p);
      }

      for (i = 0; i < segCount; i++, p += 2) {
        var idOffset = getUshort(data, p);

        if (idOffset === 0) {
          continue;
        }

        ranges[i].ids = [];

        for (var j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
          ranges[i].ids[j] = getUshort(data, p + idOffset);
          idOffset += 2;
        }
      }

      return ranges;
    } else if (format === 12) {
      getLong(data, start + offset + 4);
      var groups = getLong(data, start + offset + 12);
      p = start + offset + 16;
      ranges = [];

      for (i = 0; i < groups; i++) {
        ranges.push({
          start: getLong(data, p),
          end: getLong(data, p + 4),
          idDelta: getLong(data, p + 8) - getLong(data, p)
        });
        p += 12;
      }

      return ranges;
    }

    throw new _util.FormatError("unsupported cmap: ".concat(format));
  }

  function parseCff(data, start, end, seacAnalysisEnabled) {
    var properties = {};
    var parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
    var cff = parser.parse();
    return {
      glyphs: cff.charStrings.objects,
      subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
      gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
      isCFFCIDFont: cff.isCIDFont,
      fdSelect: cff.fdSelect,
      fdArray: cff.fdArray
    };
  }

  function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
    var itemSize, itemDecode;

    if (isGlyphLocationsLong) {
      itemSize = 4;

      itemDecode = function fontItemDecodeLong(data, offset) {
        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
      };
    } else {
      itemSize = 2;

      itemDecode = function fontItemDecode(data, offset) {
        return data[offset] << 9 | data[offset + 1] << 1;
      };
    }

    var glyphs = [];
    var startOffset = itemDecode(loca, 0);

    for (var j = itemSize; j < loca.length; j += itemSize) {
      var endOffset = itemDecode(loca, j);
      glyphs.push(glyf.subarray(startOffset, endOffset));
      startOffset = endOffset;
    }

    return glyphs;
  }

  function lookupCmap(ranges, unicode) {
    var code = unicode.codePointAt(0),
        gid = 0;
    var l = 0,
        r = ranges.length - 1;

    while (l < r) {
      var c = l + r + 1 >> 1;

      if (code < ranges[c].start) {
        r = c - 1;
      } else {
        l = c;
      }
    }

    if (ranges[l].start <= code && code <= ranges[l].end) {
      gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xffff;
    }

    return {
      charCode: code,
      glyphId: gid
    };
  }

  function compileGlyf(code, cmds, font) {
    function moveTo(x, y) {
      cmds.push({
        cmd: "moveTo",
        args: [x, y]
      });
    }

    function lineTo(x, y) {
      cmds.push({
        cmd: "lineTo",
        args: [x, y]
      });
    }

    function quadraticCurveTo(xa, ya, x, y) {
      cmds.push({
        cmd: "quadraticCurveTo",
        args: [xa, ya, x, y]
      });
    }

    var i = 0;
    var numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
    var flags;
    var x = 0,
        y = 0;
    i += 10;

    if (numberOfContours < 0) {
      do {
        flags = code[i] << 8 | code[i + 1];
        var glyphIndex = code[i + 2] << 8 | code[i + 3];
        i += 4;
        var arg1, arg2;

        if (flags & 0x01) {
          arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
          arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
          i += 4;
        } else {
          arg1 = code[i++];
          arg2 = code[i++];
        }

        if (flags & 0x02) {
          x = arg1;
          y = arg2;
        } else {
          x = 0;
          y = 0;
        }

        var scaleX = 1,
            scaleY = 1,
            scale01 = 0,
            scale10 = 0;

        if (flags & 0x08) {
          scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          i += 2;
        } else if (flags & 0x40) {
          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
          i += 4;
        } else if (flags & 0x80) {
          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
          scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
          scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
          i += 8;
        }

        var subglyph = font.glyphs[glyphIndex];

        if (subglyph) {
          cmds.push({
            cmd: "save"
          });
          cmds.push({
            cmd: "transform",
            args: [scaleX, scale01, scale10, scaleY, x, y]
          });
          compileGlyf(subglyph, cmds, font);
          cmds.push({
            cmd: "restore"
          });
        }
      } while (flags & 0x20);
    } else {
      var endPtsOfContours = [];
      var j, jj;

      for (j = 0; j < numberOfContours; j++) {
        endPtsOfContours.push(code[i] << 8 | code[i + 1]);
        i += 2;
      }

      var instructionLength = code[i] << 8 | code[i + 1];
      i += 2 + instructionLength;
      var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
      var points = [];

      while (points.length < numberOfPoints) {
        flags = code[i++];
        var repeat = 1;

        if (flags & 0x08) {
          repeat += code[i++];
        }

        while (repeat-- > 0) {
          points.push({
            flags: flags
          });
        }
      }

      for (j = 0; j < numberOfPoints; j++) {
        switch (points[j].flags & 0x12) {
          case 0x00:
            x += (code[i] << 24 | code[i + 1] << 16) >> 16;
            i += 2;
            break;

          case 0x02:
            x -= code[i++];
            break;

          case 0x12:
            x += code[i++];
            break;
        }

        points[j].x = x;
      }

      for (j = 0; j < numberOfPoints; j++) {
        switch (points[j].flags & 0x24) {
          case 0x00:
            y += (code[i] << 24 | code[i + 1] << 16) >> 16;
            i += 2;
            break;

          case 0x04:
            y -= code[i++];
            break;

          case 0x24:
            y += code[i++];
            break;
        }

        points[j].y = y;
      }

      var startPoint = 0;

      for (i = 0; i < numberOfContours; i++) {
        var endPoint = endPtsOfContours[i];
        var contour = points.slice(startPoint, endPoint + 1);

        if (contour[0].flags & 1) {
          contour.push(contour[0]);
        } else if (contour[contour.length - 1].flags & 1) {
          contour.unshift(contour[contour.length - 1]);
        } else {
          var p = {
            flags: 1,
            x: (contour[0].x + contour[contour.length - 1].x) / 2,
            y: (contour[0].y + contour[contour.length - 1].y) / 2
          };
          contour.unshift(p);
          contour.push(p);
        }

        moveTo(contour[0].x, contour[0].y);

        for (j = 1, jj = contour.length; j < jj; j++) {
          if (contour[j].flags & 1) {
            lineTo(contour[j].x, contour[j].y);
          } else if (contour[j + 1].flags & 1) {
            quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
            j++;
          } else {
            quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
          }
        }

        startPoint = endPoint + 1;
      }
    }
  }

  function compileCharString(charStringCode, cmds, font, glyphId) {
    function moveTo(x, y) {
      cmds.push({
        cmd: "moveTo",
        args: [x, y]
      });
    }

    function lineTo(x, y) {
      cmds.push({
        cmd: "lineTo",
        args: [x, y]
      });
    }

    function bezierCurveTo(x1, y1, x2, y2, x, y) {
      cmds.push({
        cmd: "bezierCurveTo",
        args: [x1, y1, x2, y2, x, y]
      });
    }

    var stack = [];
    var x = 0,
        y = 0;
    var stems = 0;

    function parse(code) {
      var i = 0;

      while (i < code.length) {
        var stackClean = false;
        var v = code[i++];
        var xa, xb, ya, yb, y1, y2, y3, n, subrCode;

        switch (v) {
          case 1:
            stems += stack.length >> 1;
            stackClean = true;
            break;

          case 3:
            stems += stack.length >> 1;
            stackClean = true;
            break;

          case 4:
            y += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;

          case 5:
            while (stack.length > 0) {
              x += stack.shift();
              y += stack.shift();
              lineTo(x, y);
            }

            break;

          case 6:
            while (stack.length > 0) {
              x += stack.shift();
              lineTo(x, y);

              if (stack.length === 0) {
                break;
              }

              y += stack.shift();
              lineTo(x, y);
            }

            break;

          case 7:
            while (stack.length > 0) {
              y += stack.shift();
              lineTo(x, y);

              if (stack.length === 0) {
                break;
              }

              x += stack.shift();
              lineTo(x, y);
            }

            break;

          case 8:
            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            break;

          case 10:
            n = stack.pop();
            subrCode = null;

            if (font.isCFFCIDFont) {
              var fdIndex = font.fdSelect.getFDIndex(glyphId);

              if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                var fontDict = font.fdArray[fdIndex];
                var subrs = void 0;

                if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                  subrs = fontDict.privateDict.subrsIndex.objects;
                }

                if (subrs) {
                  n += getSubroutineBias(subrs);
                  subrCode = subrs[n];
                }
              } else {
                (0, _util.warn)("Invalid fd index for glyph index.");
              }
            } else {
              subrCode = font.subrs[n + font.subrsBias];
            }

            if (subrCode) {
              parse(subrCode);
            }

            break;

          case 11:
            return;

          case 12:
            v = code[i++];

            switch (v) {
              case 34:
                xa = x + stack.shift();
                xb = xa + stack.shift();
                y1 = y + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y, xb, y1, x, y1);
                xa = x + stack.shift();
                xb = xa + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y1, xb, y, x, y);
                break;

              case 35:
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                stack.pop();
                break;

              case 36:
                xa = x + stack.shift();
                y1 = y + stack.shift();
                xb = xa + stack.shift();
                y2 = y1 + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y1, xb, y2, x, y2);
                xa = x + stack.shift();
                xb = xa + stack.shift();
                y3 = y2 + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y2, xb, y3, x, y);
                break;

              case 37:
                var x0 = x,
                    y0 = y;
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb;
                y = yb;

                if (Math.abs(x - x0) > Math.abs(y - y0)) {
                  x += stack.shift();
                } else {
                  y += stack.shift();
                }

                bezierCurveTo(xa, ya, xb, yb, x, y);
                break;

              default:
                throw new _util.FormatError("unknown operator: 12 ".concat(v));
            }

            break;

          case 14:
            if (stack.length >= 4) {
              var achar = stack.pop();
              var bchar = stack.pop();
              y = stack.pop();
              x = stack.pop();
              cmds.push({
                cmd: "save"
              });
              cmds.push({
                cmd: "translate",
                args: [x, y]
              });
              var cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
              compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
              cmds.push({
                cmd: "restore"
              });
              cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
              compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
            }

            return;

          case 18:
            stems += stack.length >> 1;
            stackClean = true;
            break;

          case 19:
            stems += stack.length >> 1;
            i += stems + 7 >> 3;
            stackClean = true;
            break;

          case 20:
            stems += stack.length >> 1;
            i += stems + 7 >> 3;
            stackClean = true;
            break;

          case 21:
            y += stack.pop();
            x += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;

          case 22:
            x += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;

          case 23:
            stems += stack.length >> 1;
            stackClean = true;
            break;

          case 24:
            while (stack.length > 2) {
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
            break;

          case 25:
            while (stack.length > 6) {
              x += stack.shift();
              y += stack.shift();
              lineTo(x, y);
            }

            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
            break;

          case 26:
            if (stack.length % 2) {
              x += stack.shift();
            }

            while (stack.length > 0) {
              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            break;

          case 27:
            if (stack.length % 2) {
              y += stack.shift();
            }

            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb;
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            break;

          case 28:
            stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
            i += 2;
            break;

          case 29:
            n = stack.pop() + font.gsubrsBias;
            subrCode = font.gsubrs[n];

            if (subrCode) {
              parse(subrCode);
            }

            break;

          case 30:
            while (stack.length > 0) {
              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);

              if (stack.length === 0) {
                break;
              }

              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              y = yb + stack.shift();
              x = xb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            break;

          case 31:
            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              y = yb + stack.shift();
              x = xb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);

              if (stack.length === 0) {
                break;
              }

              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }

            break;

          default:
            if (v < 32) {
              throw new _util.FormatError("unknown operator: ".concat(v));
            }

            if (v < 247) {
              stack.push(v - 139);
            } else if (v < 251) {
              stack.push((v - 247) * 256 + code[i++] + 108);
            } else if (v < 255) {
              stack.push(-(v - 251) * 256 - code[i++] - 108);
            } else {
              stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
              i += 4;
            }

            break;
        }

        if (stackClean) {
          stack.length = 0;
        }
      }
    }

    parse(charStringCode);
  }

  var NOOP = [];

  var CompiledFont = /*#__PURE__*/function () {
    function CompiledFont(fontMatrix) {
      _classCallCheck(this, CompiledFont);

      if (this.constructor === CompiledFont) {
        (0, _util.unreachable)("Cannot initialize CompiledFont.");
      }

      this.fontMatrix = fontMatrix;
      this.compiledGlyphs = Object.create(null);
      this.compiledCharCodeToGlyphId = Object.create(null);
    }

    _createClass(CompiledFont, [{
      key: "getPathJs",
      value: function getPathJs(unicode) {
        var cmap = lookupCmap(this.cmap, unicode);
        var fn = this.compiledGlyphs[cmap.glyphId];

        if (!fn) {
          fn = this.compileGlyph(this.glyphs[cmap.glyphId], cmap.glyphId);
          this.compiledGlyphs[cmap.glyphId] = fn;
        }

        if (this.compiledCharCodeToGlyphId[cmap.charCode] === undefined) {
          this.compiledCharCodeToGlyphId[cmap.charCode] = cmap.glyphId;
        }

        return fn;
      }
    }, {
      key: "compileGlyph",
      value: function compileGlyph(code, glyphId) {
        if (!code || code.length === 0 || code[0] === 14) {
          return NOOP;
        }

        var fontMatrix = this.fontMatrix;

        if (this.isCFFCIDFont) {
          var fdIndex = this.fdSelect.getFDIndex(glyphId);

          if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
            var fontDict = this.fdArray[fdIndex];
            fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
          } else {
            (0, _util.warn)("Invalid fd index for glyph index.");
          }
        }

        var cmds = [];
        cmds.push({
          cmd: "save"
        });
        cmds.push({
          cmd: "transform",
          args: fontMatrix.slice()
        });
        cmds.push({
          cmd: "scale",
          args: ["size", "-size"]
        });
        this.compileGlyphImpl(code, cmds, glyphId);
        cmds.push({
          cmd: "restore"
        });
        return cmds;
      }
    }, {
      key: "compileGlyphImpl",
      value: function compileGlyphImpl() {
        (0, _util.unreachable)("Children classes should implement this.");
      }
    }, {
      key: "hasBuiltPath",
      value: function hasBuiltPath(unicode) {
        var cmap = lookupCmap(this.cmap, unicode);
        return this.compiledGlyphs[cmap.glyphId] !== undefined && this.compiledCharCodeToGlyphId[cmap.charCode] !== undefined;
      }
    }]);

    return CompiledFont;
  }();

  var TrueTypeCompiled = /*#__PURE__*/function (_CompiledFont) {
    _inherits(TrueTypeCompiled, _CompiledFont);

    var _super = _createSuper(TrueTypeCompiled);

    function TrueTypeCompiled(glyphs, cmap, fontMatrix) {
      var _this;

      _classCallCheck(this, TrueTypeCompiled);

      _this = _super.call(this, fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);
      _this.glyphs = glyphs;
      _this.cmap = cmap;
      return _this;
    }

    _createClass(TrueTypeCompiled, [{
      key: "compileGlyphImpl",
      value: function compileGlyphImpl(code, cmds) {
        compileGlyf(code, cmds, this);
      }
    }]);

    return TrueTypeCompiled;
  }(CompiledFont);

  var Type2Compiled = /*#__PURE__*/function (_CompiledFont2) {
    _inherits(Type2Compiled, _CompiledFont2);

    var _super2 = _createSuper(Type2Compiled);

    function Type2Compiled(cffInfo, cmap, fontMatrix, glyphNameMap) {
      var _this2;

      _classCallCheck(this, Type2Compiled);

      _this2 = _super2.call(this, fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);
      _this2.glyphs = cffInfo.glyphs;
      _this2.gsubrs = cffInfo.gsubrs || [];
      _this2.subrs = cffInfo.subrs || [];
      _this2.cmap = cmap;
      _this2.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
      _this2.gsubrsBias = getSubroutineBias(_this2.gsubrs);
      _this2.subrsBias = getSubroutineBias(_this2.subrs);
      _this2.isCFFCIDFont = cffInfo.isCFFCIDFont;
      _this2.fdSelect = cffInfo.fdSelect;
      _this2.fdArray = cffInfo.fdArray;
      return _this2;
    }

    _createClass(Type2Compiled, [{
      key: "compileGlyphImpl",
      value: function compileGlyphImpl(code, cmds, glyphId) {
        compileCharString(code, cmds, this, glyphId);
      }
    }]);

    return Type2Compiled;
  }(CompiledFont);

  return {
    create: function FontRendererFactory_create(font, seacAnalysisEnabled) {
      var data = new Uint8Array(font.data);
      var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
      var numTables = getUshort(data, 4);

      for (var i = 0, p = 12; i < numTables; i++, p += 16) {
        var tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
        var offset = getLong(data, p + 8);
        var length = getLong(data, p + 12);

        switch (tag) {
          case "cmap":
            cmap = parseCmap(data, offset, offset + length);
            break;

          case "glyf":
            glyf = data.subarray(offset, offset + length);
            break;

          case "loca":
            loca = data.subarray(offset, offset + length);
            break;

          case "head":
            unitsPerEm = getUshort(data, offset + 18);
            indexToLocFormat = getUshort(data, offset + 50);
            break;

          case "CFF ":
            cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
            break;
        }
      }

      if (glyf) {
        var fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
        return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
      }

      return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
    }
  };
}();

exports.FontRendererFactory = FontRendererFactory;

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Parser = void 0;

var _encodings = __w_pdfjs_require__(162);

var _core_utils = __w_pdfjs_require__(138);

var _stream = __w_pdfjs_require__(142);

var _util = __w_pdfjs_require__(4);

var HINTING_ENABLED = false;

var Type1CharString = function Type1CharStringClosure() {
  var COMMAND_MAP = {
    hstem: [1],
    vstem: [3],
    vmoveto: [4],
    rlineto: [5],
    hlineto: [6],
    vlineto: [7],
    rrcurveto: [8],
    callsubr: [10],
    flex: [12, 35],
    drop: [12, 18],
    endchar: [14],
    rmoveto: [21],
    hmoveto: [22],
    vhcurveto: [30],
    hvcurveto: [31]
  };

  function Type1CharString() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }

  Type1CharString.prototype = {
    convert: function Type1CharString_convert(encoded, subrs, seacAnalysisEnabled) {
      var count = encoded.length;
      var error = false;
      var wx, sbx, subrNumber;

      for (var i = 0; i < count; i++) {
        var value = encoded[i];

        if (value < 32) {
          if (value === 12) {
            value = (value << 8) + encoded[++i];
          }

          switch (value) {
            case 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;

            case 3:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;

            case 4:
              if (this.flexing) {
                if (this.stack.length < 1) {
                  error = true;
                  break;
                }

                var dy = this.stack.pop();
                this.stack.push(0, dy);
                break;
              }

              error = this.executeCommand(1, COMMAND_MAP.vmoveto);
              break;

            case 5:
              error = this.executeCommand(2, COMMAND_MAP.rlineto);
              break;

            case 6:
              error = this.executeCommand(1, COMMAND_MAP.hlineto);
              break;

            case 7:
              error = this.executeCommand(1, COMMAND_MAP.vlineto);
              break;

            case 8:
              error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
              break;

            case 9:
              this.stack = [];
              break;

            case 10:
              if (this.stack.length < 1) {
                error = true;
                break;
              }

              subrNumber = this.stack.pop();

              if (!subrs[subrNumber]) {
                error = true;
                break;
              }

              error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
              break;

            case 11:
              return error;

            case 13:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              wx = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx);
              error = this.executeCommand(2, COMMAND_MAP.hmoveto);
              break;

            case 14:
              this.output.push(COMMAND_MAP.endchar[0]);
              break;

            case 21:
              if (this.flexing) {
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;

            case 22:
              if (this.flexing) {
                this.stack.push(0);
                break;
              }

              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;

            case 30:
              error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
              break;

            case 31:
              error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
              break;

            case (12 << 8) + 0:
              this.stack = [];
              break;

            case (12 << 8) + 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;

            case (12 << 8) + 2:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;

            case (12 << 8) + 6:
              if (seacAnalysisEnabled) {
                var asb = this.stack[this.stack.length - 5];
                this.seac = this.stack.splice(-4, 4);
                this.seac[0] += this.lsb - asb;
                error = this.executeCommand(0, COMMAND_MAP.endchar);
              } else {
                error = this.executeCommand(4, COMMAND_MAP.endchar);
              }

              break;

            case (12 << 8) + 7:
              if (this.stack.length < 4) {
                error = true;
                break;
              }

              this.stack.pop();
              wx = this.stack.pop();
              var sby = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx, sby);
              error = this.executeCommand(3, COMMAND_MAP.rmoveto);
              break;

            case (12 << 8) + 12:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              var num2 = this.stack.pop();
              var num1 = this.stack.pop();
              this.stack.push(num1 / num2);
              break;

            case (12 << 8) + 16:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              subrNumber = this.stack.pop();
              var numArgs = this.stack.pop();

              if (subrNumber === 0 && numArgs === 3) {
                var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                error = this.executeCommand(13, COMMAND_MAP.flex, true);
                this.flexing = false;
                this.stack.push(flexArgs[15], flexArgs[16]);
              } else if (subrNumber === 1 && numArgs === 0) {
                this.flexing = true;
              }

              break;

            case (12 << 8) + 17:
              break;

            case (12 << 8) + 33:
              this.stack = [];
              break;

            default:
              (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
              break;
          }

          if (error) {
            break;
          }

          continue;
        } else if (value <= 246) {
          value = value - 139;
        } else if (value <= 250) {
          value = (value - 247) * 256 + encoded[++i] + 108;
        } else if (value <= 254) {
          value = -((value - 251) * 256) - encoded[++i] - 108;
        } else {
          value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
        }

        this.stack.push(value);
      }

      return error;
    },
    executeCommand: function executeCommand(howManyArgs, command, keepStack) {
      var stackLength = this.stack.length;

      if (howManyArgs > stackLength) {
        return true;
      }

      var start = stackLength - howManyArgs;

      for (var i = start; i < stackLength; i++) {
        var value = this.stack[i];

        if (Number.isInteger(value)) {
          this.output.push(28, value >> 8 & 0xff, value & 0xff);
        } else {
          value = 65536 * value | 0;
          this.output.push(255, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
        }
      }

      this.output.push.apply(this.output, command);

      if (keepStack) {
        this.stack.splice(start, howManyArgs);
      } else {
        this.stack.length = 0;
      }

      return false;
    }
  };
  return Type1CharString;
}();

var Type1Parser = function Type1ParserClosure() {
  var EEXEC_ENCRYPT_KEY = 55665;
  var CHAR_STRS_ENCRYPT_KEY = 4330;

  function isHexDigit(code) {
    return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  }

  function decrypt(data, key, discardNumber) {
    if (discardNumber >= data.length) {
      return new Uint8Array(0);
    }

    var r = key | 0,
        c1 = 52845,
        c2 = 22719,
        i,
        j;

    for (i = 0; i < discardNumber; i++) {
      r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
    }

    var count = data.length - discardNumber;
    var decrypted = new Uint8Array(count);

    for (i = discardNumber, j = 0; j < count; i++, j++) {
      var value = data[i];
      decrypted[j] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }

    return decrypted;
  }

  function decryptAscii(data, key, discardNumber) {
    var r = key | 0,
        c1 = 52845,
        c2 = 22719;
    var count = data.length,
        maybeLength = count >>> 1;
    var decrypted = new Uint8Array(maybeLength);
    var i, j;

    for (i = 0, j = 0; i < count; i++) {
      var digit1 = data[i];

      if (!isHexDigit(digit1)) {
        continue;
      }

      i++;
      var digit2;

      while (i < count && !isHexDigit(digit2 = data[i])) {
        i++;
      }

      if (i < count) {
        var value = parseInt(String.fromCharCode(digit1, digit2), 16);
        decrypted[j++] = value ^ r >> 8;
        r = (value + r) * c1 + c2 & (1 << 16) - 1;
      }
    }

    return decrypted.slice(discardNumber, j);
  }

  function isSpecial(c) {
    return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29;
  }

  function Type1Parser(stream, encrypted, seacAnalysisEnabled) {
    if (encrypted) {
      var data = stream.getBytes();
      var isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
      stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
    }

    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    this.stream = stream;
    this.nextChar();
  }

  Type1Parser.prototype = {
    readNumberArray: function Type1Parser_readNumberArray() {
      this.getToken();
      var array = [];

      while (true) {
        var token = this.getToken();

        if (token === null || token === "]" || token === "}") {
          break;
        }

        array.push(parseFloat(token || 0));
      }

      return array;
    },
    readNumber: function Type1Parser_readNumber() {
      var token = this.getToken();
      return parseFloat(token || 0);
    },
    readInt: function Type1Parser_readInt() {
      var token = this.getToken();
      return parseInt(token || 0, 10) | 0;
    },
    readBoolean: function Type1Parser_readBoolean() {
      var token = this.getToken();
      return token === "true" ? 1 : 0;
    },
    nextChar: function Type1_nextChar() {
      return this.currentChar = this.stream.getByte();
    },
    getToken: function Type1Parser_getToken() {
      var comment = false;
      var ch = this.currentChar;

      while (true) {
        if (ch === -1) {
          return null;
        }

        if (comment) {
          if (ch === 0x0a || ch === 0x0d) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
          break;
        }

        ch = this.nextChar();
      }

      if (isSpecial(ch)) {
        this.nextChar();
        return String.fromCharCode(ch);
      }

      var token = "";

      do {
        token += String.fromCharCode(ch);
        ch = this.nextChar();
      } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));

      return token;
    },
    readCharStrings: function Type1Parser_readCharStrings(bytes, lenIV) {
      if (lenIV === -1) {
        return bytes;
      }

      return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
    },
    extractFontProgram: function Type1Parser_extractFontProgram(properties) {
      var stream = this.stream;
      var subrs = [],
          charstrings = [];
      var privateData = Object.create(null);
      privateData.lenIV = 4;
      var program = {
        subrs: [],
        charstrings: [],
        properties: {
          privateData: privateData
        }
      };
      var token, length, data, lenIV, encoded;

      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }

        token = this.getToken();

        switch (token) {
          case "CharStrings":
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();

            while (true) {
              token = this.getToken();

              if (token === null || token === "end") {
                break;
              }

              if (token !== "/") {
                continue;
              }

              var glyph = this.getToken();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();

              if (token === "noaccess") {
                this.getToken();
              }

              charstrings.push({
                glyph: glyph,
                encoded: encoded
              });
            }

            break;

          case "Subrs":
            this.readInt();
            this.getToken();

            while (this.getToken() === "dup") {
              var index = this.readInt();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();

              if (token === "noaccess") {
                this.getToken();
              }

              subrs[index] = encoded;
            }

            break;

          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            var blueArray = this.readNumberArray();

            if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
              program.properties.privateData[token] = blueArray;
            }

            break;

          case "StemSnapH":
          case "StemSnapV":
            program.properties.privateData[token] = this.readNumberArray();
            break;

          case "StdHW":
          case "StdVW":
            program.properties.privateData[token] = this.readNumberArray()[0];
            break;

          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
          case "ExpansionFactor":
            program.properties.privateData[token] = this.readNumber();
            break;

          case "ForceBold":
            program.properties.privateData[token] = this.readBoolean();
            break;
        }
      }

      for (var i = 0; i < charstrings.length; i++) {
        glyph = charstrings[i].glyph;
        encoded = charstrings[i].encoded;
        var charString = new Type1CharString();
        var error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
        var output = charString.output;

        if (error) {
          output = [14];
        }

        var charStringObject = {
          glyphName: glyph,
          charstring: output,
          width: charString.width,
          lsb: charString.lsb,
          seac: charString.seac
        };

        if (glyph === ".notdef") {
          program.charstrings.unshift(charStringObject);
        } else {
          program.charstrings.push(charStringObject);
        }

        if (properties.builtInEncoding) {
          var _index = properties.builtInEncoding.indexOf(glyph);

          if (_index > -1 && properties.widths[_index] === undefined && _index >= properties.firstChar && _index <= properties.lastChar) {
            properties.widths[_index] = charString.width;
          }
        }
      }

      return program;
    },
    extractFontHeader: function Type1Parser_extractFontHeader(properties) {
      var token;

      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }

        token = this.getToken();

        switch (token) {
          case "FontMatrix":
            var matrix = this.readNumberArray();
            properties.fontMatrix = matrix;
            break;

          case "Encoding":
            var encodingArg = this.getToken();
            var encoding;

            if (!/^\d+$/.test(encodingArg)) {
              encoding = (0, _encodings.getEncoding)(encodingArg);
            } else {
              encoding = [];
              var size = parseInt(encodingArg, 10) | 0;
              this.getToken();

              for (var j = 0; j < size; j++) {
                token = this.getToken();

                while (token !== "dup" && token !== "def") {
                  token = this.getToken();

                  if (token === null) {
                    return;
                  }
                }

                if (token === "def") {
                  break;
                }

                var index = this.readInt();
                this.getToken();
                var glyph = this.getToken();
                encoding[index] = glyph;
                this.getToken();
              }
            }

            properties.builtInEncoding = encoding;
            break;

          case "FontBBox":
            var fontBBox = this.readNumberArray();
            properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
            properties.descent = Math.min(fontBBox[1], fontBBox[3]);
            properties.ascentScaled = true;
            break;
        }
      }
    }
  };
  return Type1Parser;
}();

exports.Type1Parser = Type1Parser;

/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTilingPatternIR = getTilingPatternIR;
exports.Pattern = void 0;

var _util = __w_pdfjs_require__(4);

var _colorspace = __w_pdfjs_require__(153);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

var ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};

var Pattern = function PatternClosure() {
  function Pattern() {
    (0, _util.unreachable)("should not call Pattern constructor");
  }

  Pattern.prototype = {
    getPattern: function Pattern_getPattern(ctx) {
      (0, _util.unreachable)("Should not call Pattern.getStyle: ".concat(ctx));
    }
  };

  Pattern.parseShading = function (shading, matrix, xref, res, handler, pdfFunctionFactory, localColorSpaceCache) {
    var dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
    var type = dict.get("ShadingType");

    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new Shadings.RadialAxial(dict, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);

        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new Shadings.Mesh(shading, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);

        default:
          throw new _util.FormatError("Unsupported ShadingType: " + type);
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      handler.send("UnsupportedFeature", {
        featureId: _util.UNSUPPORTED_FEATURES.shadingPattern
      });
      (0, _util.warn)(ex);
      return new Shadings.Dummy();
    }
  };

  return Pattern;
}();

exports.Pattern = Pattern;
var Shadings = {};
Shadings.SMALL_NUMBER = 1e-6;

Shadings.RadialAxial = function RadialAxialClosure() {
  function RadialAxial(dict, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    this.matrix = matrix;
    this.coordsArr = dict.getArray("Coords");
    this.shadingType = dict.get("ShadingType");
    this.type = "Pattern";

    var cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref: xref,
      resources: resources,
      pdfFunctionFactory: pdfFunctionFactory,
      localColorSpaceCache: localColorSpaceCache
    });

    this.cs = cs;
    var bbox = dict.getArray("BBox");

    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = _util.Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }

    var t0 = 0.0,
        t1 = 1.0;

    if (dict.has("Domain")) {
      var domainArr = dict.getArray("Domain");
      t0 = domainArr[0];
      t1 = domainArr[1];
    }

    var extendStart = false,
        extendEnd = false;

    if (dict.has("Extend")) {
      var extendArr = dict.getArray("Extend");
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }

    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      var x1 = this.coordsArr[0];
      var y1 = this.coordsArr[1];
      var r1 = this.coordsArr[2];
      var x2 = this.coordsArr[3];
      var y2 = this.coordsArr[4];
      var r2 = this.coordsArr[5];
      var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        (0, _util.warn)("Unsupported radial gradient.");
      }
    }

    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    var fnObj = dict.getRaw("Function");
    var fn = pdfFunctionFactory.createFromArray(fnObj);
    var NUMBER_OF_SAMPLES = 10;
    var step = (t1 - t0) / NUMBER_OF_SAMPLES;
    var colorStops = this.colorStops = [];

    if (t0 >= t1 || step <= 0) {
      (0, _util.info)("Bad shading domain.");
      return;
    }

    var color = new Float32Array(cs.numComps),
        ratio = new Float32Array(1);
    var rgbColor;

    for (var i = 0; i <= NUMBER_OF_SAMPLES; i++) {
      ratio[0] = t0 + i * step;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);

      var cssColor = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);

      colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]);
    }

    var background = "transparent";

    if (dict.has("Background")) {
      rgbColor = cs.getRgb(dict.get("Background"), 0);
      background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
    }

    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += Shadings.SMALL_NUMBER;
    }

    if (!extendEnd) {
      colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
      colorStops.push([1, background]);
    }

    this.colorStops = colorStops;
  }

  RadialAxial.prototype = {
    getIR: function RadialAxial_getIR() {
      var coordsArr = this.coordsArr;
      var shadingType = this.shadingType;
      var type, p0, p1, r0, r1;

      if (shadingType === ShadingType.AXIAL) {
        p0 = [coordsArr[0], coordsArr[1]];
        p1 = [coordsArr[2], coordsArr[3]];
        r0 = null;
        r1 = null;
        type = "axial";
      } else if (shadingType === ShadingType.RADIAL) {
        p0 = [coordsArr[0], coordsArr[1]];
        p1 = [coordsArr[3], coordsArr[4]];
        r0 = coordsArr[2];
        r1 = coordsArr[5];
        type = "radial";
      } else {
        (0, _util.unreachable)("getPattern type unknown: ".concat(shadingType));
      }

      var matrix = this.matrix;

      if (matrix) {
        p0 = _util.Util.applyTransform(p0, matrix);
        p1 = _util.Util.applyTransform(p1, matrix);

        if (shadingType === ShadingType.RADIAL) {
          var scale = _util.Util.singularValueDecompose2dScale(matrix);

          r0 *= scale[0];
          r1 *= scale[1];
        }
      }

      return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
    }
  };
  return RadialAxial;
}();

Shadings.Mesh = function MeshClosure() {
  function MeshStreamReader(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    var numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    var csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }

  MeshStreamReader.prototype = {
    get hasData() {
      if (this.stream.end) {
        return this.stream.pos < this.stream.end;
      }

      if (this.bufferLength > 0) {
        return true;
      }

      var nextByte = this.stream.getByte();

      if (nextByte < 0) {
        return false;
      }

      this.buffer = nextByte;
      this.bufferLength = 8;
      return true;
    },

    readBits: function MeshStreamReader_readBits(n) {
      var buffer = this.buffer;
      var bufferLength = this.bufferLength;

      if (n === 32) {
        if (bufferLength === 0) {
          return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
        }

        buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
        var nextByte = this.stream.getByte();
        this.buffer = nextByte & (1 << bufferLength) - 1;
        return (buffer << 8 - bufferLength | (nextByte & 0xff) >> bufferLength) >>> 0;
      }

      if (n === 8 && bufferLength === 0) {
        return this.stream.getByte();
      }

      while (bufferLength < n) {
        buffer = buffer << 8 | this.stream.getByte();
        bufferLength += 8;
      }

      bufferLength -= n;
      this.bufferLength = bufferLength;
      this.buffer = buffer & (1 << bufferLength) - 1;
      return buffer >> bufferLength;
    },
    align: function MeshStreamReader_align() {
      this.buffer = 0;
      this.bufferLength = 0;
    },
    readFlag: function MeshStreamReader_readFlag() {
      return this.readBits(this.context.bitsPerFlag);
    },
    readCoordinate: function MeshStreamReader_readCoordinate() {
      var bitsPerCoordinate = this.context.bitsPerCoordinate;
      var xi = this.readBits(bitsPerCoordinate);
      var yi = this.readBits(bitsPerCoordinate);
      var decode = this.context.decode;
      var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
      return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
    },
    readComponents: function MeshStreamReader_readComponents() {
      var numComps = this.context.numComps;
      var bitsPerComponent = this.context.bitsPerComponent;
      var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
      var decode = this.context.decode;
      var components = this.tmpCompsBuf;

      for (var i = 0, j = 4; i < numComps; i++, j += 2) {
        var ci = this.readBits(bitsPerComponent);
        components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
      }

      var color = this.tmpCsCompsBuf;

      if (this.context.colorFn) {
        this.context.colorFn(components, 0, color, 0);
      }

      return this.context.colorSpace.getRgb(color, 0);
    }
  };

  function decodeType4Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var operators = [];
    var ps = [];
    var verticesLeft = 0;

    while (reader.hasData) {
      var f = reader.readFlag();
      var coord = reader.readCoordinate();
      var color = reader.readComponents();

      if (verticesLeft === 0) {
        if (!(0 <= f && f <= 2)) {
          throw new _util.FormatError("Unknown type4 flag");
        }

        switch (f) {
          case 0:
            verticesLeft = 3;
            break;

          case 1:
            ps.push(ps[ps.length - 2], ps[ps.length - 1]);
            verticesLeft = 1;
            break;

          case 2:
            ps.push(ps[ps.length - 3], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
        }

        operators.push(f);
      }

      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }

    mesh.figures.push({
      type: "triangles",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }

  function decodeType5Shading(mesh, reader, verticesPerRow) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = [];

    while (reader.hasData) {
      var coord = reader.readCoordinate();
      var color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }

    mesh.figures.push({
      type: "lattice",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow: verticesPerRow
    });
  }

  var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  var TRIANGLE_DENSITY = 20;

  var getB = function getBClosure() {
    function buildB(count) {
      var lut = [];

      for (var i = 0; i <= count; i++) {
        var t = i / count,
            t_ = 1 - t;
        lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
      }

      return lut;
    }

    var cache = [];
    return function getB(count) {
      if (!cache[count]) {
        cache[count] = buildB(count);
      }

      return cache[count];
    };
  }();

  function buildFigureFromPatch(mesh, index) {
    var figure = mesh.figures[index];
    (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
    var coords = mesh.coords,
        colors = mesh.colors;
    var pi = figure.coords;
    var ci = figure.colors;
    var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
    splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
    splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    var verticesPerRow = splitXBy + 1;
    var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    var k = 0;
    var cl = new Uint8Array(3),
        cr = new Uint8Array(3);
    var c0 = colors[ci[0]],
        c1 = colors[ci[1]],
        c2 = colors[ci[2]],
        c3 = colors[ci[3]];
    var bRow = getB(splitYBy),
        bCol = getB(splitXBy);

    for (var row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;

      for (var col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }

        var x = 0,
            y = 0;
        var q = 0;

        for (var i = 0; i <= 3; i++) {
          for (var j = 0; j <= 3; j++, q++) {
            var m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }

        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        var newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }

    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    mesh.figures[index] = {
      type: "lattice",
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow: verticesPerRow
    };
  }

  function decodeType6Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = new Int32Array(16);
    var cs = new Int32Array(4);

    while (reader.hasData) {
      var f = reader.readFlag();

      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type6 flag");
      }

      var i, ii;
      var pi = coords.length;

      for (i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }

      var ci = colors.length;

      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }

      var tmp1, tmp2, tmp3, tmp4;

      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;

        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }

      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      mesh.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }

  function decodeType7Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = new Int32Array(16);
    var cs = new Int32Array(4);

    while (reader.hasData) {
      var f = reader.readFlag();

      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type7 flag");
      }

      var i, ii;
      var pi = coords.length;

      for (i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }

      var ci = colors.length;

      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }

      var tmp1, tmp2, tmp3, tmp4;

      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;

        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }

      mesh.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }

  function updateBounds(mesh) {
    var minX = mesh.coords[0][0],
        minY = mesh.coords[0][1],
        maxX = minX,
        maxY = minY;

    for (var i = 1, ii = mesh.coords.length; i < ii; i++) {
      var x = mesh.coords[i][0],
          y = mesh.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }

    mesh.bounds = [minX, minY, maxX, maxY];
  }

  function packData(mesh) {
    var i, ii, j, jj;
    var coords = mesh.coords;
    var coordsPacked = new Float32Array(coords.length * 2);

    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      var xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }

    mesh.coords = coordsPacked;
    var colors = mesh.colors;
    var colorsPacked = new Uint8Array(colors.length * 3);

    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      var c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }

    mesh.colors = colorsPacked;
    var figures = mesh.figures;

    for (i = 0, ii = figures.length; i < ii; i++) {
      var figure = figures[i],
          ps = figure.coords,
          cs = figure.colors;

      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }

  function Mesh(stream, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    if (!(0, _primitives.isStream)(stream)) {
      throw new _util.FormatError("Mesh data is not a stream");
    }

    var dict = stream.dict;
    this.matrix = matrix;
    this.shadingType = dict.get("ShadingType");
    this.type = "Pattern";
    var bbox = dict.getArray("BBox");

    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = _util.Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }

    var cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref: xref,
      resources: resources,
      pdfFunctionFactory: pdfFunctionFactory,
      localColorSpaceCache: localColorSpaceCache
    });

    this.cs = cs;
    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
    var fnObj = dict.getRaw("Function");
    var fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    var decodeContext = {
      bitsPerCoordinate: dict.get("BitsPerCoordinate"),
      bitsPerComponent: dict.get("BitsPerComponent"),
      bitsPerFlag: dict.get("BitsPerFlag"),
      decode: dict.getArray("Decode"),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    var reader = new MeshStreamReader(stream, decodeContext);
    var patchMesh = false;

    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        decodeType4Shading(this, reader);
        break;

      case ShadingType.LATTICE_FORM_MESH:
        var verticesPerRow = dict.get("VerticesPerRow") | 0;

        if (verticesPerRow < 2) {
          throw new _util.FormatError("Invalid VerticesPerRow");
        }

        decodeType5Shading(this, reader, verticesPerRow);
        break;

      case ShadingType.COONS_PATCH_MESH:
        decodeType6Shading(this, reader);
        patchMesh = true;
        break;

      case ShadingType.TENSOR_PATCH_MESH:
        decodeType7Shading(this, reader);
        patchMesh = true;
        break;

      default:
        (0, _util.unreachable)("Unsupported mesh type.");
        break;
    }

    if (patchMesh) {
      updateBounds(this);

      for (var i = 0, ii = this.figures.length; i < ii; i++) {
        buildFigureFromPatch(this, i);
      }
    }

    updateBounds(this);
    packData(this);
  }

  Mesh.prototype = {
    getIR: function Mesh_getIR() {
      return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
    }
  };
  return Mesh;
}();

Shadings.Dummy = function DummyClosure() {
  function Dummy() {
    this.type = "Pattern";
  }

  Dummy.prototype = {
    getIR: function Dummy_getIR() {
      return ["Dummy"];
    }
  };
  return Dummy;
}();

function getTilingPatternIR(operatorList, dict, color) {
  var matrix = dict.getArray("Matrix");

  var bbox = _util.Util.normalizeRect(dict.getArray("BBox"));

  var xstep = dict.get("XStep");
  var ystep = dict.get("YStep");
  var paintType = dict.get("PaintType");
  var tilingType = dict.get("TilingType");

  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
    throw new _util.FormatError("Invalid getTilingPatternIR /BBox array: [".concat(bbox, "]."));
  }

  return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}

/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isPDFFunction = isPDFFunction;
exports.PostScriptEvaluator = exports.PostScriptCompiler = exports.PDFFunctionFactory = void 0;

var _primitives = __w_pdfjs_require__(135);

var _util = __w_pdfjs_require__(4);

var _ps_parser = __w_pdfjs_require__(170);

var _image_utils = __w_pdfjs_require__(154);

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PDFFunctionFactory = /*#__PURE__*/function () {
  function PDFFunctionFactory(_ref) {
    var xref = _ref.xref,
        _ref$isEvalSupported = _ref.isEvalSupported,
        isEvalSupported = _ref$isEvalSupported === void 0 ? true : _ref$isEvalSupported;

    _classCallCheck(this, PDFFunctionFactory);

    this.xref = xref;
    this.isEvalSupported = isEvalSupported !== false;
  }

  _createClass(PDFFunctionFactory, [{
    key: "create",
    value: function create(fn) {
      var cachedFunction = this.getCached(fn);

      if (cachedFunction) {
        return cachedFunction;
      }

      var parsedFunction = PDFFunction.parse({
        xref: this.xref,
        isEvalSupported: this.isEvalSupported,
        fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
      });

      this._cache(fn, parsedFunction);

      return parsedFunction;
    }
  }, {
    key: "createFromArray",
    value: function createFromArray(fnObj) {
      var cachedFunction = this.getCached(fnObj);

      if (cachedFunction) {
        return cachedFunction;
      }

      var parsedFunction = PDFFunction.parseArray({
        xref: this.xref,
        isEvalSupported: this.isEvalSupported,
        fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
      });

      this._cache(fnObj, parsedFunction);

      return parsedFunction;
    }
  }, {
    key: "getCached",
    value: function getCached(cacheKey) {
      var fnRef;

      if (cacheKey instanceof _primitives.Ref) {
        fnRef = cacheKey;
      } else if (cacheKey instanceof _primitives.Dict) {
        fnRef = cacheKey.objId;
      } else if ((0, _primitives.isStream)(cacheKey)) {
        fnRef = cacheKey.dict && cacheKey.dict.objId;
      }

      if (fnRef) {
        var localFunction = this._localFunctionCache.getByRef(fnRef);

        if (localFunction) {
          return localFunction;
        }
      }

      return null;
    }
  }, {
    key: "_cache",
    value: function _cache(cacheKey, parsedFunction) {
      if (!parsedFunction) {
        throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
      }

      var fnRef;

      if (cacheKey instanceof _primitives.Ref) {
        fnRef = cacheKey;
      } else if (cacheKey instanceof _primitives.Dict) {
        fnRef = cacheKey.objId;
      } else if ((0, _primitives.isStream)(cacheKey)) {
        fnRef = cacheKey.dict && cacheKey.dict.objId;
      }

      if (fnRef) {
        this._localFunctionCache.set(null, fnRef, parsedFunction);
      }
    }
  }, {
    key: "_localFunctionCache",
    get: function get() {
      return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
    }
  }]);

  return PDFFunctionFactory;
}();

exports.PDFFunctionFactory = PDFFunctionFactory;

function toNumberArray(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }

  var length = arr.length;

  for (var i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      var result = new Array(length);

      for (var j = 0; j < length; j++) {
        result[j] = +arr[j];
      }

      return result;
    }
  }

  return arr;
}

var PDFFunction = function PDFFunctionClosure() {
  var CONSTRUCT_SAMPLED = 0;
  var CONSTRUCT_INTERPOLATED = 2;
  var CONSTRUCT_STICHED = 3;
  var CONSTRUCT_POSTSCRIPT = 4;
  return {
    getSampleArray: function getSampleArray(size, outputSize, bps, stream) {
      var i, ii;
      var length = 1;

      for (i = 0, ii = size.length; i < ii; i++) {
        length *= size[i];
      }

      length *= outputSize;
      var array = new Array(length);
      var codeSize = 0;
      var codeBuf = 0;
      var sampleMul = 1.0 / (Math.pow(2.0, bps) - 1);
      var strBytes = stream.getBytes((length * bps + 7) / 8);
      var strIdx = 0;

      for (i = 0; i < length; i++) {
        while (codeSize < bps) {
          codeBuf <<= 8;
          codeBuf |= strBytes[strIdx++];
          codeSize += 8;
        }

        codeSize -= bps;
        array[i] = (codeBuf >> codeSize) * sampleMul;
        codeBuf &= (1 << codeSize) - 1;
      }

      return array;
    },
    getIR: function getIR(_ref2) {
      var xref = _ref2.xref,
          isEvalSupported = _ref2.isEvalSupported,
          fn = _ref2.fn;
      var dict = fn.dict;

      if (!dict) {
        dict = fn;
      }

      var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
      var typeNum = dict.get("FunctionType");
      var typeFn = types[typeNum];

      if (!typeFn) {
        throw new _util.FormatError("Unknown type of function");
      }

      return typeFn.call(this, {
        xref: xref,
        isEvalSupported: isEvalSupported,
        fn: fn,
        dict: dict
      });
    },
    fromIR: function fromIR(_ref3) {
      var xref = _ref3.xref,
          isEvalSupported = _ref3.isEvalSupported,
          IR = _ref3.IR;
      var type = IR[0];

      switch (type) {
        case CONSTRUCT_SAMPLED:
          return this.constructSampledFromIR({
            xref: xref,
            isEvalSupported: isEvalSupported,
            IR: IR
          });

        case CONSTRUCT_INTERPOLATED:
          return this.constructInterpolatedFromIR({
            xref: xref,
            isEvalSupported: isEvalSupported,
            IR: IR
          });

        case CONSTRUCT_STICHED:
          return this.constructStichedFromIR({
            xref: xref,
            isEvalSupported: isEvalSupported,
            IR: IR
          });

        default:
          return this.constructPostScriptFromIR({
            xref: xref,
            isEvalSupported: isEvalSupported,
            IR: IR
          });
      }
    },
    parse: function parse(_ref4) {
      var xref = _ref4.xref,
          isEvalSupported = _ref4.isEvalSupported,
          fn = _ref4.fn;
      var IR = this.getIR({
        xref: xref,
        isEvalSupported: isEvalSupported,
        fn: fn
      });
      return this.fromIR({
        xref: xref,
        isEvalSupported: isEvalSupported,
        IR: IR
      });
    },
    parseArray: function parseArray(_ref5) {
      var xref = _ref5.xref,
          isEvalSupported = _ref5.isEvalSupported,
          fnObj = _ref5.fnObj;

      if (!Array.isArray(fnObj)) {
        return this.parse({
          xref: xref,
          isEvalSupported: isEvalSupported,
          fn: fnObj
        });
      }

      var fnArray = [];

      for (var j = 0, jj = fnObj.length; j < jj; j++) {
        fnArray.push(this.parse({
          xref: xref,
          isEvalSupported: isEvalSupported,
          fn: xref.fetchIfRef(fnObj[j])
        }));
      }

      return function (src, srcOffset, dest, destOffset) {
        for (var i = 0, ii = fnArray.length; i < ii; i++) {
          fnArray[i](src, srcOffset, dest, destOffset + i);
        }
      };
    },
    constructSampled: function constructSampled(_ref6) {
      var xref = _ref6.xref,
          isEvalSupported = _ref6.isEvalSupported,
          fn = _ref6.fn,
          dict = _ref6.dict;

      function toMultiArray(arr) {
        var inputLength = arr.length;
        var out = [];
        var index = 0;

        for (var i = 0; i < inputLength; i += 2) {
          out[index] = [arr[i], arr[i + 1]];
          ++index;
        }

        return out;
      }

      var domain = toNumberArray(dict.getArray("Domain"));
      var range = toNumberArray(dict.getArray("Range"));

      if (!domain || !range) {
        throw new _util.FormatError("No domain or range");
      }

      var inputSize = domain.length / 2;
      var outputSize = range.length / 2;
      domain = toMultiArray(domain);
      range = toMultiArray(range);
      var size = toNumberArray(dict.getArray("Size"));
      var bps = dict.get("BitsPerSample");
      var order = dict.get("Order") || 1;

      if (order !== 1) {
        (0, _util.info)("No support for cubic spline interpolation: " + order);
      }

      var encode = toNumberArray(dict.getArray("Encode"));

      if (!encode) {
        encode = [];

        for (var i = 0; i < inputSize; ++i) {
          encode.push([0, size[i] - 1]);
        }
      } else {
        encode = toMultiArray(encode);
      }

      var decode = toNumberArray(dict.getArray("Decode"));

      if (!decode) {
        decode = range;
      } else {
        decode = toMultiArray(decode);
      }

      var samples = this.getSampleArray(size, outputSize, bps, fn);
      return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, Math.pow(2, bps) - 1, range];
    },
    constructSampledFromIR: function constructSampledFromIR(_ref7) {
      var xref = _ref7.xref,
          isEvalSupported = _ref7.isEvalSupported,
          IR = _ref7.IR;

      function interpolate(x, xmin, xmax, ymin, ymax) {
        return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
      }

      return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
        var m = IR[1];
        var domain = IR[2];
        var encode = IR[3];
        var decode = IR[4];
        var samples = IR[5];
        var size = IR[6];
        var n = IR[7];
        var range = IR[9];
        var cubeVertices = 1 << m;
        var cubeN = new Float64Array(cubeVertices);
        var cubeVertex = new Uint32Array(cubeVertices);
        var i, j;

        for (j = 0; j < cubeVertices; j++) {
          cubeN[j] = 1;
        }

        var k = n,
            pos = 1;

        for (i = 0; i < m; ++i) {
          var domain_2i = domain[i][0];
          var domain_2i_1 = domain[i][1];
          var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
          var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
          var size_i = size[i];
          e = Math.min(Math.max(e, 0), size_i - 1);
          var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
          var n0 = e0 + 1 - e;
          var n1 = e - e0;
          var offset0 = e0 * k;
          var offset1 = offset0 + k;

          for (j = 0; j < cubeVertices; j++) {
            if (j & pos) {
              cubeN[j] *= n1;
              cubeVertex[j] += offset1;
            } else {
              cubeN[j] *= n0;
              cubeVertex[j] += offset0;
            }
          }

          k *= size_i;
          pos <<= 1;
        }

        for (j = 0; j < n; ++j) {
          var rj = 0;

          for (i = 0; i < cubeVertices; i++) {
            rj += samples[cubeVertex[i] + j] * cubeN[i];
          }

          rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
          dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
        }
      };
    },
    constructInterpolated: function constructInterpolated(_ref8) {
      var xref = _ref8.xref,
          isEvalSupported = _ref8.isEvalSupported,
          fn = _ref8.fn,
          dict = _ref8.dict;
      var c0 = toNumberArray(dict.getArray("C0")) || [0];
      var c1 = toNumberArray(dict.getArray("C1")) || [1];
      var n = dict.get("N");
      var length = c0.length;
      var diff = [];

      for (var i = 0; i < length; ++i) {
        diff.push(c1[i] - c0[i]);
      }

      return [CONSTRUCT_INTERPOLATED, c0, diff, n];
    },
    constructInterpolatedFromIR: function constructInterpolatedFromIR(_ref9) {
      var xref = _ref9.xref,
          isEvalSupported = _ref9.isEvalSupported,
          IR = _ref9.IR;
      var c0 = IR[1];
      var diff = IR[2];
      var n = IR[3];
      var length = diff.length;
      return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
        var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);

        for (var j = 0; j < length; ++j) {
          dest[destOffset + j] = c0[j] + x * diff[j];
        }
      };
    },
    constructStiched: function constructStiched(_ref10) {
      var xref = _ref10.xref,
          isEvalSupported = _ref10.isEvalSupported,
          fn = _ref10.fn,
          dict = _ref10.dict;
      var domain = toNumberArray(dict.getArray("Domain"));

      if (!domain) {
        throw new _util.FormatError("No domain");
      }

      var inputSize = domain.length / 2;

      if (inputSize !== 1) {
        throw new _util.FormatError("Bad domain for stiched function");
      }

      var fnRefs = dict.get("Functions");
      var fns = [];

      for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
        fns.push(this.parse({
          xref: xref,
          isEvalSupported: isEvalSupported,
          fn: xref.fetchIfRef(fnRefs[i])
        }));
      }

      var bounds = toNumberArray(dict.getArray("Bounds"));
      var encode = toNumberArray(dict.getArray("Encode"));
      return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
    },
    constructStichedFromIR: function constructStichedFromIR(_ref11) {
      var xref = _ref11.xref,
          isEvalSupported = _ref11.isEvalSupported,
          IR = _ref11.IR;
      var domain = IR[1];
      var bounds = IR[2];
      var encode = IR[3];
      var fns = IR[4];
      var tmpBuf = new Float32Array(1);
      return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
        var clip = function constructStichedFromIRClip(v, min, max) {
          if (v > max) {
            v = max;
          } else if (v < min) {
            v = min;
          }

          return v;
        };

        var v = clip(src[srcOffset], domain[0], domain[1]);

        for (var i = 0, ii = bounds.length; i < ii; ++i) {
          if (v < bounds[i]) {
            break;
          }
        }

        var dmin = domain[0];

        if (i > 0) {
          dmin = bounds[i - 1];
        }

        var dmax = domain[1];

        if (i < bounds.length) {
          dmax = bounds[i];
        }

        var rmin = encode[2 * i];
        var rmax = encode[2 * i + 1];
        tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
        fns[i](tmpBuf, 0, dest, destOffset);
      };
    },
    constructPostScript: function constructPostScript(_ref12) {
      var xref = _ref12.xref,
          isEvalSupported = _ref12.isEvalSupported,
          fn = _ref12.fn,
          dict = _ref12.dict;
      var domain = toNumberArray(dict.getArray("Domain"));
      var range = toNumberArray(dict.getArray("Range"));

      if (!domain) {
        throw new _util.FormatError("No domain.");
      }

      if (!range) {
        throw new _util.FormatError("No range.");
      }

      var lexer = new _ps_parser.PostScriptLexer(fn);
      var parser = new _ps_parser.PostScriptParser(lexer);
      var code = parser.parse();
      return [CONSTRUCT_POSTSCRIPT, domain, range, code];
    },
    constructPostScriptFromIR: function constructPostScriptFromIR(_ref13) {
      var xref = _ref13.xref,
          isEvalSupported = _ref13.isEvalSupported,
          IR = _ref13.IR;
      var domain = IR[1];
      var range = IR[2];
      var code = IR[3];

      if (isEvalSupported && _util.IsEvalSupportedCached.value) {
        var compiled = new PostScriptCompiler().compile(code, domain, range);

        if (compiled) {
          return new Function("src", "srcOffset", "dest", "destOffset", compiled);
        }
      }

      (0, _util.info)("Unable to compile PS function");
      var numOutputs = range.length >> 1;
      var numInputs = domain.length >> 1;
      var evaluator = new PostScriptEvaluator(code);
      var cache = Object.create(null);
      var MAX_CACHE_SIZE = 2048 * 4;
      var cache_available = MAX_CACHE_SIZE;
      var tmpBuf = new Float32Array(numInputs);
      return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
        var i, value;
        var key = "";
        var input = tmpBuf;

        for (i = 0; i < numInputs; i++) {
          value = src[srcOffset + i];
          input[i] = value;
          key += value + "_";
        }

        var cachedValue = cache[key];

        if (cachedValue !== undefined) {
          dest.set(cachedValue, destOffset);
          return;
        }

        var output = new Float32Array(numOutputs);
        var stack = evaluator.execute(input);
        var stackIndex = stack.length - numOutputs;

        for (i = 0; i < numOutputs; i++) {
          value = stack[stackIndex + i];
          var bound = range[i * 2];

          if (value < bound) {
            value = bound;
          } else {
            bound = range[i * 2 + 1];

            if (value > bound) {
              value = bound;
            }
          }

          output[i] = value;
        }

        if (cache_available > 0) {
          cache_available--;
          cache[key] = output;
        }

        dest.set(output, destOffset);
      };
    }
  };
}();

function isPDFFunction(v) {
  var fnDict;

  if (_typeof(v) !== "object") {
    return false;
  } else if ((0, _primitives.isDict)(v)) {
    fnDict = v;
  } else if ((0, _primitives.isStream)(v)) {
    fnDict = v.dict;
  } else {
    return false;
  }

  return fnDict.has("FunctionType");
}

var PostScriptStack = function PostScriptStackClosure() {
  var MAX_STACK_SIZE = 100;

  function PostScriptStack(initialStack) {
    this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
  }

  PostScriptStack.prototype = {
    push: function PostScriptStack_push(value) {
      if (this.stack.length >= MAX_STACK_SIZE) {
        throw new Error("PostScript function stack overflow.");
      }

      this.stack.push(value);
    },
    pop: function PostScriptStack_pop() {
      if (this.stack.length <= 0) {
        throw new Error("PostScript function stack underflow.");
      }

      return this.stack.pop();
    },
    copy: function PostScriptStack_copy(n) {
      if (this.stack.length + n >= MAX_STACK_SIZE) {
        throw new Error("PostScript function stack overflow.");
      }

      var stack = this.stack;

      for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
        stack.push(stack[i]);
      }
    },
    index: function PostScriptStack_index(n) {
      this.push(this.stack[this.stack.length - n - 1]);
    },
    roll: function PostScriptStack_roll(n, p) {
      var stack = this.stack;
      var l = stack.length - n;
      var r = stack.length - 1,
          c = l + (p - Math.floor(p / n) * n),
          i,
          j,
          t;

      for (i = l, j = r; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }

      for (i = l, j = c - 1; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }

      for (i = c, j = r; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }
    }
  };
  return PostScriptStack;
}();

var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
  function PostScriptEvaluator(operators) {
    this.operators = operators;
  }

  PostScriptEvaluator.prototype = {
    execute: function PostScriptEvaluator_execute(initialStack) {
      var stack = new PostScriptStack(initialStack);
      var counter = 0;
      var operators = this.operators;
      var length = operators.length;
      var operator, a, b;

      while (counter < length) {
        operator = operators[counter++];

        if (typeof operator === "number") {
          stack.push(operator);
          continue;
        }

        switch (operator) {
          case "jz":
            b = stack.pop();
            a = stack.pop();

            if (!a) {
              counter = b;
            }

            break;

          case "j":
            a = stack.pop();
            counter = a;
            break;

          case "abs":
            a = stack.pop();
            stack.push(Math.abs(a));
            break;

          case "add":
            b = stack.pop();
            a = stack.pop();
            stack.push(a + b);
            break;

          case "and":
            b = stack.pop();
            a = stack.pop();

            if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
              stack.push(a && b);
            } else {
              stack.push(a & b);
            }

            break;

          case "atan":
            a = stack.pop();
            stack.push(Math.atan(a));
            break;

          case "bitshift":
            b = stack.pop();
            a = stack.pop();

            if (a > 0) {
              stack.push(a << b);
            } else {
              stack.push(a >> b);
            }

            break;

          case "ceiling":
            a = stack.pop();
            stack.push(Math.ceil(a));
            break;

          case "copy":
            a = stack.pop();
            stack.copy(a);
            break;

          case "cos":
            a = stack.pop();
            stack.push(Math.cos(a));
            break;

          case "cvi":
            a = stack.pop() | 0;
            stack.push(a);
            break;

          case "cvr":
            break;

          case "div":
            b = stack.pop();
            a = stack.pop();
            stack.push(a / b);
            break;

          case "dup":
            stack.copy(1);
            break;

          case "eq":
            b = stack.pop();
            a = stack.pop();
            stack.push(a === b);
            break;

          case "exch":
            stack.roll(2, 1);
            break;

          case "exp":
            b = stack.pop();
            a = stack.pop();
            stack.push(Math.pow(a, b));
            break;

          case "false":
            stack.push(false);
            break;

          case "floor":
            a = stack.pop();
            stack.push(Math.floor(a));
            break;

          case "ge":
            b = stack.pop();
            a = stack.pop();
            stack.push(a >= b);
            break;

          case "gt":
            b = stack.pop();
            a = stack.pop();
            stack.push(a > b);
            break;

          case "idiv":
            b = stack.pop();
            a = stack.pop();
            stack.push(a / b | 0);
            break;

          case "index":
            a = stack.pop();
            stack.index(a);
            break;

          case "le":
            b = stack.pop();
            a = stack.pop();
            stack.push(a <= b);
            break;

          case "ln":
            a = stack.pop();
            stack.push(Math.log(a));
            break;

          case "log":
            a = stack.pop();
            stack.push(Math.log(a) / Math.LN10);
            break;

          case "lt":
            b = stack.pop();
            a = stack.pop();
            stack.push(a < b);
            break;

          case "mod":
            b = stack.pop();
            a = stack.pop();
            stack.push(a % b);
            break;

          case "mul":
            b = stack.pop();
            a = stack.pop();
            stack.push(a * b);
            break;

          case "ne":
            b = stack.pop();
            a = stack.pop();
            stack.push(a !== b);
            break;

          case "neg":
            a = stack.pop();
            stack.push(-a);
            break;

          case "not":
            a = stack.pop();

            if ((0, _util.isBool)(a)) {
              stack.push(!a);
            } else {
              stack.push(~a);
            }

            break;

          case "or":
            b = stack.pop();
            a = stack.pop();

            if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
              stack.push(a || b);
            } else {
              stack.push(a | b);
            }

            break;

          case "pop":
            stack.pop();
            break;

          case "roll":
            b = stack.pop();
            a = stack.pop();
            stack.roll(a, b);
            break;

          case "round":
            a = stack.pop();
            stack.push(Math.round(a));
            break;

          case "sin":
            a = stack.pop();
            stack.push(Math.sin(a));
            break;

          case "sqrt":
            a = stack.pop();
            stack.push(Math.sqrt(a));
            break;

          case "sub":
            b = stack.pop();
            a = stack.pop();
            stack.push(a - b);
            break;

          case "true":
            stack.push(true);
            break;

          case "truncate":
            a = stack.pop();
            a = a < 0 ? Math.ceil(a) : Math.floor(a);
            stack.push(a);
            break;

          case "xor":
            b = stack.pop();
            a = stack.pop();

            if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
              stack.push(a !== b);
            } else {
              stack.push(a ^ b);
            }

            break;

          default:
            throw new _util.FormatError("Unknown operator ".concat(operator));
        }
      }

      return stack.stack;
    }
  };
  return PostScriptEvaluator;
}();

exports.PostScriptEvaluator = PostScriptEvaluator;

var PostScriptCompiler = function PostScriptCompilerClosure() {
  function AstNode(type) {
    this.type = type;
  }

  AstNode.prototype.visit = function (visitor) {
    (0, _util.unreachable)("abstract method");
  };

  function AstArgument(index, min, max) {
    AstNode.call(this, "args");
    this.index = index;
    this.min = min;
    this.max = max;
  }

  AstArgument.prototype = Object.create(AstNode.prototype);

  AstArgument.prototype.visit = function (visitor) {
    visitor.visitArgument(this);
  };

  function AstLiteral(number) {
    AstNode.call(this, "literal");
    this.number = number;
    this.min = number;
    this.max = number;
  }

  AstLiteral.prototype = Object.create(AstNode.prototype);

  AstLiteral.prototype.visit = function (visitor) {
    visitor.visitLiteral(this);
  };

  function AstBinaryOperation(op, arg1, arg2, min, max) {
    AstNode.call(this, "binary");
    this.op = op;
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.min = min;
    this.max = max;
  }

  AstBinaryOperation.prototype = Object.create(AstNode.prototype);

  AstBinaryOperation.prototype.visit = function (visitor) {
    visitor.visitBinaryOperation(this);
  };

  function AstMin(arg, max) {
    AstNode.call(this, "max");
    this.arg = arg;
    this.min = arg.min;
    this.max = max;
  }

  AstMin.prototype = Object.create(AstNode.prototype);

  AstMin.prototype.visit = function (visitor) {
    visitor.visitMin(this);
  };

  function AstVariable(index, min, max) {
    AstNode.call(this, "var");
    this.index = index;
    this.min = min;
    this.max = max;
  }

  AstVariable.prototype = Object.create(AstNode.prototype);

  AstVariable.prototype.visit = function (visitor) {
    visitor.visitVariable(this);
  };

  function AstVariableDefinition(variable, arg) {
    AstNode.call(this, "definition");
    this.variable = variable;
    this.arg = arg;
  }

  AstVariableDefinition.prototype = Object.create(AstNode.prototype);

  AstVariableDefinition.prototype.visit = function (visitor) {
    visitor.visitVariableDefinition(this);
  };

  function ExpressionBuilderVisitor() {
    this.parts = [];
  }

  ExpressionBuilderVisitor.prototype = {
    visitArgument: function visitArgument(arg) {
      this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
    },
    visitVariable: function visitVariable(variable) {
      this.parts.push("v", variable.index);
    },
    visitLiteral: function visitLiteral(literal) {
      this.parts.push(literal.number);
    },
    visitBinaryOperation: function visitBinaryOperation(operation) {
      this.parts.push("(");
      operation.arg1.visit(this);
      this.parts.push(" ", operation.op, " ");
      operation.arg2.visit(this);
      this.parts.push(")");
    },
    visitVariableDefinition: function visitVariableDefinition(definition) {
      this.parts.push("var ");
      definition.variable.visit(this);
      this.parts.push(" = ");
      definition.arg.visit(this);
      this.parts.push(";");
    },
    visitMin: function visitMin(max) {
      this.parts.push("Math.min(");
      max.arg.visit(this);
      this.parts.push(", ", max.max, ")");
    },
    toString: function toString() {
      return this.parts.join("");
    }
  };

  function buildAddOperation(num1, num2) {
    if (num2.type === "literal" && num2.number === 0) {
      return num1;
    }

    if (num1.type === "literal" && num1.number === 0) {
      return num2;
    }

    if (num2.type === "literal" && num1.type === "literal") {
      return new AstLiteral(num1.number + num2.number);
    }

    return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
  }

  function buildMulOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return new AstLiteral(0);
      } else if (num2.number === 1) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number * num2.number);
      }
    }

    if (num1.type === "literal") {
      if (num1.number === 0) {
        return new AstLiteral(0);
      } else if (num1.number === 1) {
        return num2;
      }
    }

    var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    return new AstBinaryOperation("*", num1, num2, min, max);
  }

  function buildSubOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number - num2.number);
      }
    }

    if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
      return num2.arg2;
    }

    return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
  }

  function buildMinOperation(num1, max) {
    if (num1.min >= max) {
      return new AstLiteral(max);
    } else if (num1.max <= max) {
      return num1;
    }

    return new AstMin(num1, max);
  }

  function PostScriptCompiler() {}

  PostScriptCompiler.prototype = {
    compile: function PostScriptCompiler_compile(code, domain, range) {
      var stack = [];
      var instructions = [];
      var inputSize = domain.length >> 1,
          outputSize = range.length >> 1;
      var lastRegister = 0;
      var n, j;
      var num1, num2, ast1, ast2, tmpVar, item;

      for (var i = 0; i < inputSize; i++) {
        stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
      }

      for (var _i = 0, ii = code.length; _i < ii; _i++) {
        item = code[_i];

        if (typeof item === "number") {
          stack.push(new AstLiteral(item));
          continue;
        }

        switch (item) {
          case "add":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildAddOperation(num1, num2));
            break;

          case "cvr":
            if (stack.length < 1) {
              return null;
            }

            break;

          case "mul":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildMulOperation(num1, num2));
            break;

          case "sub":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildSubOperation(num1, num2));
            break;

          case "exch":
            if (stack.length < 2) {
              return null;
            }

            ast1 = stack.pop();
            ast2 = stack.pop();
            stack.push(ast1, ast2);
            break;

          case "pop":
            if (stack.length < 1) {
              return null;
            }

            stack.pop();
            break;

          case "index":
            if (stack.length < 1) {
              return null;
            }

            num1 = stack.pop();

            if (num1.type !== "literal") {
              return null;
            }

            n = num1.number;

            if (n < 0 || !Number.isInteger(n) || stack.length < n) {
              return null;
            }

            ast1 = stack[stack.length - n - 1];

            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }

            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - n - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;

          case "dup":
            if (stack.length < 1) {
              return null;
            }

            if (typeof code[_i + 1] === "number" && code[_i + 2] === "gt" && code[_i + 3] === _i + 7 && code[_i + 4] === "jz" && code[_i + 5] === "pop" && code[_i + 6] === code[_i + 1]) {
              num1 = stack.pop();
              stack.push(buildMinOperation(num1, code[_i + 1]));
              _i += 6;
              break;
            }

            ast1 = stack[stack.length - 1];

            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }

            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;

          case "roll":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();

            if (num2.type !== "literal" || num1.type !== "literal") {
              return null;
            }

            j = num2.number;
            n = num1.number;

            if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
              return null;
            }

            j = (j % n + n) % n;

            if (j === 0) {
              break;
            }

            Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
            break;

          default:
            return null;
        }
      }

      if (stack.length !== outputSize) {
        return null;
      }

      var result = [];
      instructions.forEach(function (instruction) {
        var statementBuilder = new ExpressionBuilderVisitor();
        instruction.visit(statementBuilder);
        result.push(statementBuilder.toString());
      });
      stack.forEach(function (expr, i) {
        var statementBuilder = new ExpressionBuilderVisitor();
        expr.visit(statementBuilder);
        var min = range[i * 2],
            max = range[i * 2 + 1];
        var out = [statementBuilder.toString()];

        if (min > expr.min) {
          out.unshift("Math.max(", min, ", ");
          out.push(")");
        }

        if (max < expr.max) {
          out.unshift("Math.min(", max, ", ");
          out.push(")");
        }

        out.unshift("dest[destOffset + ", i, "] = ");
        out.push(";");
        result.push(out.join(""));
      });
      return result.join("\n");
    }
  };
  return PostScriptCompiler;
}();

exports.PostScriptCompiler = PostScriptCompiler;

/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptParser = exports.PostScriptLexer = void 0;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PostScriptParser = /*#__PURE__*/function () {
  function PostScriptParser(lexer) {
    _classCallCheck(this, PostScriptParser);

    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }

  _createClass(PostScriptParser, [{
    key: "nextToken",
    value: function nextToken() {
      this.prev = this.token;
      this.token = this.lexer.getToken();
    }
  }, {
    key: "accept",
    value: function accept(type) {
      if (this.token.type === type) {
        this.nextToken();
        return true;
      }

      return false;
    }
  }, {
    key: "expect",
    value: function expect(type) {
      if (this.accept(type)) {
        return true;
      }

      throw new _util.FormatError("Unexpected symbol: found ".concat(this.token.type, " expected ").concat(type, "."));
    }
  }, {
    key: "parse",
    value: function parse() {
      this.nextToken();
      this.expect(PostScriptTokenTypes.LBRACE);
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      return this.operators;
    }
  }, {
    key: "parseBlock",
    value: function parseBlock() {
      while (true) {
        if (this.accept(PostScriptTokenTypes.NUMBER)) {
          this.operators.push(this.prev.value);
        } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
          this.operators.push(this.prev.value);
        } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
          this.parseCondition();
        } else {
          return;
        }
      }
    }
  }, {
    key: "parseCondition",
    value: function parseCondition() {
      var conditionLocation = this.operators.length;
      this.operators.push(null, null);
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);

      if (this.accept(PostScriptTokenTypes.IF)) {
        this.operators[conditionLocation] = this.operators.length;
        this.operators[conditionLocation + 1] = "jz";
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        var jumpLocation = this.operators.length;
        this.operators.push(null, null);
        var endOfTrue = this.operators.length;
        this.parseBlock();
        this.expect(PostScriptTokenTypes.RBRACE);
        this.expect(PostScriptTokenTypes.IFELSE);
        this.operators[jumpLocation] = this.operators.length;
        this.operators[jumpLocation + 1] = "j";
        this.operators[conditionLocation] = endOfTrue;
        this.operators[conditionLocation + 1] = "jz";
      } else {
        throw new _util.FormatError("PS Function: error parsing conditional.");
      }
    }
  }]);

  return PostScriptParser;
}();

exports.PostScriptParser = PostScriptParser;
var PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};

var PostScriptToken = function PostScriptTokenClosure() {
  var opCache = Object.create(null);

  var PostScriptToken = /*#__PURE__*/function () {
    function PostScriptToken(type, value) {
      _classCallCheck(this, PostScriptToken);

      this.type = type;
      this.value = value;
    }

    _createClass(PostScriptToken, null, [{
      key: "getOperator",
      value: function getOperator(op) {
        var opValue = opCache[op];

        if (opValue) {
          return opValue;
        }

        return opCache[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
      }
    }, {
      key: "LBRACE",
      get: function get() {
        return (0, _util.shadow)(this, "LBRACE", new PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
      }
    }, {
      key: "RBRACE",
      get: function get() {
        return (0, _util.shadow)(this, "RBRACE", new PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
      }
    }, {
      key: "IF",
      get: function get() {
        return (0, _util.shadow)(this, "IF", new PostScriptToken(PostScriptTokenTypes.IF, "IF"));
      }
    }, {
      key: "IFELSE",
      get: function get() {
        return (0, _util.shadow)(this, "IFELSE", new PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
      }
    }]);

    return PostScriptToken;
  }();

  return PostScriptToken;
}();

var PostScriptLexer = /*#__PURE__*/function () {
  function PostScriptLexer(stream) {
    _classCallCheck(this, PostScriptLexer);

    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }

  _createClass(PostScriptLexer, [{
    key: "nextChar",
    value: function nextChar() {
      return this.currentChar = this.stream.getByte();
    }
  }, {
    key: "getToken",
    value: function getToken() {
      var comment = false;
      var ch = this.currentChar;

      while (true) {
        if (ch < 0) {
          return _primitives.EOF;
        }

        if (comment) {
          if (ch === 0x0a || ch === 0x0d) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
          break;
        }

        ch = this.nextChar();
      }

      switch (ch | 0) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 0x2b:
        case 0x2d:
        case 0x2e:
          return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());

        case 0x7b:
          this.nextChar();
          return PostScriptToken.LBRACE;

        case 0x7d:
          this.nextChar();
          return PostScriptToken.RBRACE;
      }

      var strBuf = this.strBuf;
      strBuf.length = 0;
      strBuf[0] = String.fromCharCode(ch);

      while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5a || ch >= 0x61 && ch <= 0x7a)) {
        strBuf.push(String.fromCharCode(ch));
      }

      var str = strBuf.join("");

      switch (str.toLowerCase()) {
        case "if":
          return PostScriptToken.IF;

        case "ifelse":
          return PostScriptToken.IFELSE;

        default:
          return PostScriptToken.getOperator(str);
      }
    }
  }, {
    key: "getNumber",
    value: function getNumber() {
      var ch = this.currentChar;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      strBuf[0] = String.fromCharCode(ch);

      while ((ch = this.nextChar()) >= 0) {
        if (ch >= 0x30 && ch <= 0x39 || ch === 0x2d || ch === 0x2e) {
          strBuf.push(String.fromCharCode(ch));
        } else {
          break;
        }
      }

      var value = parseFloat(strBuf.join(""));

      if (isNaN(value)) {
        throw new _util.FormatError("Invalid floating point number: ".concat(value));
      }

      return value;
    }
  }]);

  return PostScriptLexer;
}();

exports.PostScriptLexer = PostScriptLexer;

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bidi = bidi;

var _util = __w_pdfjs_require__(4);

var baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
var arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];

function isOdd(i) {
  return (i & 1) !== 0;
}

function isEven(i) {
  return (i & 1) === 0;
}

function findUnequal(arr, start, value) {
  for (var j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }

  return j;
}

function setValues(arr, start, end, value) {
  for (var j = start; j < end; ++j) {
    arr[j] = value;
  }
}

function reverseValues(arr, start, end) {
  for (var i = start, j = end - 1; i < j; ++i, --j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}

function createBidiText(str, isLTR) {
  var vertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var dir = "ltr";

  if (vertical) {
    dir = "ttb";
  } else if (!isLTR) {
    dir = "rtl";
  }

  return {
    str: str,
    dir: dir
  };
}

var chars = [];
var types = [];

function bidi(str, startLevel, vertical) {
  var isLTR = true;
  var strLength = str.length;

  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }

  chars.length = strLength;
  types.length = strLength;
  var numBidi = 0;
  var i, ii;

  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    var charCode = str.charCodeAt(i);
    var charType = "L";

    if (charCode <= 0x00ff) {
      charType = baseTypes[charCode];
    } else if (0x0590 <= charCode && charCode <= 0x05f4) {
      charType = "R";
    } else if (0x0600 <= charCode && charCode <= 0x06ff) {
      charType = arabicTypes[charCode & 0xff];

      if (!charType) {
        (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
      }
    } else if (0x0700 <= charCode && charCode <= 0x08ac) {
      charType = "AL";
    }

    if (charType === "R" || charType === "AL" || charType === "AN") {
      numBidi++;
    }

    types[i] = charType;
  }

  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }

  if (startLevel === -1) {
    if (numBidi / strLength < 0.3) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }

  var levels = [];

  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }

  var e = isOdd(startLevel) ? "R" : "L";
  var sor = e;
  var eor = sor;
  var lastType = sor;

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "NSM") {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }

  lastType = sor;
  var t;

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "EN") {
      types[i] = lastType === "AL" ? "AN" : "EN";
    } else if (t === "R" || t === "L" || t === "AL") {
      lastType = t;
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "AL") {
      types[i] = "R";
    }
  }

  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
      types[i] = "EN";
    }

    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "EN") {
      var j;

      for (j = i - 1; j >= 0; --j) {
        if (types[j] !== "ET") {
          break;
        }

        types[j] = "EN";
      }

      for (j = i + 1; j < strLength; ++j) {
        if (types[j] !== "ET") {
          break;
        }

        types[j] = "EN";
      }
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
      types[i] = "ON";
    }
  }

  lastType = sor;

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "EN") {
      types[i] = lastType === "L" ? "L" : "EN";
    } else if (t === "R" || t === "L") {
      lastType = t;
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      var end = findUnequal(types, i + 1, "ON");
      var before = sor;

      if (i > 0) {
        before = types[i - 1];
      }

      var after = eor;

      if (end + 1 < strLength) {
        after = types[end + 1];
      }

      if (before !== "L") {
        before = "R";
      }

      if (after !== "L") {
        after = "R";
      }

      if (before === after) {
        setValues(types, i, end, before);
      }

      i = end - 1;
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      types[i] = e;
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (isEven(levels[i])) {
      if (t === "R") {
        levels[i] += 1;
      } else if (t === "AN" || t === "EN") {
        levels[i] += 2;
      }
    } else {
      if (t === "L" || t === "AN" || t === "EN") {
        levels[i] += 1;
      }
    }
  }

  var highestLevel = -1;
  var lowestOddLevel = 99;
  var level;

  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];

    if (highestLevel < level) {
      highestLevel = level;
    }

    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }

  for (level = highestLevel; level >= lowestOddLevel; --level) {
    var start = -1;

    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }

    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }

  for (i = 0, ii = chars.length; i < ii; ++i) {
    var ch = chars[i];

    if (ch === "<" || ch === ">") {
      chars[i] = "";
    }
  }

  return createBidiText(chars.join(""), isLTR);
}

/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMetrics = void 0;

var _core_utils = __w_pdfjs_require__(138);

var getMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = 600;
  t["Courier-Bold"] = 600;
  t["Courier-BoldOblique"] = 600;
  t["Courier-Oblique"] = 600;
  t.Helvetica = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t.Symbol = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.universal = 713;
    t.numbersign = 500;
    t.existential = 549;
    t.percent = 833;
    t.ampersand = 778;
    t.suchthat = 439;
    t.parenleft = 333;
    t.parenright = 333;
    t.asteriskmath = 500;
    t.plus = 549;
    t.comma = 250;
    t.minus = 549;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 549;
    t.equal = 549;
    t.greater = 549;
    t.question = 444;
    t.congruent = 549;
    t.Alpha = 722;
    t.Beta = 667;
    t.Chi = 722;
    t.Delta = 612;
    t.Epsilon = 611;
    t.Phi = 763;
    t.Gamma = 603;
    t.Eta = 722;
    t.Iota = 333;
    t.theta1 = 631;
    t.Kappa = 722;
    t.Lambda = 686;
    t.Mu = 889;
    t.Nu = 722;
    t.Omicron = 722;
    t.Pi = 768;
    t.Theta = 741;
    t.Rho = 556;
    t.Sigma = 592;
    t.Tau = 611;
    t.Upsilon = 690;
    t.sigma1 = 439;
    t.Omega = 768;
    t.Xi = 645;
    t.Psi = 795;
    t.Zeta = 611;
    t.bracketleft = 333;
    t.therefore = 863;
    t.bracketright = 333;
    t.perpendicular = 658;
    t.underscore = 500;
    t.radicalex = 500;
    t.alpha = 631;
    t.beta = 549;
    t.chi = 549;
    t.delta = 494;
    t.epsilon = 439;
    t.phi = 521;
    t.gamma = 411;
    t.eta = 603;
    t.iota = 329;
    t.phi1 = 603;
    t.kappa = 549;
    t.lambda = 549;
    t.mu = 576;
    t.nu = 521;
    t.omicron = 549;
    t.pi = 549;
    t.theta = 521;
    t.rho = 549;
    t.sigma = 603;
    t.tau = 439;
    t.upsilon = 576;
    t.omega1 = 713;
    t.omega = 686;
    t.xi = 493;
    t.psi = 686;
    t.zeta = 494;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.similar = 549;
    t.Euro = 750;
    t.Upsilon1 = 620;
    t.minute = 247;
    t.lessequal = 549;
    t.fraction = 167;
    t.infinity = 713;
    t.florin = 500;
    t.club = 753;
    t.diamond = 753;
    t.heart = 753;
    t.spade = 753;
    t.arrowboth = 1042;
    t.arrowleft = 987;
    t.arrowup = 603;
    t.arrowright = 987;
    t.arrowdown = 603;
    t.degree = 400;
    t.plusminus = 549;
    t.second = 411;
    t.greaterequal = 549;
    t.multiply = 549;
    t.proportional = 713;
    t.partialdiff = 494;
    t.bullet = 460;
    t.divide = 549;
    t.notequal = 549;
    t.equivalence = 549;
    t.approxequal = 549;
    t.ellipsis = 1000;
    t.arrowvertex = 603;
    t.arrowhorizex = 1000;
    t.carriagereturn = 658;
    t.aleph = 823;
    t.Ifraktur = 686;
    t.Rfraktur = 795;
    t.weierstrass = 987;
    t.circlemultiply = 768;
    t.circleplus = 768;
    t.emptyset = 823;
    t.intersection = 768;
    t.union = 768;
    t.propersuperset = 713;
    t.reflexsuperset = 713;
    t.notsubset = 713;
    t.propersubset = 713;
    t.reflexsubset = 713;
    t.element = 713;
    t.notelement = 713;
    t.angle = 768;
    t.gradient = 713;
    t.registerserif = 790;
    t.copyrightserif = 790;
    t.trademarkserif = 890;
    t.product = 823;
    t.radical = 549;
    t.dotmath = 250;
    t.logicalnot = 713;
    t.logicaland = 603;
    t.logicalor = 603;
    t.arrowdblboth = 1042;
    t.arrowdblleft = 987;
    t.arrowdblup = 603;
    t.arrowdblright = 987;
    t.arrowdbldown = 603;
    t.lozenge = 494;
    t.angleleft = 329;
    t.registersans = 790;
    t.copyrightsans = 790;
    t.trademarksans = 786;
    t.summation = 713;
    t.parenlefttp = 384;
    t.parenleftex = 384;
    t.parenleftbt = 384;
    t.bracketlefttp = 384;
    t.bracketleftex = 384;
    t.bracketleftbt = 384;
    t.bracelefttp = 494;
    t.braceleftmid = 494;
    t.braceleftbt = 494;
    t.braceex = 494;
    t.angleright = 329;
    t.integral = 274;
    t.integraltp = 686;
    t.integralex = 686;
    t.integralbt = 686;
    t.parenrighttp = 384;
    t.parenrightex = 384;
    t.parenrightbt = 384;
    t.bracketrighttp = 384;
    t.bracketrightex = 384;
    t.bracketrightbt = 384;
    t.bracerighttp = 494;
    t.bracerightmid = 494;
    t.bracerightbt = 494;
    t.apple = 790;
  });
  t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 408;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 564;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 564;
    t.equal = 564;
    t.greater = 564;
    t.question = 444;
    t.at = 921;
    t.A = 722;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 556;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 389;
    t.K = 722;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 556;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 722;
    t.W = 944;
    t.X = 722;
    t.Y = 722;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 469;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 444;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 333;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.asciitilde = 541;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 180;
    t.quotedblleft = 444;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 453;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 444;
    t.quotedblright = 444;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 444;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 889;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 444;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 564;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 444;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 444;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 444;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 444;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 444;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 444;
    t.Amacron = 722;
    t.rcaron = 333;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 556;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 588;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 564;
    t.uacute = 500;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 444;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 722;
    t.Iacute = 333;
    t.plusminus = 564;
    t.brokenbar = 200;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 333;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 326;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 444;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 344;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 722;
    t.zdotaccent = 444;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 500;
    t.minus = 564;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 564;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 1000;
    t.ampersand = 833;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 930;
    t.A = 722;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 778;
    t.L = 667;
    t.M = 944;
    t.N = 722;
    t.O = 778;
    t.P = 611;
    t.Q = 778;
    t.R = 722;
    t.S = 556;
    t.T = 667;
    t.U = 722;
    t.V = 722;
    t.W = 1000;
    t.X = 722;
    t.Y = 722;
    t.Z = 667;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 581;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 556;
    t.c = 444;
    t.d = 556;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 333;
    t.k = 556;
    t.l = 278;
    t.m = 833;
    t.n = 556;
    t.o = 500;
    t.p = 556;
    t.q = 556;
    t.r = 444;
    t.s = 389;
    t.t = 333;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 394;
    t.bar = 220;
    t.braceright = 394;
    t.asciitilde = 520;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 540;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 300;
    t.Lslash = 667;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 330;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 556;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 570;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 667;
    t.Cacute = 722;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 722;
    t.rcaron = 444;
    t.ccedilla = 444;
    t.Zdotaccent = 667;
    t.Thorn = 611;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 556;
    t.dcaron = 672;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 667;
    t.partialdiff = 494;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 778;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 444;
    t.omacron = 500;
    t.Zacute = 667;
    t.Zcaron = 667;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 416;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 300;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 394;
    t.Kcommaaccent = 778;
    t.Lacute = 667;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 667;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 444;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 667;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 444;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 556;
    t.minus = 570;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 333;
    t.logicalnot = 570;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 389;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 832;
    t.A = 667;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 667;
    t.F = 667;
    t.G = 722;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 667;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 889;
    t.X = 667;
    t.Y = 611;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 570;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 556;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 556;
    t.v = 444;
    t.w = 667;
    t.x = 500;
    t.y = 444;
    t.z = 389;
    t.braceleft = 348;
    t.bar = 220;
    t.braceright = 348;
    t.asciitilde = 570;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 500;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 944;
    t.ordfeminine = 266;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 300;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 611;
    t.divide = 570;
    t.Yacute = 611;
    t.Acircumflex = 667;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 667;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 608;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 444;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 722;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 366;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 576;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 382;
    t.Kcommaaccent = 667;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 500;
    t.minus = 606;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 606;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 420;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 675;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 675;
    t.equal = 675;
    t.greater = 675;
    t.question = 500;
    t.at = 920;
    t.A = 611;
    t.B = 611;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 611;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 444;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 667;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 611;
    t.S = 500;
    t.T = 556;
    t.U = 722;
    t.V = 611;
    t.W = 833;
    t.X = 611;
    t.Y = 556;
    t.Z = 556;
    t.bracketleft = 389;
    t.backslash = 278;
    t.bracketright = 389;
    t.asciicircum = 422;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 278;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 444;
    t.l = 278;
    t.m = 722;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 444;
    t.w = 667;
    t.x = 444;
    t.y = 444;
    t.z = 389;
    t.braceleft = 400;
    t.bar = 275;
    t.braceright = 400;
    t.asciitilde = 541;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 214;
    t.quotedblleft = 556;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 523;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 556;
    t.quotedblright = 556;
    t.guillemotright = 500;
    t.ellipsis = 889;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 889;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 556;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 667;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 556;
    t.divide = 675;
    t.Yacute = 556;
    t.Acircumflex = 611;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 667;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 556;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 611;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 500;
    t.Amacron = 611;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 556;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 611;
    t.Sacute = 500;
    t.dcaron = 544;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 611;
    t.Abreve = 611;
    t.multiply = 675;
    t.uacute = 500;
    t.Tcaron = 556;
    t.partialdiff = 476;
    t.ydieresis = 444;
    t.Nacute = 667;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 667;
    t.Iacute = 333;
    t.plusminus = 675;
    t.brokenbar = 275;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 556;
    t.Zcaron = 556;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 300;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 611;
    t.Adieresis = 611;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 500;
    t.lcaron = 300;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 500;
    t.Scommaaccent = 500;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 667;
    t.otilde = 500;
    t.Rcommaaccent = 611;
    t.Lcommaaccent = 556;
    t.Atilde = 611;
    t.Aogonek = 611;
    t.Aring = 611;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 444;
    t.minus = 675;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 675;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.a1 = 974;
    t.a2 = 961;
    t.a202 = 974;
    t.a3 = 980;
    t.a4 = 719;
    t.a5 = 789;
    t.a119 = 790;
    t.a118 = 791;
    t.a117 = 690;
    t.a11 = 960;
    t.a12 = 939;
    t.a13 = 549;
    t.a14 = 855;
    t.a15 = 911;
    t.a16 = 933;
    t.a105 = 911;
    t.a17 = 945;
    t.a18 = 974;
    t.a19 = 755;
    t.a20 = 846;
    t.a21 = 762;
    t.a22 = 761;
    t.a23 = 571;
    t.a24 = 677;
    t.a25 = 763;
    t.a26 = 760;
    t.a27 = 759;
    t.a28 = 754;
    t.a6 = 494;
    t.a7 = 552;
    t.a8 = 537;
    t.a9 = 577;
    t.a10 = 692;
    t.a29 = 786;
    t.a30 = 788;
    t.a31 = 788;
    t.a32 = 790;
    t.a33 = 793;
    t.a34 = 794;
    t.a35 = 816;
    t.a36 = 823;
    t.a37 = 789;
    t.a38 = 841;
    t.a39 = 823;
    t.a40 = 833;
    t.a41 = 816;
    t.a42 = 831;
    t.a43 = 923;
    t.a44 = 744;
    t.a45 = 723;
    t.a46 = 749;
    t.a47 = 790;
    t.a48 = 792;
    t.a49 = 695;
    t.a50 = 776;
    t.a51 = 768;
    t.a52 = 792;
    t.a53 = 759;
    t.a54 = 707;
    t.a55 = 708;
    t.a56 = 682;
    t.a57 = 701;
    t.a58 = 826;
    t.a59 = 815;
    t.a60 = 789;
    t.a61 = 789;
    t.a62 = 707;
    t.a63 = 687;
    t.a64 = 696;
    t.a65 = 689;
    t.a66 = 786;
    t.a67 = 787;
    t.a68 = 713;
    t.a69 = 791;
    t.a70 = 785;
    t.a71 = 791;
    t.a72 = 873;
    t.a73 = 761;
    t.a74 = 762;
    t.a203 = 762;
    t.a75 = 759;
    t.a204 = 759;
    t.a76 = 892;
    t.a77 = 892;
    t.a78 = 788;
    t.a79 = 784;
    t.a81 = 438;
    t.a82 = 138;
    t.a83 = 277;
    t.a84 = 415;
    t.a97 = 392;
    t.a98 = 392;
    t.a99 = 668;
    t.a100 = 668;
    t.a89 = 390;
    t.a90 = 390;
    t.a93 = 317;
    t.a94 = 317;
    t.a91 = 276;
    t.a92 = 276;
    t.a205 = 509;
    t.a85 = 509;
    t.a206 = 410;
    t.a86 = 410;
    t.a87 = 234;
    t.a88 = 234;
    t.a95 = 334;
    t.a96 = 334;
    t.a101 = 732;
    t.a102 = 544;
    t.a103 = 544;
    t.a104 = 910;
    t.a106 = 667;
    t.a107 = 760;
    t.a108 = 760;
    t.a112 = 776;
    t.a111 = 595;
    t.a110 = 694;
    t.a109 = 626;
    t.a120 = 788;
    t.a121 = 788;
    t.a122 = 788;
    t.a123 = 788;
    t.a124 = 788;
    t.a125 = 788;
    t.a126 = 788;
    t.a127 = 788;
    t.a128 = 788;
    t.a129 = 788;
    t.a130 = 788;
    t.a131 = 788;
    t.a132 = 788;
    t.a133 = 788;
    t.a134 = 788;
    t.a135 = 788;
    t.a136 = 788;
    t.a137 = 788;
    t.a138 = 788;
    t.a139 = 788;
    t.a140 = 788;
    t.a141 = 788;
    t.a142 = 788;
    t.a143 = 788;
    t.a144 = 788;
    t.a145 = 788;
    t.a146 = 788;
    t.a147 = 788;
    t.a148 = 788;
    t.a149 = 788;
    t.a150 = 788;
    t.a151 = 788;
    t.a152 = 788;
    t.a153 = 788;
    t.a154 = 788;
    t.a155 = 788;
    t.a156 = 788;
    t.a157 = 788;
    t.a158 = 788;
    t.a159 = 788;
    t.a160 = 894;
    t.a161 = 838;
    t.a163 = 1016;
    t.a164 = 458;
    t.a196 = 748;
    t.a165 = 924;
    t.a192 = 748;
    t.a166 = 918;
    t.a167 = 927;
    t.a168 = 928;
    t.a169 = 928;
    t.a170 = 834;
    t.a171 = 873;
    t.a172 = 828;
    t.a173 = 924;
    t.a162 = 924;
    t.a174 = 917;
    t.a175 = 930;
    t.a176 = 931;
    t.a177 = 463;
    t.a178 = 883;
    t.a179 = 836;
    t.a193 = 836;
    t.a180 = 867;
    t.a199 = 867;
    t.a181 = 696;
    t.a200 = 696;
    t.a182 = 874;
    t.a201 = 874;
    t.a183 = 760;
    t.a184 = 946;
    t.a197 = 771;
    t.a185 = 865;
    t.a194 = 771;
    t.a198 = 888;
    t.a186 = 967;
    t.a195 = 888;
    t.a187 = 831;
    t.a188 = 873;
    t.a189 = 927;
    t.a190 = 970;
    t.a191 = 918;
  });
});
exports.getMetrics = getMetrics;

/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;

var _util = __w_pdfjs_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SEED = 0xc3d2e1f0;
var MASK_HIGH = 0xffff0000;
var MASK_LOW = 0xffff;

var MurmurHash3_64 = /*#__PURE__*/function () {
  function MurmurHash3_64(seed) {
    _classCallCheck(this, MurmurHash3_64);

    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }

  _createClass(MurmurHash3_64, [{
    key: "update",
    value: function update(input) {
      var data, length;

      if ((0, _util.isString)(input)) {
        data = new Uint8Array(input.length * 2);
        length = 0;

        for (var i = 0, ii = input.length; i < ii; i++) {
          var code = input.charCodeAt(i);

          if (code <= 0xff) {
            data[length++] = code;
          } else {
            data[length++] = code >>> 8;
            data[length++] = code & 0xff;
          }
        }
      } else if ((0, _util.isArrayBuffer)(input)) {
        data = input.slice();
        length = data.byteLength;
      } else {
        throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
      }

      var blockCounts = length >> 2;
      var tailLength = length - blockCounts * 4;
      var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
      var k1 = 0,
          k2 = 0;
      var h1 = this.h1,
          h2 = this.h2;
      var C1 = 0xcc9e2d51,
          C2 = 0x1b873593;
      var C1_LOW = C1 & MASK_LOW,
          C2_LOW = C2 & MASK_LOW;

      for (var _i = 0; _i < blockCounts; _i++) {
        if (_i & 1) {
          k1 = dataUint32[_i];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 0xe6546b64;
        } else {
          k2 = dataUint32[_i];
          k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
          k2 = k2 << 15 | k2 >>> 17;
          k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
          h2 ^= k2;
          h2 = h2 << 13 | h2 >>> 19;
          h2 = h2 * 5 + 0xe6546b64;
        }
      }

      k1 = 0;

      switch (tailLength) {
        case 3:
          k1 ^= data[blockCounts * 4 + 2] << 16;

        case 2:
          k1 ^= data[blockCounts * 4 + 1] << 8;

        case 1:
          k1 ^= data[blockCounts * 4];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;

          if (blockCounts & 1) {
            h1 ^= k1;
          } else {
            h2 ^= k1;
          }

      }

      this.h1 = h1;
      this.h2 = h2;
    }
  }, {
    key: "hexdigest",
    value: function hexdigest() {
      var h1 = this.h1,
          h2 = this.h2;
      h1 ^= h2 >>> 1;
      h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
      h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
      h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      var hex1 = (h1 >>> 0).toString(16),
          hex2 = (h2 >>> 0).toString(16);
      return hex1.padStart(8, "0") + hex2.padStart(8, "0");
    }
  }]);

  return MurmurHash3_64;
}();

exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OperatorList = void 0;

var _util = __w_pdfjs_require__(4);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var QueueOptimizer = function QueueOptimizerClosure() {
  function addState(parentState, pattern, checkFn, iterateFn, processFn) {
    var state = parentState;

    for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
      var item = pattern[i];
      state = state[item] || (state[item] = []);
    }

    state[pattern[pattern.length - 1]] = {
      checkFn: checkFn,
      iterateFn: iterateFn,
      processFn: processFn
    };
  }

  function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
    var iFirstPIMXO = iFirstSave + 2;

    for (var i = 0; i < count; i++) {
      var arg = argsArray[iFirstPIMXO + 4 * i];
      var imageMask = arg.length === 1 && arg[0];

      if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
        fnArray[iFirstPIMXO + 4 * i] = _util.OPS.paintSolidColorImageMask;
        continue;
      }

      break;
    }

    return count - i;
  }

  var InitialState = [];
  addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
    var fnArray = context.fnArray;
    var iFirstSave = context.iCurr - 3;
    var pos = (i - iFirstSave) % 4;

    switch (pos) {
      case 0:
        return fnArray[i] === _util.OPS.save;

      case 1:
        return fnArray[i] === _util.OPS.transform;

      case 2:
        return fnArray[i] === _util.OPS.paintInlineImageXObject;

      case 3:
        return fnArray[i] === _util.OPS.restore;
    }

    throw new Error("iterateInlineImageGroup - invalid pos: ".concat(pos));
  }, function foundInlineImageGroup(context, i) {
    var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
    var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
    var MAX_WIDTH = 1000;
    var IMAGE_PADDING = 1;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIIXO = curr - 1;
    var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);

    if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
      return i - (i - iFirstSave) % 4;
    }

    var maxX = 0;
    var map = [],
        maxLineHeight = 0;
    var currentX = IMAGE_PADDING,
        currentY = IMAGE_PADDING;
    var q;

    for (q = 0; q < count; q++) {
      var transform = argsArray[iFirstTransform + (q << 2)];
      var img = argsArray[iFirstPIIXO + (q << 2)][0];

      if (currentX + img.width > MAX_WIDTH) {
        maxX = Math.max(maxX, currentX);
        currentY += maxLineHeight + 2 * IMAGE_PADDING;
        currentX = 0;
        maxLineHeight = 0;
      }

      map.push({
        transform: transform,
        x: currentX,
        y: currentY,
        w: img.width,
        h: img.height
      });
      currentX += img.width + 2 * IMAGE_PADDING;
      maxLineHeight = Math.max(maxLineHeight, img.height);
    }

    var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
    var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
    var imgData = new Uint8ClampedArray(imgWidth * imgHeight * 4);
    var imgRowSize = imgWidth << 2;

    for (q = 0; q < count; q++) {
      var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
      var rowSize = map[q].w << 2;
      var dataOffset = 0;
      var offset = map[q].x + map[q].y * imgWidth << 2;
      imgData.set(data.subarray(0, rowSize), offset - imgRowSize);

      for (var k = 0, kk = map[q].h; k < kk; k++) {
        imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
        dataOffset += rowSize;
        offset += imgRowSize;
      }

      imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);

      while (offset >= 0) {
        data[offset - 4] = data[offset];
        data[offset - 3] = data[offset + 1];
        data[offset - 2] = data[offset + 2];
        data[offset - 1] = data[offset + 3];
        data[offset + rowSize] = data[offset + rowSize - 4];
        data[offset + rowSize + 1] = data[offset + rowSize - 3];
        data[offset + rowSize + 2] = data[offset + rowSize - 2];
        data[offset + rowSize + 3] = data[offset + rowSize - 1];
        offset -= imgRowSize;
      }
    }

    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [{
      width: imgWidth,
      height: imgHeight,
      kind: _util.ImageKind.RGBA_32BPP,
      data: imgData
    }, map]);
    return iFirstSave + 1;
  });
  addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
    var fnArray = context.fnArray;
    var iFirstSave = context.iCurr - 3;
    var pos = (i - iFirstSave) % 4;

    switch (pos) {
      case 0:
        return fnArray[i] === _util.OPS.save;

      case 1:
        return fnArray[i] === _util.OPS.transform;

      case 2:
        return fnArray[i] === _util.OPS.paintImageMaskXObject;

      case 3:
        return fnArray[i] === _util.OPS.restore;
    }

    throw new Error("iterateImageMaskGroup - invalid pos: ".concat(pos));
  }, function foundImageMaskGroup(context, i) {
    var MIN_IMAGES_IN_MASKS_BLOCK = 10;
    var MAX_IMAGES_IN_MASKS_BLOCK = 100;
    var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIMXO = curr - 1;
    var count = Math.floor((i - iFirstSave) / 4);
    count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);

    if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
      return i - (i - iFirstSave) % 4;
    }

    var q;
    var isSameImage = false;
    var iTransform, transformArgs;
    var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
    var firstTransformArg0 = argsArray[iFirstTransform][0],
        firstTransformArg1 = argsArray[iFirstTransform][1],
        firstTransformArg2 = argsArray[iFirstTransform][2],
        firstTransformArg3 = argsArray[iFirstTransform][3];

    if (firstTransformArg1 === firstTransformArg2) {
      isSameImage = true;
      iTransform = iFirstTransform + 4;
      var iPIMXO = iFirstPIMXO + 4;

      for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
        transformArgs = argsArray[iTransform];

        if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
          if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
            isSameImage = false;
          } else {
            count = q;
          }

          break;
        }
      }
    }

    if (isSameImage) {
      count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
      var positions = new Float32Array(count * 2);
      iTransform = iFirstTransform;

      for (q = 0; q < count; q++, iTransform += 4) {
        transformArgs = argsArray[iTransform];
        positions[q << 1] = transformArgs[4];
        positions[(q << 1) + 1] = transformArgs[5];
      }

      fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
      argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
    } else {
      count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
      var images = [];

      for (q = 0; q < count; q++) {
        transformArgs = argsArray[iFirstTransform + (q << 2)];
        var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
        images.push({
          data: maskParams.data,
          width: maskParams.width,
          height: maskParams.height,
          transform: transformArgs
        });
      }

      fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
      argsArray.splice(iFirstSave, count * 4, [images]);
    }

    return iFirstSave + 1;
  });
  addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) {
    var argsArray = context.argsArray;
    var iFirstTransform = context.iCurr - 2;
    return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
  }, function iterateImageGroup(context, i) {
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var iFirstSave = context.iCurr - 3;
    var pos = (i - iFirstSave) % 4;

    switch (pos) {
      case 0:
        return fnArray[i] === _util.OPS.save;

      case 1:
        if (fnArray[i] !== _util.OPS.transform) {
          return false;
        }

        var iFirstTransform = context.iCurr - 2;
        var firstTransformArg0 = argsArray[iFirstTransform][0];
        var firstTransformArg3 = argsArray[iFirstTransform][3];

        if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
          return false;
        }

        return true;

      case 2:
        if (fnArray[i] !== _util.OPS.paintImageXObject) {
          return false;
        }

        var iFirstPIXO = context.iCurr - 1;
        var firstPIXOArg0 = argsArray[iFirstPIXO][0];

        if (argsArray[i][0] !== firstPIXOArg0) {
          return false;
        }

        return true;

      case 3:
        return fnArray[i] === _util.OPS.restore;
    }

    throw new Error("iterateImageGroup - invalid pos: ".concat(pos));
  }, function (context, i) {
    var MIN_IMAGES_IN_BLOCK = 3;
    var MAX_IMAGES_IN_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIXO = curr - 1;
    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
    var firstTransformArg0 = argsArray[iFirstTransform][0];
    var firstTransformArg3 = argsArray[iFirstTransform][3];
    var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);

    if (count < MIN_IMAGES_IN_BLOCK) {
      return i - (i - iFirstSave) % 4;
    }

    var positions = new Float32Array(count * 2);
    var iTransform = iFirstTransform;

    for (var q = 0; q < count; q++, iTransform += 4) {
      var transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }

    var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, args);
    return iFirstSave + 1;
  });
  addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) {
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var iFirstSave = context.iCurr - 4;
    var pos = (i - iFirstSave) % 5;

    switch (pos) {
      case 0:
        return fnArray[i] === _util.OPS.beginText;

      case 1:
        return fnArray[i] === _util.OPS.setFont;

      case 2:
        return fnArray[i] === _util.OPS.setTextMatrix;

      case 3:
        if (fnArray[i] !== _util.OPS.showText) {
          return false;
        }

        var iFirstSetFont = context.iCurr - 3;
        var firstSetFontArg0 = argsArray[iFirstSetFont][0];
        var firstSetFontArg1 = argsArray[iFirstSetFont][1];

        if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
          return false;
        }

        return true;

      case 4:
        return fnArray[i] === _util.OPS.endText;
    }

    throw new Error("iterateShowTextGroup - invalid pos: ".concat(pos));
  }, function (context, i) {
    var MIN_CHARS_IN_BLOCK = 3;
    var MAX_CHARS_IN_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstBeginText = curr - 4;
    var iFirstSetFont = curr - 3;
    var iFirstSetTextMatrix = curr - 2;
    var iFirstShowText = curr - 1;
    var iFirstEndText = curr;
    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
    var count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);

    if (count < MIN_CHARS_IN_BLOCK) {
      return i - (i - iFirstBeginText) % 5;
    }

    var iFirst = iFirstBeginText;

    if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
      count++;
      iFirst -= 5;
    }

    var iEndText = iFirst + 4;

    for (var q = 1; q < count; q++) {
      fnArray.splice(iEndText, 3);
      argsArray.splice(iEndText, 3);
      iEndText += 2;
    }

    return iEndText + 1;
  });

  function QueueOptimizer(queue) {
    this.queue = queue;
    this.state = null;
    this.context = {
      iCurr: 0,
      fnArray: queue.fnArray,
      argsArray: queue.argsArray
    };
    this.match = null;
    this.lastProcessed = 0;
  }

  QueueOptimizer.prototype = {
    _optimize: function _optimize() {
      var fnArray = this.queue.fnArray;
      var i = this.lastProcessed,
          ii = fnArray.length;
      var state = this.state;
      var match = this.match;

      if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
        this.lastProcessed = ii;
        return;
      }

      var context = this.context;

      while (i < ii) {
        if (match) {
          var iterate = (0, match.iterateFn)(context, i);

          if (iterate) {
            i++;
            continue;
          }

          i = (0, match.processFn)(context, i + 1);
          ii = fnArray.length;
          match = null;
          state = null;

          if (i >= ii) {
            break;
          }
        }

        state = (state || InitialState)[fnArray[i]];

        if (!state || Array.isArray(state)) {
          i++;
          continue;
        }

        context.iCurr = i;
        i++;

        if (state.checkFn && !(0, state.checkFn)(context)) {
          state = null;
          continue;
        }

        match = state;
        state = null;
      }

      this.state = state;
      this.match = match;
      this.lastProcessed = i;
    },
    push: function push(fn, args) {
      this.queue.fnArray.push(fn);
      this.queue.argsArray.push(args);

      this._optimize();
    },
    flush: function flush() {
      while (this.match) {
        var length = this.queue.fnArray.length;
        this.lastProcessed = (0, this.match.processFn)(this.context, length);
        this.match = null;
        this.state = null;

        this._optimize();
      }
    },
    reset: function reset() {
      this.state = null;
      this.match = null;
      this.lastProcessed = 0;
    }
  };
  return QueueOptimizer;
}();

var NullOptimizer = function NullOptimizerClosure() {
  function NullOptimizer(queue) {
    this.queue = queue;
  }

  NullOptimizer.prototype = {
    push: function push(fn, args) {
      this.queue.fnArray.push(fn);
      this.queue.argsArray.push(args);
    },
    flush: function flush() {},
    reset: function reset() {}
  };
  return NullOptimizer;
}();

var OperatorList = function OperatorListClosure() {
  var CHUNK_SIZE = 1000;
  var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;

  function OperatorList(intent, streamSink) {
    this._streamSink = streamSink;
    this.fnArray = [];
    this.argsArray = [];

    if (streamSink && intent !== "oplist") {
      this.optimizer = new QueueOptimizer(this);
    } else {
      this.optimizer = new NullOptimizer(this);
    }

    this.dependencies = new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = streamSink ? null : Promise.resolve();
  }

  OperatorList.prototype = {
    get length() {
      return this.argsArray.length;
    },

    get ready() {
      return this._resolved || this._streamSink.ready;
    },

    get totalLength() {
      return this._totalLength + this.length;
    },

    addOp: function addOp(fn, args) {
      this.optimizer.push(fn, args);
      this.weight++;

      if (this._streamSink) {
        if (this.weight >= CHUNK_SIZE) {
          this.flush();
        } else if (this.weight >= CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
          this.flush();
        }
      }
    },
    addDependency: function addDependency(dependency) {
      if (this.dependencies.has(dependency)) {
        return;
      }

      this.dependencies.add(dependency);
      this.addOp(_util.OPS.dependency, [dependency]);
    },
    addDependencies: function addDependencies(dependencies) {
      var _iterator = _createForOfIteratorHelper(dependencies),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dependency = _step.value;
          this.addDependency(dependency);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    addOpList: function addOpList(opList) {
      if (!(opList instanceof OperatorList)) {
        (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
        return;
      }

      var _iterator2 = _createForOfIteratorHelper(opList.dependencies),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var dependency = _step2.value;
          this.dependencies.add(dependency);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      for (var i = 0, ii = opList.length; i < ii; i++) {
        this.addOp(opList.fnArray[i], opList.argsArray[i]);
      }
    },
    getIR: function getIR() {
      return {
        fnArray: this.fnArray,
        argsArray: this.argsArray,
        length: this.length
      };
    },

    get _transfers() {
      var transfers = [];
      var fnArray = this.fnArray,
          argsArray = this.argsArray,
          length = this.length;

      for (var i = 0; i < length; i++) {
        switch (fnArray[i]) {
          case _util.OPS.paintInlineImageXObject:
          case _util.OPS.paintInlineImageXObjectGroup:
          case _util.OPS.paintImageMaskXObject:
            var arg = argsArray[i][0];
            ;

            if (!arg.cached) {
              transfers.push(arg.data.buffer);
            }

            break;
        }
      }

      return transfers;
    },

    flush: function flush() {
      var lastChunk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.optimizer.flush();
      var length = this.length;
      this._totalLength += length;

      this._streamSink.enqueue({
        fnArray: this.fnArray,
        argsArray: this.argsArray,
        lastChunk: lastChunk,
        length: length
      }, 1, this._transfers);

      this.dependencies.clear();
      this.fnArray.length = 0;
      this.argsArray.length = 0;
      this.weight = 0;
      this.optimizer.reset();
    }
  };
  return OperatorList;
}();

exports.OperatorList = OperatorList;

/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFImage = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _colorspace = __w_pdfjs_require__(153);

var _stream = __w_pdfjs_require__(142);

var _jpeg_stream = __w_pdfjs_require__(148);

var _jpx = __w_pdfjs_require__(151);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function decodeAndClamp(value, addend, coefficient, max) {
  value = addend + value * coefficient;

  if (value < 0) {
    value = 0;
  } else if (value > max) {
    value = max;
  }

  return value;
}

function resizeImageMask(src, bpc, w1, h1, w2, h2) {
  var length = w2 * h2;
  var dest;

  if (bpc <= 8) {
    dest = new Uint8Array(length);
  } else if (bpc <= 16) {
    dest = new Uint16Array(length);
  } else {
    dest = new Uint32Array(length);
  }

  var xRatio = w1 / w2;
  var yRatio = h1 / h2;
  var i,
      j,
      py,
      newIndex = 0,
      oldIndex;
  var xScaled = new Uint16Array(w2);
  var w1Scanline = w1;

  for (i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio);
  }

  for (i = 0; i < h2; i++) {
    py = Math.floor(i * yRatio) * w1Scanline;

    for (j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex];
    }
  }

  return dest;
}

var PDFImage = /*#__PURE__*/function () {
  function PDFImage(_ref) {
    var xref = _ref.xref,
        res = _ref.res,
        image = _ref.image,
        _ref$isInline = _ref.isInline,
        isInline = _ref$isInline === void 0 ? false : _ref$isInline,
        _ref$smask = _ref.smask,
        smask = _ref$smask === void 0 ? null : _ref$smask,
        _ref$mask = _ref.mask,
        mask = _ref$mask === void 0 ? null : _ref$mask,
        _ref$isMask = _ref.isMask,
        isMask = _ref$isMask === void 0 ? false : _ref$isMask,
        pdfFunctionFactory = _ref.pdfFunctionFactory,
        localColorSpaceCache = _ref.localColorSpaceCache;

    _classCallCheck(this, PDFImage);

    this.image = image;
    var dict = image.dict;
    var filter = dict.get("Filter");

    if ((0, _primitives.isName)(filter)) {
      switch (filter.name) {
        case "JPXDecode":
          var jpxImage = new _jpx.JpxImage();
          jpxImage.parseImageProperties(image.stream);
          image.stream.reset();
          image.width = jpxImage.width;
          image.height = jpxImage.height;
          image.bitsPerComponent = jpxImage.bitsPerComponent;
          image.numComps = jpxImage.componentsCount;
          break;

        case "JBIG2Decode":
          image.bitsPerComponent = 1;
          image.numComps = 1;
          break;
      }
    }

    var width = dict.get("Width", "W");
    var height = dict.get("Height", "H");

    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
      (0, _util.warn)("PDFImage - using the Width/Height of the image data, " + "rather than the image dictionary.");
      width = image.width;
      height = image.height;
    }

    if (width < 1 || height < 1) {
      throw new _util.FormatError("Invalid image width: ".concat(width, " or height: ").concat(height));
    }

    this.width = width;
    this.height = height;
    this.interpolate = dict.get("Interpolate", "I") || false;
    this.imageMask = dict.get("ImageMask", "IM") || false;
    this.matte = dict.get("Matte") || false;
    var bitsPerComponent = image.bitsPerComponent;

    if (!bitsPerComponent) {
      bitsPerComponent = dict.get("BitsPerComponent", "BPC");

      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          throw new _util.FormatError("Bits per component missing in image: ".concat(this.imageMask));
        }
      }
    }

    this.bpc = bitsPerComponent;

    if (!this.imageMask) {
      var colorSpace = dict.getRaw("ColorSpace") || dict.getRaw("CS");

      if (!colorSpace) {
        (0, _util.info)("JPX images (which do not require color spaces)");

        switch (image.numComps) {
          case 1:
            colorSpace = _primitives.Name.get("DeviceGray");
            break;

          case 3:
            colorSpace = _primitives.Name.get("DeviceRGB");
            break;

          case 4:
            colorSpace = _primitives.Name.get("DeviceCMYK");
            break;

          default:
            throw new Error("JPX images with ".concat(image.numComps, " ") + "color components not supported.");
        }
      }

      this.colorSpace = _colorspace.ColorSpace.parse({
        cs: colorSpace,
        xref: xref,
        resources: isInline ? res : null,
        pdfFunctionFactory: pdfFunctionFactory,
        localColorSpaceCache: localColorSpaceCache
      });
      this.numComps = this.colorSpace.numComps;
    }

    this.decode = dict.getArray("Decode", "D");
    this.needsDecode = false;

    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      var max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      var isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";

      for (var i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        var dmin = this.decode[i];
        var dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
      }
    }

    if (smask) {
      this.smask = new PDFImage({
        xref: xref,
        res: res,
        image: smask,
        isInline: isInline,
        pdfFunctionFactory: pdfFunctionFactory,
        localColorSpaceCache: localColorSpaceCache
      });
    } else if (mask) {
      if ((0, _primitives.isStream)(mask)) {
        var maskDict = mask.dict,
            imageMask = maskDict.get("ImageMask", "IM");

        if (!imageMask) {
          (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
        } else {
          this.mask = new PDFImage({
            xref: xref,
            res: res,
            image: mask,
            isInline: isInline,
            isMask: true,
            pdfFunctionFactory: pdfFunctionFactory,
            localColorSpaceCache: localColorSpaceCache
          });
        }
      } else {
        this.mask = mask;
      }
    }
  }

  _createClass(PDFImage, [{
    key: "drawWidth",
    get: function get() {
      return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
    }
  }, {
    key: "drawHeight",
    get: function get() {
      return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
    }
  }, {
    key: "decodeBuffer",
    value: function decodeBuffer(buffer) {
      var bpc = this.bpc;
      var numComps = this.numComps;
      var decodeAddends = this.decodeAddends;
      var decodeCoefficients = this.decodeCoefficients;
      var max = (1 << bpc) - 1;
      var i, ii;

      if (bpc === 1) {
        for (i = 0, ii = buffer.length; i < ii; i++) {
          buffer[i] = +!buffer[i];
        }

        return;
      }

      var index = 0;

      for (i = 0, ii = this.width * this.height; i < ii; i++) {
        for (var j = 0; j < numComps; j++) {
          buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
          index++;
        }
      }
    }
  }, {
    key: "getComponents",
    value: function getComponents(buffer) {
      var bpc = this.bpc;

      if (bpc === 8) {
        return buffer;
      }

      var width = this.width;
      var height = this.height;
      var numComps = this.numComps;
      var length = width * height * numComps;
      var bufferPos = 0;
      var output;

      if (bpc <= 8) {
        output = new Uint8Array(length);
      } else if (bpc <= 16) {
        output = new Uint16Array(length);
      } else {
        output = new Uint32Array(length);
      }

      var rowComps = width * numComps;
      var max = (1 << bpc) - 1;
      var i = 0,
          ii,
          buf;

      if (bpc === 1) {
        var mask, loop1End, loop2End;

        for (var j = 0; j < height; j++) {
          loop1End = i + (rowComps & ~7);
          loop2End = i + rowComps;

          while (i < loop1End) {
            buf = buffer[bufferPos++];
            output[i] = buf >> 7 & 1;
            output[i + 1] = buf >> 6 & 1;
            output[i + 2] = buf >> 5 & 1;
            output[i + 3] = buf >> 4 & 1;
            output[i + 4] = buf >> 3 & 1;
            output[i + 5] = buf >> 2 & 1;
            output[i + 6] = buf >> 1 & 1;
            output[i + 7] = buf & 1;
            i += 8;
          }

          if (i < loop2End) {
            buf = buffer[bufferPos++];
            mask = 128;

            while (i < loop2End) {
              output[i++] = +!!(buf & mask);
              mask >>= 1;
            }
          }
        }
      } else {
        var bits = 0;
        buf = 0;

        for (i = 0, ii = length; i < ii; ++i) {
          if (i % rowComps === 0) {
            buf = 0;
            bits = 0;
          }

          while (bits < bpc) {
            buf = buf << 8 | buffer[bufferPos++];
            bits += 8;
          }

          var remainingBits = bits - bpc;
          var value = buf >> remainingBits;

          if (value < 0) {
            value = 0;
          } else if (value > max) {
            value = max;
          }

          output[i] = value;
          buf = buf & (1 << remainingBits) - 1;
          bits = remainingBits;
        }
      }

      return output;
    }
  }, {
    key: "fillOpacity",
    value: function fillOpacity(rgbaBuf, width, height, actualHeight, image) {
      var smask = this.smask;
      var mask = this.mask;
      var alphaBuf, sw, sh, i, ii, j;

      if (smask) {
        sw = smask.width;
        sh = smask.height;
        alphaBuf = new Uint8ClampedArray(sw * sh);
        smask.fillGrayBuffer(alphaBuf);

        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
        }
      } else if (mask) {
        if (mask instanceof PDFImage) {
          sw = mask.width;
          sh = mask.height;
          alphaBuf = new Uint8ClampedArray(sw * sh);
          mask.numComps = 1;
          mask.fillGrayBuffer(alphaBuf);

          for (i = 0, ii = sw * sh; i < ii; ++i) {
            alphaBuf[i] = 255 - alphaBuf[i];
          }

          if (sw !== width || sh !== height) {
            alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
          }
        } else if (Array.isArray(mask)) {
          alphaBuf = new Uint8ClampedArray(width * height);
          var numComps = this.numComps;

          for (i = 0, ii = width * height; i < ii; ++i) {
            var opacity = 0;
            var imageOffset = i * numComps;

            for (j = 0; j < numComps; ++j) {
              var color = image[imageOffset + j];
              var maskOffset = j * 2;

              if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                opacity = 255;
                break;
              }
            }

            alphaBuf[i] = opacity;
          }
        } else {
          throw new _util.FormatError("Unknown mask format.");
        }
      }

      if (alphaBuf) {
        for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
          rgbaBuf[j] = alphaBuf[i];
        }
      } else {
        for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
          rgbaBuf[j] = 255;
        }
      }
    }
  }, {
    key: "undoPreblend",
    value: function undoPreblend(buffer, width, height) {
      var matte = this.smask && this.smask.matte;

      if (!matte) {
        return;
      }

      var matteRgb = this.colorSpace.getRgb(matte, 0);
      var matteR = matteRgb[0];
      var matteG = matteRgb[1];
      var matteB = matteRgb[2];
      var length = width * height * 4;

      for (var i = 0; i < length; i += 4) {
        var alpha = buffer[i + 3];

        if (alpha === 0) {
          buffer[i] = 255;
          buffer[i + 1] = 255;
          buffer[i + 2] = 255;
          continue;
        }

        var k = 255 / alpha;
        buffer[i] = (buffer[i] - matteR) * k + matteR;
        buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
        buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
      }
    }
  }, {
    key: "createImageData",
    value: function createImageData() {
      var forceRGBA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var drawWidth = this.drawWidth;
      var drawHeight = this.drawHeight;
      var imgData = {
        width: drawWidth,
        height: drawHeight,
        kind: 0,
        data: null
      };
      var numComps = this.numComps;
      var originalWidth = this.width;
      var originalHeight = this.height;
      var bpc = this.bpc;
      var rowBytes = originalWidth * numComps * bpc + 7 >> 3;
      var imgArray;

      if (!forceRGBA) {
        var kind;

        if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
          kind = _util.ImageKind.GRAYSCALE_1BPP;
        } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
          kind = _util.ImageKind.RGB_24BPP;
        }

        if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
          imgData.kind = kind;
          imgArray = this.getImageBytes(originalHeight * rowBytes);

          if (this.image instanceof _stream.DecodeStream) {
            imgData.data = imgArray;
          } else {
            var newArray = new Uint8ClampedArray(imgArray.length);
            newArray.set(imgArray);
            imgData.data = newArray;
          }

          if (this.needsDecode) {
            (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
            var buffer = imgData.data;

            for (var i = 0, ii = buffer.length; i < ii; i++) {
              buffer[i] ^= 0xff;
            }
          }

          return imgData;
        }

        if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
          var imageLength = originalHeight * rowBytes;

          switch (this.colorSpace.name) {
            case "DeviceGray":
              imageLength *= 3;

            case "DeviceRGB":
            case "DeviceCMYK":
              imgData.kind = _util.ImageKind.RGB_24BPP;
              imgData.data = this.getImageBytes(imageLength, drawWidth, drawHeight, true);
              return imgData;
          }
        }
      }

      imgArray = this.getImageBytes(originalHeight * rowBytes);
      var actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
      var comps = this.getComponents(imgArray);
      var alpha01, maybeUndoPreblend;

      if (!forceRGBA && !this.smask && !this.mask) {
        imgData.kind = _util.ImageKind.RGB_24BPP;
        imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
        alpha01 = 0;
        maybeUndoPreblend = false;
      } else {
        imgData.kind = _util.ImageKind.RGBA_32BPP;
        imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
        alpha01 = 1;
        maybeUndoPreblend = true;
        this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
      }

      if (this.needsDecode) {
        this.decodeBuffer(comps);
      }

      this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);

      if (maybeUndoPreblend) {
        this.undoPreblend(imgData.data, drawWidth, actualHeight);
      }

      return imgData;
    }
  }, {
    key: "fillGrayBuffer",
    value: function fillGrayBuffer(buffer) {
      var numComps = this.numComps;

      if (numComps !== 1) {
        throw new _util.FormatError("Reading gray scale from a color image: ".concat(numComps));
      }

      var width = this.width;
      var height = this.height;
      var bpc = this.bpc;
      var rowBytes = width * numComps * bpc + 7 >> 3;
      var imgArray = this.getImageBytes(height * rowBytes);
      var comps = this.getComponents(imgArray);
      var i, length;

      if (bpc === 1) {
        length = width * height;

        if (this.needsDecode) {
          for (i = 0; i < length; ++i) {
            buffer[i] = comps[i] - 1 & 255;
          }
        } else {
          for (i = 0; i < length; ++i) {
            buffer[i] = -comps[i] & 255;
          }
        }

        return;
      }

      if (this.needsDecode) {
        this.decodeBuffer(comps);
      }

      length = width * height;
      var scale = 255 / ((1 << bpc) - 1);

      for (i = 0; i < length; ++i) {
        buffer[i] = scale * comps[i];
      }
    }
  }, {
    key: "getImageBytes",
    value: function getImageBytes(length, drawWidth, drawHeight) {
      var forceRGB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.image.reset();
      this.image.drawWidth = drawWidth || this.width;
      this.image.drawHeight = drawHeight || this.height;
      this.image.forceRGB = !!forceRGB;
      return this.image.getBytes(length, true);
    }
  }], [{
    key: "buildImage",
    value: function () {
      var _buildImage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref2) {
        var xref, res, image, _ref2$isInline, isInline, pdfFunctionFactory, localColorSpaceCache, imageData, smaskData, maskData, smask, mask;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                xref = _ref2.xref, res = _ref2.res, image = _ref2.image, _ref2$isInline = _ref2.isInline, isInline = _ref2$isInline === void 0 ? false : _ref2$isInline, pdfFunctionFactory = _ref2.pdfFunctionFactory, localColorSpaceCache = _ref2.localColorSpaceCache;
                imageData = image;
                smaskData = null;
                maskData = null;
                smask = image.dict.get("SMask");
                mask = image.dict.get("Mask");

                if (smask) {
                  smaskData = smask;
                } else if (mask) {
                  if ((0, _primitives.isStream)(mask) || Array.isArray(mask)) {
                    maskData = mask;
                  } else {
                    (0, _util.warn)("Unsupported mask format.");
                  }
                }

                return _context.abrupt("return", new PDFImage({
                  xref: xref,
                  res: res,
                  image: imageData,
                  isInline: isInline,
                  smask: smaskData,
                  mask: maskData,
                  pdfFunctionFactory: pdfFunctionFactory,
                  localColorSpaceCache: localColorSpaceCache
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function buildImage(_x) {
        return _buildImage.apply(this, arguments);
      }

      return buildImage;
    }()
  }, {
    key: "createMask",
    value: function createMask(_ref3) {
      var imgArray = _ref3.imgArray,
          width = _ref3.width,
          height = _ref3.height,
          imageIsFromDecodeStream = _ref3.imageIsFromDecodeStream,
          inverseDecode = _ref3.inverseDecode;
      var computedLength = (width + 7 >> 3) * height;
      var actualLength = imgArray.byteLength;
      var haveFullData = computedLength === actualLength;
      var data, i;

      if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
        data = imgArray;
      } else if (!inverseDecode) {
        data = new Uint8ClampedArray(actualLength);
        data.set(imgArray);
      } else {
        data = new Uint8ClampedArray(computedLength);
        data.set(imgArray);

        for (i = actualLength; i < computedLength; i++) {
          data[i] = 0xff;
        }
      }

      if (inverseDecode) {
        for (i = 0; i < actualLength; i++) {
          data[i] ^= 0xff;
        }
      }

      return {
        data: data,
        width: width,
        height: height
      };
    }
  }]);

  return PDFImage;
}();

exports.PDFImage = PDFImage;

/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.incrementalUpdate = incrementalUpdate;
exports.writeDict = writeDict;

var _util = __w_pdfjs_require__(4);

var _primitives = __w_pdfjs_require__(135);

var _core_utils = __w_pdfjs_require__(138);

var _xml_parser = __w_pdfjs_require__(177);

var _crypto = __w_pdfjs_require__(152);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function writeDict(dict, buffer, transform) {
  buffer.push("<<");

  var _iterator = _createForOfIteratorHelper(dict.getKeys()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      buffer.push(" /".concat((0, _core_utils.escapePDFName)(key), " "));
      writeValue(dict.getRaw(key), buffer, transform);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  buffer.push(">>");
}

function writeStream(stream, buffer, transform) {
  writeDict(stream.dict, buffer, transform);
  buffer.push(" stream\n");
  var string = (0, _util.bytesToString)(stream.getBytes());

  if (transform !== null) {
    string = transform.encryptString(string);
  }

  buffer.push(string);
  buffer.push("\nendstream\n");
}

function writeArray(array, buffer, transform) {
  buffer.push("[");
  var first = true;

  var _iterator2 = _createForOfIteratorHelper(array),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var val = _step2.value;

      if (!first) {
        buffer.push(" ");
      } else {
        first = false;
      }

      writeValue(val, buffer, transform);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  buffer.push("]");
}

function numberToString(value) {
  if (Number.isInteger(value)) {
    return value.toString();
  }

  var roundedValue = Math.round(value * 100);

  if (roundedValue % 100 === 0) {
    return (roundedValue / 100).toString();
  }

  if (roundedValue % 10 === 0) {
    return value.toFixed(1);
  }

  return value.toFixed(2);
}

function writeValue(value, buffer, transform) {
  if ((0, _primitives.isName)(value)) {
    buffer.push("/".concat((0, _core_utils.escapePDFName)(value.name)));
  } else if ((0, _primitives.isRef)(value)) {
    buffer.push("".concat(value.num, " ").concat(value.gen, " R"));
  } else if (Array.isArray(value)) {
    writeArray(value, buffer, transform);
  } else if (typeof value === "string") {
    if (transform !== null) {
      value = transform.encryptString(value);
    }

    buffer.push("(".concat((0, _util.escapeString)(value), ")"));
  } else if (typeof value === "number") {
    buffer.push(numberToString(value));
  } else if ((0, _primitives.isDict)(value)) {
    writeDict(value, buffer, transform);
  } else if ((0, _primitives.isStream)(value)) {
    writeStream(value, buffer, transform);
  }
}

function writeInt(number, size, offset, buffer) {
  for (var i = size + offset - 1; i > offset - 1; i--) {
    buffer[i] = number & 0xff;
    number >>= 8;
  }

  return offset + size;
}

function writeString(string, offset, buffer) {
  for (var i = 0, len = string.length; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i) & 0xff;
  }
}

function computeMD5(filesize, xrefInfo) {
  var time = Math.floor(Date.now() / 1000);
  var filename = xrefInfo.filename || "";
  var md5Buffer = [time.toString(), filename, filesize.toString()];
  var md5BufferLen = md5Buffer.reduce(function (a, str) {
    return a + str.length;
  }, 0);

  for (var _i = 0, _Object$values = Object.values(xrefInfo.info); _i < _Object$values.length; _i++) {
    var value = _Object$values[_i];
    md5Buffer.push(value);
    md5BufferLen += value.length;
  }

  var array = new Uint8Array(md5BufferLen);
  var offset = 0;

  for (var _i2 = 0, _md5Buffer = md5Buffer; _i2 < _md5Buffer.length; _i2++) {
    var str = _md5Buffer[_i2];
    writeString(str, offset, array);
    offset += str.length;
  }

  return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
}

function updateXFA(datasetsRef, newRefs, xref) {
  if (datasetsRef === null || xref === null) {
    return;
  }

  var datasets = xref.fetchIfRef(datasetsRef);
  var str = (0, _util.bytesToString)(datasets.getBytes());
  var xml = new _xml_parser.SimpleXMLParser({
    hasAttributes: true
  }).parseFromString(str);

  var _iterator3 = _createForOfIteratorHelper(newRefs),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var xfa = _step3.value.xfa;

      if (!xfa) {
        continue;
      }

      var path = xfa.path,
          value = xfa.value;

      if (!path) {
        continue;
      }

      var node = xml.documentElement.searchNode((0, _core_utils.parseXFAPath)(path), 0);

      if (node) {
        node.childNodes = [new _xml_parser.SimpleDOMNode("#text", value)];
      } else {
        (0, _util.warn)("Node not found for path: ".concat(path));
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var buffer = [];
  xml.documentElement.dump(buffer);
  var updatedXml = buffer.join("");
  var encrypt = xref.encrypt;

  if (encrypt) {
    var transform = encrypt.createCipherTransform(datasetsRef.num, datasetsRef.gen);
    updatedXml = transform.encryptString(updatedXml);
  }

  var data = "".concat(datasetsRef.num, " ").concat(datasetsRef.gen, " obj\n") + "<< /Type /EmbeddedFile /Length ".concat(updatedXml.length, ">>\nstream\n") + updatedXml + "\nendstream\nendobj\n";
  newRefs.push({
    ref: datasetsRef,
    data: data
  });
}

function incrementalUpdate(_ref) {
  var originalData = _ref.originalData,
      xrefInfo = _ref.xrefInfo,
      newRefs = _ref.newRefs,
      _ref$xref = _ref.xref,
      xref = _ref$xref === void 0 ? null : _ref$xref,
      _ref$datasetsRef = _ref.datasetsRef,
      datasetsRef = _ref$datasetsRef === void 0 ? null : _ref$datasetsRef;
  updateXFA(datasetsRef, newRefs, xref);
  var newXref = new _primitives.Dict(null);
  var refForXrefTable = xrefInfo.newRef;
  var buffer, baseOffset;
  var lastByte = originalData[originalData.length - 1];

  if (lastByte === 0x0a || lastByte === 0x0d) {
    buffer = [];
    baseOffset = originalData.length;
  } else {
    buffer = ["\n"];
    baseOffset = originalData.length + 1;
  }

  newXref.set("Size", refForXrefTable.num + 1);
  newXref.set("Prev", xrefInfo.startXRef);
  newXref.set("Type", _primitives.Name.get("XRef"));

  if (xrefInfo.rootRef !== null) {
    newXref.set("Root", xrefInfo.rootRef);
  }

  if (xrefInfo.infoRef !== null) {
    newXref.set("Info", xrefInfo.infoRef);
  }

  if (xrefInfo.encrypt !== null) {
    newXref.set("Encrypt", xrefInfo.encrypt);
  }

  newRefs.push({
    ref: refForXrefTable,
    data: ""
  });
  newRefs = newRefs.sort(function (a, b) {
    return a.ref.num - b.ref.num;
  });
  var xrefTableData = [[0, 1, 0xffff]];
  var indexes = [0, 1];
  var maxOffset = 0;

  var _iterator4 = _createForOfIteratorHelper(newRefs),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _step4.value,
          ref = _step4$value.ref,
          data = _step4$value.data;
      maxOffset = Math.max(maxOffset, baseOffset);
      xrefTableData.push([1, baseOffset, Math.min(ref.gen, 0xffff)]);
      baseOffset += data.length;
      indexes.push(ref.num);
      indexes.push(1);
      buffer.push(data);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  newXref.set("Index", indexes);

  if (xrefInfo.fileIds.length !== 0) {
    var md5 = computeMD5(baseOffset, xrefInfo);
    newXref.set("ID", [xrefInfo.fileIds[0], md5]);
  }

  var offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
  var sizes = [1, offsetSize, 2];
  var structSize = sizes[0] + sizes[1] + sizes[2];
  var tableLength = structSize * xrefTableData.length;
  newXref.set("W", sizes);
  newXref.set("Length", tableLength);
  buffer.push("".concat(refForXrefTable.num, " ").concat(refForXrefTable.gen, " obj\n"));
  writeDict(newXref, buffer, null);
  buffer.push(" stream\n");
  var bufferLen = buffer.reduce(function (a, str) {
    return a + str.length;
  }, 0);
  var footer = "\nendstream\nendobj\nstartxref\n".concat(baseOffset, "\n%%EOF\n");
  var array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
  array.set(originalData);
  var offset = originalData.length;

  var _iterator5 = _createForOfIteratorHelper(buffer),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var str = _step5.value;
      writeString(str, offset, array);
      offset += str.length;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  for (var _i3 = 0, _xrefTableData = xrefTableData; _i3 < _xrefTableData.length; _i3++) {
    var _xrefTableData$_i = _slicedToArray(_xrefTableData[_i3], 3),
        type = _xrefTableData$_i[0],
        objOffset = _xrefTableData$_i[1],
        gen = _xrefTableData$_i[2];

    offset = writeInt(type, sizes[0], offset, array);
    offset = writeInt(objOffset, sizes[1], offset, array);
    offset = writeInt(gen, sizes[2], offset, array);
  }

  writeString(footer, offset, array);
  return array;
}

/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;

var _util = __w_pdfjs_require__(4);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};
exports.XMLParserErrorCode = XMLParserErrorCode;

function isWhitespace(s, index) {
  var ch = s[index];
  return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
}

function isWhitespaceString(s) {
  for (var i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }

  return true;
}

var XMLParserBase = /*#__PURE__*/function () {
  function XMLParserBase() {
    _classCallCheck(this, XMLParserBase);
  }

  _createClass(XMLParserBase, [{
    key: "_resolveEntities",
    value: function _resolveEntities(s) {
      var _this = this;

      return s.replace(/&([^;]+);/g, function (all, entity) {
        if (entity.substring(0, 2) === "#x") {
          return String.fromCodePoint(parseInt(entity.substring(2), 16));
        } else if (entity.substring(0, 1) === "#") {
          return String.fromCodePoint(parseInt(entity.substring(1), 10));
        }

        switch (entity) {
          case "lt":
            return "<";

          case "gt":
            return ">";

          case "amp":
            return "&";

          case "quot":
            return '"';

          case "apos":
            return "'";
        }

        return _this.onResolveEntity(entity);
      });
    }
  }, {
    key: "_parseContent",
    value: function _parseContent(s, start) {
      var attributes = [];
      var pos = start;

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
        ++pos;
      }

      var name = s.substring(start, pos);
      skipWs();

      while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
        skipWs();
        var attrName = "",
            attrValue = "";

        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
          attrName += s[pos];
          ++pos;
        }

        skipWs();

        if (s[pos] !== "=") {
          return null;
        }

        ++pos;
        skipWs();
        var attrEndChar = s[pos];

        if (attrEndChar !== '"' && attrEndChar !== "'") {
          return null;
        }

        var attrEndIndex = s.indexOf(attrEndChar, ++pos);

        if (attrEndIndex < 0) {
          return null;
        }

        attrValue = s.substring(pos, attrEndIndex);
        attributes.push({
          name: attrName,
          value: this._resolveEntities(attrValue)
        });
        pos = attrEndIndex + 1;
        skipWs();
      }

      return {
        name: name,
        attributes: attributes,
        parsed: pos - start
      };
    }
  }, {
    key: "_parseProcessingInstruction",
    value: function _parseProcessingInstruction(s, start) {
      var pos = start;

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
        ++pos;
      }

      var name = s.substring(start, pos);
      skipWs();
      var attrStart = pos;

      while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
        ++pos;
      }

      var value = s.substring(attrStart, pos);
      return {
        name: name,
        value: value,
        parsed: pos - start
      };
    }
  }, {
    key: "parseXml",
    value: function parseXml(s) {
      var i = 0;

      while (i < s.length) {
        var ch = s[i];
        var j = i;

        if (ch === "<") {
          ++j;
          var ch2 = s[j];
          var q = void 0;

          switch (ch2) {
            case "/":
              ++j;
              q = s.indexOf(">", j);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onEndElement(s.substring(j, q));
              j = q + 1;
              break;

            case "?":
              ++j;

              var pi = this._parseProcessingInstruction(s, j);

              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                return;
              }

              this.onPi(pi.name, pi.value);
              j += pi.parsed + 2;
              break;

            case "!":
              if (s.substring(j + 1, j + 3) === "--") {
                q = s.indexOf("-->", j + 3);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedComment);
                  return;
                }

                this.onComment(s.substring(j + 3, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                q = s.indexOf("]]>", j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedCdat);
                  return;
                }

                this.onCdata(s.substring(j + 8, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                var q2 = s.indexOf("[", j + 8);
                var complexDoctype = false;
                q = s.indexOf(">", j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }

                if (q2 > 0 && q > q2) {
                  q = s.indexOf("]>", j + 8);

                  if (q < 0) {
                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                    return;
                  }

                  complexDoctype = true;
                }

                var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                this.onDoctype(doctypeContent);
                j = q + (complexDoctype ? 2 : 1);
              } else {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              break;

            default:
              var content = this._parseContent(s, j);

              if (content === null) {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              var isClosed = false;

              if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                isClosed = true;
              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onBeginElement(content.name, content.attributes, isClosed);
              j += content.parsed + (isClosed ? 2 : 1);
              break;
          }
        } else {
          while (j < s.length && s[j] !== "<") {
            j++;
          }

          var text = s.substring(i, j);
          this.onText(this._resolveEntities(text));
        }

        i = j;
      }
    }
  }, {
    key: "onResolveEntity",
    value: function onResolveEntity(name) {
      return "&".concat(name, ";");
    }
  }, {
    key: "onPi",
    value: function onPi(name, value) {}
  }, {
    key: "onComment",
    value: function onComment(text) {}
  }, {
    key: "onCdata",
    value: function onCdata(text) {}
  }, {
    key: "onDoctype",
    value: function onDoctype(doctypeContent) {}
  }, {
    key: "onText",
    value: function onText(text) {}
  }, {
    key: "onBeginElement",
    value: function onBeginElement(name, attributes, isEmpty) {}
  }, {
    key: "onEndElement",
    value: function onEndElement(name) {}
  }, {
    key: "onError",
    value: function onError(code) {}
  }]);

  return XMLParserBase;
}();

exports.XMLParserBase = XMLParserBase;

var SimpleDOMNode = /*#__PURE__*/function () {
  function SimpleDOMNode(nodeName, nodeValue) {
    _classCallCheck(this, SimpleDOMNode);

    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, "parentNode", {
      value: null,
      writable: true
    });
  }

  _createClass(SimpleDOMNode, [{
    key: "firstChild",
    get: function get() {
      return this.childNodes && this.childNodes[0];
    }
  }, {
    key: "nextSibling",
    get: function get() {
      var childNodes = this.parentNode.childNodes;

      if (!childNodes) {
        return undefined;
      }

      var index = childNodes.indexOf(this);

      if (index === -1) {
        return undefined;
      }

      return childNodes[index + 1];
    }
  }, {
    key: "textContent",
    get: function get() {
      if (!this.childNodes) {
        return this.nodeValue || "";
      }

      return this.childNodes.map(function (child) {
        return child.textContent;
      }).join("");
    }
  }, {
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes && this.childNodes.length > 0;
    }
  }, {
    key: "searchNode",
    value: function searchNode(paths, pos) {
      if (pos >= paths.length) {
        return this;
      }

      var component = paths[pos];
      var stack = [];
      var node = this;

      while (true) {
        if (component.name === node.nodeName) {
          if (component.pos === 0) {
            var res = node.searchNode(paths, pos + 1);

            if (res !== null) {
              return res;
            }
          } else if (stack.length === 0) {
            return null;
          } else {
            var _stack$pop = stack.pop(),
                _stack$pop2 = _slicedToArray(_stack$pop, 1),
                parent = _stack$pop2[0];

            var siblingPos = 0;

            var _iterator = _createForOfIteratorHelper(parent.childNodes),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var child = _step.value;

                if (component.name === child.nodeName) {
                  if (siblingPos === component.pos) {
                    return child.searchNode(paths, pos + 1);
                  }

                  siblingPos++;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return node.searchNode(paths, pos + 1);
          }
        }

        if (node.childNodes && node.childNodes.length !== 0) {
          stack.push([node, 0]);
          node = node.childNodes[0];
        } else if (stack.length === 0) {
          return null;
        } else {
          while (stack.length !== 0) {
            var _stack$pop3 = stack.pop(),
                _stack$pop4 = _slicedToArray(_stack$pop3, 2),
                _parent = _stack$pop4[0],
                currentPos = _stack$pop4[1];

            var newPos = currentPos + 1;

            if (newPos < _parent.childNodes.length) {
              stack.push([_parent, newPos]);
              node = _parent.childNodes[newPos];
              break;
            }
          }

          if (stack.length === 0) {
            return null;
          }
        }
      }
    }
  }, {
    key: "dump",
    value: function dump(buffer) {
      if (this.nodeName === "#text") {
        buffer.push((0, _util.encodeToXmlString)(this.nodeValue));
        return;
      }

      buffer.push("<".concat(this.nodeName));

      if (this.attributes) {
        var _iterator2 = _createForOfIteratorHelper(this.attributes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var attribute = _step2.value;
            buffer.push(" ".concat(attribute.name, "=\"").concat((0, _util.encodeToXmlString)(attribute.value), "\""));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      if (this.hasChildNodes()) {
        buffer.push(">");

        var _iterator3 = _createForOfIteratorHelper(this.childNodes),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var child = _step3.value;
            child.dump(buffer);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        buffer.push("</".concat(this.nodeName, ">"));
      } else if (this.nodeValue) {
        buffer.push(">".concat((0, _util.encodeToXmlString)(this.nodeValue), "</").concat(this.nodeName, ">"));
      } else {
        buffer.push("/>");
      }
    }
  }]);

  return SimpleDOMNode;
}();

exports.SimpleDOMNode = SimpleDOMNode;

var SimpleXMLParser = /*#__PURE__*/function (_XMLParserBase) {
  _inherits(SimpleXMLParser, _XMLParserBase);

  var _super = _createSuper(SimpleXMLParser);

  function SimpleXMLParser(_ref) {
    var _this2;

    var _ref$hasAttributes = _ref.hasAttributes,
        hasAttributes = _ref$hasAttributes === void 0 ? false : _ref$hasAttributes,
        _ref$lowerCaseName = _ref.lowerCaseName,
        lowerCaseName = _ref$lowerCaseName === void 0 ? false : _ref$lowerCaseName;

    _classCallCheck(this, SimpleXMLParser);

    _this2 = _super.call(this);
    _this2._currentFragment = null;
    _this2._stack = null;
    _this2._errorCode = XMLParserErrorCode.NoError;
    _this2._hasAttributes = hasAttributes;
    _this2._lowerCaseName = lowerCaseName;
    return _this2;
  }

  _createClass(SimpleXMLParser, [{
    key: "parseFromString",
    value: function parseFromString(data) {
      this._currentFragment = [];
      this._stack = [];
      this._errorCode = XMLParserErrorCode.NoError;
      this.parseXml(data);

      if (this._errorCode !== XMLParserErrorCode.NoError) {
        return undefined;
      }

      var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1),
          documentElement = _this$_currentFragmen[0];

      if (!documentElement) {
        return undefined;
      }

      return {
        documentElement: documentElement
      };
    }
  }, {
    key: "onText",
    value: function onText(text) {
      if (isWhitespaceString(text)) {
        return;
      }

      var node = new SimpleDOMNode("#text", text);

      this._currentFragment.push(node);
    }
  }, {
    key: "onCdata",
    value: function onCdata(text) {
      var node = new SimpleDOMNode("#text", text);

      this._currentFragment.push(node);
    }
  }, {
    key: "onBeginElement",
    value: function onBeginElement(name, attributes, isEmpty) {
      if (this._lowerCaseName) {
        name = name.toLowerCase();
      }

      var node = new SimpleDOMNode(name);
      node.childNodes = [];

      if (this._hasAttributes) {
        node.attributes = attributes;
      }

      this._currentFragment.push(node);

      if (isEmpty) {
        return;
      }

      this._stack.push(this._currentFragment);

      this._currentFragment = node.childNodes;
    }
  }, {
    key: "onEndElement",
    value: function onEndElement(name) {
      this._currentFragment = this._stack.pop() || [];
      var lastElement = this._currentFragment[this._currentFragment.length - 1];

      if (!lastElement) {
        return;
      }

      for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
        lastElement.childNodes[i].parentNode = lastElement;
      }
    }
  }, {
    key: "onError",
    value: function onError(code) {
      this._errorCode = code;
    }
  }]);

  return SimpleXMLParser;
}(XMLParserBase);

exports.SimpleXMLParser = SimpleXMLParser;

/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
var StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (_typeof(reason) !== "object" || reason === null) {
    return reason;
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

var MessageHandler = /*#__PURE__*/function () {
  function MessageHandler(sourceName, targetName, comObj) {
    var _this = this;

    _classCallCheck(this, MessageHandler);

    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.postMessageTransfers = true;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = function (event) {
      var data = event.data;

      if (data.targetName !== _this.sourceName) {
        return;
      }

      if (data.stream) {
        _this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        var callbackId = data.callbackId;
        var capability = _this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error("Cannot resolve callback ".concat(callbackId));
        }

        delete _this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      var action = _this.actionHandler[data.action];

      if (!action) {
        throw new Error("Unknown action from worker: ".concat(data.action));
      }

      if (data.callbackId) {
        var cbSourceName = _this.sourceName;
        var cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        _this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  _createClass(MessageHandler, [{
    key: "on",
    value: function on(actionName, handler) {
      var ah = this.actionHandler;

      if (ah[actionName]) {
        throw new Error("There is already an actionName called \"".concat(actionName, "\""));
      }

      ah[actionName] = handler;
    }
  }, {
    key: "send",
    value: function send(actionName, data, transfers) {
      this._postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        data: data
      }, transfers);
    }
  }, {
    key: "sendWithPromise",
    value: function sendWithPromise(actionName, data, transfers) {
      var callbackId = this.callbackId++;
      var capability = (0, _util.createPromiseCapability)();
      this.callbackCapabilities[callbackId] = capability;

      try {
        this._postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: actionName,
          callbackId: callbackId,
          data: data
        }, transfers);
      } catch (ex) {
        capability.reject(ex);
      }

      return capability.promise;
    }
  }, {
    key: "sendWithStream",
    value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
      var _this2 = this;

      var streamId = this.streamId++;
      var sourceName = this.sourceName;
      var targetName = this.targetName;
      var comObj = this.comObj;
      return new ReadableStream({
        start: function start(controller) {
          var startCapability = (0, _util.createPromiseCapability)();
          _this2.streamControllers[streamId] = {
            controller: controller,
            startCall: startCapability,
            pullCall: null,
            cancelCall: null,
            isClosed: false
          };

          _this2._postMessage({
            sourceName: sourceName,
            targetName: targetName,
            action: actionName,
            streamId: streamId,
            data: data,
            desiredSize: controller.desiredSize
          }, transfers);

          return startCapability.promise;
        },
        pull: function pull(controller) {
          var pullCapability = (0, _util.createPromiseCapability)();
          _this2.streamControllers[streamId].pullCall = pullCapability;
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.PULL,
            streamId: streamId,
            desiredSize: controller.desiredSize
          });
          return pullCapability.promise;
        },
        cancel: function cancel(reason) {
          (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
          var cancelCapability = (0, _util.createPromiseCapability)();
          _this2.streamControllers[streamId].cancelCall = cancelCapability;
          _this2.streamControllers[streamId].isClosed = true;
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.CANCEL,
            streamId: streamId,
            reason: wrapReason(reason)
          });
          return cancelCapability.promise;
        }
      }, queueingStrategy);
    }
  }, {
    key: "_createStreamSink",
    value: function _createStreamSink(data) {
      var self = this;
      var action = this.actionHandler[data.action];
      var streamId = data.streamId;
      var sourceName = this.sourceName;
      var targetName = data.sourceName;
      var comObj = this.comObj;
      var streamSink = {
        enqueue: function enqueue(chunk) {
          var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          var transfers = arguments.length > 2 ? arguments[2] : undefined;

          if (this.isCancelled) {
            return;
          }

          var lastDesiredSize = this.desiredSize;
          this.desiredSize -= size;

          if (lastDesiredSize > 0 && this.desiredSize <= 0) {
            this.sinkCapability = (0, _util.createPromiseCapability)();
            this.ready = this.sinkCapability.promise;
          }

          self._postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.ENQUEUE,
            streamId: streamId,
            chunk: chunk
          }, transfers);
        },
        close: function close() {
          if (this.isCancelled) {
            return;
          }

          this.isCancelled = true;
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.CLOSE,
            streamId: streamId
          });
          delete self.streamSinks[streamId];
        },
        error: function error(reason) {
          (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

          if (this.isCancelled) {
            return;
          }

          this.isCancelled = true;
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            stream: StreamKind.ERROR,
            streamId: streamId,
            reason: wrapReason(reason)
          });
        },
        sinkCapability: (0, _util.createPromiseCapability)(),
        onPull: null,
        onCancel: null,
        isCancelled: false,
        desiredSize: data.desiredSize,
        ready: null
      };
      streamSink.sinkCapability.resolve();
      streamSink.ready = streamSink.sinkCapability.promise;
      this.streamSinks[streamId] = streamSink;
      new Promise(function (resolve) {
        resolve(action(data.data, streamSink));
      }).then(function () {
        comObj.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: StreamKind.START_COMPLETE,
          streamId: streamId,
          success: true
        });
      }, function (reason) {
        comObj.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: StreamKind.START_COMPLETE,
          streamId: streamId,
          reason: wrapReason(reason)
        });
      });
    }
  }, {
    key: "_processStreamMessage",
    value: function _processStreamMessage(data) {
      var streamId = data.streamId;
      var sourceName = this.sourceName;
      var targetName = data.sourceName;
      var comObj = this.comObj;

      switch (data.stream) {
        case StreamKind.START_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].startCall.resolve();
          } else {
            this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
          }

          break;

        case StreamKind.PULL_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].pullCall.resolve();
          } else {
            this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
          }

          break;

        case StreamKind.PULL:
          if (!this.streamSinks[streamId]) {
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId: streamId,
              success: true
            });
            break;
          }

          if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
            this.streamSinks[streamId].sinkCapability.resolve();
          }

          this.streamSinks[streamId].desiredSize = data.desiredSize;
          var onPull = this.streamSinks[data.streamId].onPull;
          new Promise(function (resolve) {
            resolve(onPull && onPull());
          }).then(function () {
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId: streamId,
              success: true
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId: streamId,
              reason: wrapReason(reason)
            });
          });
          break;

        case StreamKind.ENQUEUE:
          (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

          if (this.streamControllers[streamId].isClosed) {
            break;
          }

          this.streamControllers[streamId].controller.enqueue(data.chunk);
          break;

        case StreamKind.CLOSE:
          (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

          if (this.streamControllers[streamId].isClosed) {
            break;
          }

          this.streamControllers[streamId].isClosed = true;
          this.streamControllers[streamId].controller.close();

          this._deleteStreamController(streamId);

          break;

        case StreamKind.ERROR:
          (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
          this.streamControllers[streamId].controller.error(wrapReason(data.reason));

          this._deleteStreamController(streamId);

          break;

        case StreamKind.CANCEL_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].cancelCall.resolve();
          } else {
            this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
          }

          this._deleteStreamController(streamId);

          break;

        case StreamKind.CANCEL:
          if (!this.streamSinks[streamId]) {
            break;
          }

          var onCancel = this.streamSinks[data.streamId].onCancel;
          new Promise(function (resolve) {
            resolve(onCancel && onCancel(wrapReason(data.reason)));
          }).then(function () {
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId: streamId,
              success: true
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName: sourceName,
              targetName: targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId: streamId,
              reason: wrapReason(reason)
            });
          });
          this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
          this.streamSinks[streamId].isCancelled = true;
          delete this.streamSinks[streamId];
          break;

        default:
          throw new Error("Unexpected stream case");
      }
    }
  }, {
    key: "_deleteStreamController",
    value: function () {
      var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(streamId) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
                  return capability && capability.promise;
                }));

              case 2:
                delete this.streamControllers[streamId];

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _deleteStreamController(_x) {
        return _deleteStreamController2.apply(this, arguments);
      }

      return _deleteStreamController;
    }()
  }, {
    key: "_postMessage",
    value: function _postMessage(message, transfers) {
      if (transfers && this.postMessageTransfers) {
        this.comObj.postMessage(message, transfers);
      } else {
        this.comObj.postMessage(message);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.comObj.removeEventListener("message", this._onComObjOnMessage);
    }
  }]);

  return MessageHandler;
}();

exports.MessageHandler = MessageHandler;

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorkerStream = void 0;

var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

var _util = __w_pdfjs_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PDFWorkerStream = /*#__PURE__*/function () {
  function PDFWorkerStream(msgHandler) {
    _classCallCheck(this, PDFWorkerStream);

    this._msgHandler = msgHandler;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _createClass(PDFWorkerStream, [{
    key: "getFullReader",
    value: function getFullReader() {
      (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
      return this._fullRequestReader;
    }
  }, {
    key: "getRangeReader",
    value: function getRangeReader(begin, end) {
      var reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);

      this._rangeRequestReaders.push(reader);

      return reader;
    }
  }, {
    key: "cancelAllRequests",
    value: function cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      var readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }
  }]);

  return PDFWorkerStream;
}();

exports.PDFWorkerStream = PDFWorkerStream;

var PDFWorkerStreamReader = /*#__PURE__*/function () {
  function PDFWorkerStreamReader(msgHandler) {
    var _this = this;

    _classCallCheck(this, PDFWorkerStreamReader);

    this._msgHandler = msgHandler;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;

    var readableStream = this._msgHandler.sendWithStream("GetReader");

    this._reader = readableStream.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(function (data) {
      _this._isStreamingSupported = data.isStreamingSupported;
      _this._isRangeSupported = data.isRangeSupported;
      _this._contentLength = data.contentLength;
    });
  }

  _createClass(PDFWorkerStreamReader, [{
    key: "headersReady",
    get: function get() {
      return this._headersReady;
    }
  }, {
    key: "contentLength",
    get: function get() {
      return this._contentLength;
    }
  }, {
    key: "isStreamingSupported",
    get: function get() {
      return this._isStreamingSupported;
    }
  }, {
    key: "isRangeSupported",
    get: function get() {
      return this._isRangeSupported;
    }
  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _yield$this$_reader$r, value, done;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._reader.read();

              case 2:
                _yield$this$_reader$r = _context.sent;
                value = _yield$this$_reader$r.value;
                done = _yield$this$_reader$r.done;

                if (!done) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 7:
                return _context.abrupt("return", {
                  value: value.buffer,
                  done: false
                });

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read() {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      this._reader.cancel(reason);
    }
  }]);

  return PDFWorkerStreamReader;
}();

var PDFWorkerStreamRangeReader = /*#__PURE__*/function () {
  function PDFWorkerStreamRangeReader(begin, end, msgHandler) {
    _classCallCheck(this, PDFWorkerStreamRangeReader);

    this._msgHandler = msgHandler;
    this.onProgress = null;

    var readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
      begin: begin,
      end: end
    });

    this._reader = readableStream.getReader();
  }

  _createClass(PDFWorkerStreamRangeReader, [{
    key: "isStreamingSupported",
    get: function get() {
      return false;
    }
  }, {
    key: "read",
    value: function () {
      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var _yield$this$_reader$r2, value, done;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._reader.read();

              case 2:
                _yield$this$_reader$r2 = _context2.sent;
                value = _yield$this$_reader$r2.value;
                done = _yield$this$_reader$r2.done;

                if (!done) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", {
                  value: undefined,
                  done: true
                });

              case 7:
                return _context2.abrupt("return", {
                  value: value.buffer,
                  done: false
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function read() {
        return _read2.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "cancel",
    value: function cancel(reason) {
      this._reader.cancel(reason);
    }
  }]);

  return PDFWorkerStreamRangeReader;
}();

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__w_pdfjs_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__w_pdfjs_require__.o(definition, key) && !__w_pdfjs_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__w_pdfjs_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__w_pdfjs_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__w_pdfjs_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(0);
/******/ })()
;
});
//# sourceMappingURL=pdf.worker.js.map